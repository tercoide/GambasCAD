' Gambas class file

'------------------------------------------------------------------------------

'Variables del formulario

' Benchmark
Public ShowBenchMarkInfo As Boolean = False
Public benGLAreaRefresh As Integer
Public benMouseTracking As Float

Public currentFile As String

Public CursorX As Integer
Public CursorY As Integer

Public Xr As Float
Public Yr As Float

Public PromtSlash As String = "|"
Public KeysAccumulator As String
Public TmrTicks As Integer

'Public SelectedWidth As Boolean

'Private PropertiesFlag As Boolean = False
Private PropertiesFlag As Boolean = True
Private RawFlag As Boolean = False

Public flgWheelCounter As Integer
Public InUse As Boolean                         ' variable auxiliar para evitar eventos indeseados
Public $hDrawTimer As New Timer As "DrawTimer"
Public $hSearchTimer As New Timer As "SearchTimer"
Public $hRecollectTimer As New Timer As "RecollectTimer"
Private $hOneSecondTimer As New Timer As "OneSecondTimer"

'' Printing stuff
Public MyPrinter As Printer

Public ftring As New Float[]
Public flxTrimmedLine As New Float[]
Public GLArea1 As GLArea' = gcd.Drawing.Sheet.GlSheet

Public tabViews As TabPanel

' GUI  stuff
Public oTags As New Collection
Public aThemes As New String[]
Public aLinux As Collection

Public fp As FProps

Public tskReSearch As TskSearch

Public ActivationCompleted As Boolean

'Public Printer1 As New Printer

Public Sub DrawTimer_Timer()

    glarea1.Refresh

End Sub

Public Sub RecollectTimer_Timer()

    clsEntities.CollectVisibleEntities()

End Sub

Public Sub MouseTracking_Kill()

    Return
    Debug "Reading"
    Dim sHandles As String[]
    sHandles = tskReSearch.Value
    'gcd.Drawing.HoveredEntities = tskReSearch.Value
    If sHandles.Count = 0 Then Return
    Debug "FMain: Found a " & gcd.Drawing.HoveredEntities[0].Gender & " at " & Str(Xr) & ";" & Str(Yr)

    If gcd.Drawing.HoveredEntities.Count > 0 Then
        gcd.Drawing.HoveredEntity = gcd.Drawing.HoveredEntities.First
        If gcd.Drawing.HoveredEntity.Container Then
            gcd.Drawing.HoveredInsert = gcd.Drawing.Sheet.Entities[gcd.Drawing.HoveredEntity.Container.id]
        Else
            gcd.Drawing.HoveredInsert = Null
        End If
    Else
        gcd.Drawing.HoveredEntity = Null
        gcd.Drawing.HoveredInsert = Null
    End If
    Debug "Found " & Str(gcd.Drawing.HoveredEntities.Count) & " entities below the mouse pointer"

End

Public Sub MouseTracking_Read(s As String)

    Debug "Reading"
    Debug "FMain: Found a " & s & " at " & Str(Xr) & ";" & Str(Yr)
    Return
    If gcd.Drawing.HoveredEntities.Count > 0 Then
        gcd.Drawing.HoveredEntity = gcd.Drawing.HoveredEntities.First
        If gcd.Drawing.HoveredEntity.Container Then
            gcd.Drawing.HoveredInsert = gcd.Drawing.Sheet.Entities[gcd.Drawing.HoveredEntity.Container.id]
        Else
            gcd.Drawing.HoveredInsert = Null
        End If
    Else
        gcd.Drawing.HoveredEntity = Null
        gcd.Drawing.HoveredInsert = Null
    End If
    Debug "Found " & Str(gcd.Drawing.HoveredEntities.Count) & " entities below the mouse pointer"

End

Public Sub SearchTimer_Timer()

    If clsMouseTracking.Searching Then Return
    '
    ' tskReSearch = New TskSearch
    ' tskReSearch.Xreal = xr
    ' tskReSearch.Yreal = yr
    ' Return
    ' gcd.Drawing.HoveredEntities = tskReSearch.EntitiesBelow
    gcd.Drawing.HoveredEntities = clsMouseTracking.CheckAboveEntities(Xr, Yr)

    If IsNull(gcd.Drawing.HoveredEntities) Then Return

    If gcd.Drawing.HoveredEntities.Count > 0 Then
        gcd.Drawing.HoveredEntity = gcd.Drawing.HoveredEntities.First
        If gcd.Drawing.HoveredEntity.Container Then
            gcd.Drawing.HoveredInsert = gcd.Drawing.Sheet.Entities[gcd.Drawing.HoveredEntity.Container.id]
        Else
            gcd.Drawing.HoveredInsert = Null
        End If
    Else
        gcd.Drawing.HoveredEntity = Null
        gcd.Drawing.HoveredInsert = Null
    End If
    'Debug "Found " & Str(gcd.Drawing.HoveredEntities.Count) & " entities below the mouse pointer"

End Sub

Public Sub Run() As Boolean

    ' acomodo el tamanio de los controles
    Me.tblLineWt.w = 128
    Me.tblLTypes.w = 128
    Me.mbtColors.w = 32
    Me.cmbDimStyle.w = 128
    Me.grdLayers.w = 146
    Me.Menus.HIde
    'Me.tbnLayersOnScreen.w = 96
    Me.tabDrawings[0].Visible = False

    'pnlCoords.W = pnlToolbarLeft.W
    'pnlBarBottom.H = 32

    'PanelBlockFit.Visible = False 'ag = CStr(PanelBlockFit.h)
    'PanelBlockFit.h = 0

    fMain.grdLayers.Rows.Count = 1
    fMain.grdLayers.Columns.Count = 5
    'fMain.grdLayers.Rows[0].Height = 32
    fMain.grdLayers.Rows.Height = 28
    fMain.grdLayers[0, 1].Alignment = Align.Left
    fMain.grdLayers[0, 2].Alignment = Align.Left
    fMain.grdLayers[0, 3].Alignment = Align.Left
    fMain.grdLayers[0, 4].Alignment = Align.Left
    fMain.grdLayers.Columns[0].w = 18 ' color
    fMain.grdLayers.Columns[1].w = 18 ' color
    fMain.grdLayers.Columns[2].w = 18 ' color
    fMain.grdLayers.Columns[3].w = 18 ' color
    fMain.grdLayers.Columns[4].w = 72 ' color

    ' fLayersOnScreen.Move(Me.grdLayers.x, Me.grdLayers.y + Me.grdLayers.h + 1)

    ' ' ToolButtonList  depre
    '
    ' tblLines.AddToolButton("tbnLine",, Picture.Load("/home/martin/GambasCAD/png/line.png"), "cadLine")
    ' tblLines.AddToolButton("tbnRay",, Picture.Load("/home/martin/GambasCAD/png/ray.png"), "cadRay")
    '
    ' tblCircles.AddToolButton("tbncircle",, Picture.Load("/home/martin/GambasCAD/png/circle3.png"), "cadcircle")
    ' tblCircles.AddToolButton("tbnellipse",, Picture.Load("/home/martin/GambasCAD/png/ellipse full.png"), "cadellipse")
    ' tblCircles.AddToolButton("tbnarc",, Picture.Load("/home/martin/GambasCAD/png/ARC.png"), "cadarc")

    '
    ' ' Armo la barra Inquiry
    '

    'Action_Activate("file_new")

    tmrAutosave.Delay = config.AutoSaveDelayMin * 1000 * 60
    'tmrAutosave.Enabled = True

    'Me.Visible = False

    LeerRecientes
    LoadButtons(32, 4)
    If Config.SplitterH.count = 2 Then Config.SplitterH.Add(32)
    If Config.SplitterH[2] = 0 Then Config.SplitterH[2] = 32
    splitterH.Layout = Config.SplitterH
    splRigth.Layout = Config.SplRigth

    fp = New FProps(pProps)
    fp.Expand = True

    'SetButtonPics(Me)
    'dsk.Update(pnlMayor)

    'splitterV.Layout = Config.SplitterV
    Me.Visible = True
    Me.Show()

    Me.Maximized = True

    ' If Config.SplitterH Then
    '     splitterH.Layout = Config.SplitterH
    ' Endif

    'Wait

    'glx.ClearColor(Config.BackgroundColor)

End

'' Escanea el control Padre y busca en el Path SVGs cuyo nombre coincidan con los controles hijos
'' excluidos las tres primeras letras, luego asigna la imagen Ej: tbnCopy <-- copy.svg
' Public Sub SetButtonPics(padre As Object, Optional sSvgPath As String = "")
'
'     Dim c As Control, o As Object
'     Dim sName As String, svgNames As String[]
'     Dim p As Picture
'     Dim i As Integer
'
'     If sSvgPath = "" Then sSvgPath = gcd.dirResources &/ "svg" &/ Config.IconFamily
'
'     For Each o In padre.Children
'         i = 0
'         Try i = o.Children.Count
'         If i > 0 Then               ' el control tiene hijos
'             SetButtonPics(o, sSvgPath)
'         Else                        ' busco si hay una imagen SVG
'             sName = Mid(o.name, 4)
'             svgNames = Dir(sSvgPath, sName & ".svg")
'
'             If svgNames.Count > 0 Then
'                 o.w = Config.ButtonSize
'                 o.h = Config.ButtonSize
'                 o.Picture = Image.Load(sSvgPath &/ svgNames[0]).Stretch(Config.ButtonSize, Config.ButtonSize).Picture
'                 o.text = ""
'             Endif
'         Endif
'     Next
'
' End

Public Function Action_Activate(sAction As String) As Boolean

    actions.ActionActivate(sAction)
    ' Select sAction
    '     Case "selectnew", "selectsingle", "selectrect", "selectpoly"
    '         SetToolsMode("properties")
    '         '' TODO: Definir como gestionar los bloques
    '         'Case "placeblock"
    '         'SetToolsMode("blocks")
    '     Case Else
    '         SetToolsMode("tools")
    ' End Select

End

Private Sub SetToolsMode(sMode As String)

    Dim obj As Object
    ' Dim fp As FProps  TERCO: esto tiene que ser global, lo defino mas arriba

    ' For Each obj In pnlToolbarLeft.Children
    '     obj.Visible = False
    '     If sMode = "properties" And Object.Type(obj) = "Panel" Then
    '         obj.Parent.Arrangement = Arrange.Vertical
    '         obj.Visible = True
    '         obj.Children.Clear
    fp = New FProps(pnlToolBarRigth)
    fp.Expand = True

    fp.FillProperties(gcd.Drawing.Sheet.EntitiesSelected)

    ' Else
    '     obj.Parent.Arrangement = Arrange.Row
    '     If sMode = "tools" And Object.Type(obj) = "Frame" Then
    '         obj.Visible = True
    '     Endif
    '     Endif
    ' Next

End

Public Sub LeerRecientes()

    'TODO esto deberia estar en un ini
    ' obtengo los lastopen

    Dim mnuLastOpen As New Menu(Me)
    Dim mnuFiles As Menu

    mnuLastOpen.Name = "LastOpenedFiles"
    mnuFiles = New Menu(mnuLastOpen)
    mnuFiles.Text = Config.FilesLastOpen1
    mnuFiles.Action = "file_open_" & Config.FilesLastOpen1

    mnuFiles = New Menu(mnuLastOpen)
    mnuFiles.Text = Config.FilesLastOpen2
    mnuFiles.Action = "file_open_" & config.filesLastOpen2

    mnuFiles = New Menu(mnuLastOpen)
    mnuFiles.Text = Config.FilesLastOpen3
    mnuFiles.Action = "file_open_" & config.filesLastOpen3

    mnuFiles = New Menu(mnuLastOpen)
    mnuFiles.Text = Config.FilesLastOpen4
    mnuFiles.Action = "file_open_" & config.filesLastOpen4

    mnuFiles = New Menu(mnuLastOpen)
    mnuFiles.Text = Config.FilesLastOpen5
    mnuFiles.Action = "file_open_" & config.filesLastOpen5

    mnuLastOpen.Name = "LastOpenedFiles"
    mnuFiles = New Menu(mnuLastOpen)
    mnuFiles.Text = Config.FilesLastOpen6
    mnuFiles.Action = "file_open_" & Config.FilesLastOpen6

    mnuFiles = New Menu(mnuLastOpen)
    mnuFiles.Text = Config.FilesLastOpen7
    mnuFiles.Action = "file_open_" & config.filesLastOpen7

    mnuFiles = New Menu(mnuLastOpen)
    mnuFiles.Text = Config.FilesLastOpen8
    mnuFiles.Action = "file_open_" & config.filesLastOpen8

    mnuFiles = New Menu(mnuLastOpen)
    mnuFiles.Text = Config.FilesLastOpen9
    mnuFiles.Action = "file_open_" & config.filesLastOpen9

    mnuFiles = New Menu(mnuLastOpen)
    mnuFiles.Text = Config.FilesLastOpen10
    mnuFiles.Action = "file_open_" & config.filesLastOpen10

    MenuButton1.Menu = "LastOpenedFiles"

End

Public Sub form_Close()

    actions.ExitProgram

End

Public Sub Form_Resize()

    splitterH.W = Panel1.W - pnlToolbarLeft.w
    ' 'Return
    ' tskReSearch = New TskSearch As "MouseTracking"
    ' tskReSearch.Xreal = xr
    ' tskReSearch.Yreal = yr

End

Public Sub glarea1_resize()

    If Not glx.Initialized Then glx.Init(glarea1)
    glx.Resize(glarea1)

End

Public Sub GLArea1_open()

End

Public Sub form_Arrange()

    ' Dim i As Integer
    ' Dim f As Font
    '
    ' f = panentities.Font
    ' i = f.Height

    FixPanelHeight(panEntities) ', ToolPanel1.Padding, ToolPanel1.Border)
    FixPanelHeight(panDimensions)
    FixPanelHeight(panBlocks)
    FixPanelHeight(panTools)
    FixPanelHeight(panInquiry)
    FixPanelHeight(pansnap)
    FixPanelHeight(panTopRigth)
    FixPanelHeight(panTop)
    'tskReSearch = New TskSearch As "MouseTracking"

End

Public Sub GLArea1_draw()

    Dim iParent As Integer
    Dim i, BackGroundColor As Integer
    Dim L As Layer
    Dim vpt As Viewport
    Dim e As Entity

    If Not gcd.DrawingReady Then Return
    Inc benGLAreaRefresh
    gl.Clear(gl.DEPTH_BUFFER_BIT Or gl.COLOR_BUFFER_BIT)

    gl.LoadIdentity
    gl.Translatef(gcd.Drawing.Sheet.PanX, gcd.Drawing.Sheet.PanY, 0)
    gl.Scalef(gcd.Drawing.Sheet.ScaleZoom, gcd.Drawing.Sheet.ScaleZoom, 1)

    '---------------------------------------------------
    gl.Translatef(-gcd.Drawing.Sheet.PanBaseRealX, -gcd.Drawing.Sheet.PanBaseRealY, 0)
    gcd.clsJob.Draw()
    gl.Translatef(gcd.Drawing.Sheet.PanBaseRealX, gcd.Drawing.Sheet.PanBaseRealY, 0)
    '--------------------------------------------------------------------

    If gcd.DrawHoveredEntity Then

        If gcd.Drawing.HoveredInsert Then
            gl.CallList(gcd.Drawing.HoveredInsert.glDrwListRemark)
        Else If gcd.Drawing.HoveredEntity Then
            If gcd.Drawing.HoveredEntity.glDrwListRemark > 0 Then
                gl.CallList(gcd.Drawing.HoveredEntity.glDrwListRemark)
            Else
                gcd.CCC[gcd.Drawing.HoveredEntity.Gender].DrawRemark(gcd.Drawing.HoveredEntity)
            End If
        End If
    End If

    'gcd.clsJob.Draw()
    If Not gcd.Drawing.Sheet.IsModel Then   ' Sheet view

        For Each vpt In gcd.Drawing.Sheet.Viewports
            If Not vpt.Visibile Then Continue
            gl.LoadIdentity

            ' el scissor no se ve afectado por las trnasformaciones!!!!!!!!
            ' se aplica al Viewport XLow,Ylow,Width,Heigth

            'glx.Rectangle2D(-GLArea1.W / 2 + gcd.XPix(vpt.X0), GLArea1.h / 2 - gcd.YPix(vpt.Y0), gcd.Pixels(vpt.X1 - vpt.x0), gcd.Pixels(vpt.Y1 - vpt.y0))

            gl.Scissor(gcd.XPix(vpt.X0), GLArea1.h - gcd.YPix(vpt.Y0), gcd.Pixels(Abs(vpt.X1 - vpt.x0)), gcd.Pixels(Abs(vpt.Y1 - vpt.y0)))

            gl.Translatef(gcd.Drawing.Sheet.PanX, gcd.Drawing.Sheet.PanY, 0)

            gl.Scalef(gcd.Drawing.Sheet.ScaleZoom, gcd.Drawing.Sheet.ScaleZoom, 1)

            gl.Translatef(vpt.PanX, vpt.PanY, 0)
            gl.Scalef(vpt.ScaleZoom, vpt.ScaleZoom, 1)

            gl.Enable(GL.sCISSOR_TEST)

            For Each L In vpt.Layers
                'For Each L In gcd.Drawing.Layers
                If L.Visible And Not l.Frozen Then
                    gl.CallList(L.glList)
                End If
            Next
            gl.Disable(gl.SCISSOR_TEST)
        Next

        'gl.Viewport(0, 0, gcd.Drawing.GLAreaInUse.W, gcd.Drawing.GLAreaInUse.h)

        gl.LoadIdentity

        gl.Translatef(gcd.Drawing.Sheet.PanX, gcd.Drawing.Sheet.PanY, 0)

        gl.Scalef(gcd.Drawing.Sheet.ScaleZoom, gcd.Drawing.Sheet.ScaleZoom, 1)

        ' For Each e In gcd.Drawing.Sheet.Entities
        '     If e.Visible Then gl.CallList(e.glDrwList)
        ' Next

        gl.CallList(gcd.Drawing.Sheet.GlListAllEntities)

        ' esto representa la hoja a imprimir

        If gcd.Drawing.Sheet.Viewport Then ' tenemos un viewport activo
            BackGroundColor = Color.LightGray
            glx.Rectangle2D(gcd.Drawing.Sheet.Viewport.x0, gcd.Drawing.Sheet.Viewport.Y0, gcd.Drawing.Sheet.Viewport.X1 - gcd.Drawing.Sheet.Viewport.x0, gcd.Drawing.Sheet.Viewport.y1 - gcd.Drawing.Sheet.Viewport.y0, gcd.Drawing.Sheet.BackGroundColor,,,,,,, 2)
        Else
            BackGroundColor = gcd.Drawing.Sheet.BackGroundColor
        End If

        ' depre porque esto no parece ser necesario
        'glx.Rectangle2D(0, 0, gcd.Drawing.Sheet.pPrintStyle.PaperSizeW, gcd.Drawing.Sheet.pPrintStyle.PaperSizeH, BackGroundColor,,,,,,, 2)

    Else ' Model view

        For Each L In gcd.Drawing.Layers
            If L.Visible And Not l.Frozen Then gl.CallList(L.glList)
        Next

    End If

    ' el orden del dibujo es importante en paint, porque una cosa tapa a la otra; en openGL aparentemente es al reves, lo primero se dibuja ultimo

    gl.PushMatrix()
    gl.Translatef(-gcd.Drawing.Sheet.PanBaseRealX, -gcd.Drawing.Sheet.PanBaseRealY, 0)

    ' If gcd.DrawBounds Then DrawingAIds.DrawPolygons

    'DrawingAIds.DrawCoordenadas

    DrawingAIds.DibujaHelper

    '
    'clsEntities.DrawArrays()

    ' POI dinamicos
    If gcd.Drawing.flgShowPOIinfo And gcd.Drawing.iEntity.Count > 0 Then

        Select gcd.Drawing.iEntity[2]
            Case gcd.poiMIdPoint
                glx.PolygonFilled([gcd.Drawing.iEntity[0] - gcd.Metros(4), gcd.Drawing.iEntity[1], gcd.Drawing.iEntity[0], gcd.Drawing.iEntity[1] + gcd.Metros(4), gcd.Drawing.iEntity[0] + gcd.Metros(4), gcd.Drawing.iEntity[1], gcd.Drawing.iEntity[0], gcd.Drawing.iEntity[1] - gcd.Metros(4)], Color.Blue, Color.Green)
            Case gcd.poiQuadrant
                glx.PolygonFilled([gcd.Drawing.iEntity[0] - gcd.Metros(6), gcd.Drawing.iEntity[1], gcd.Drawing.iEntity[0], gcd.Drawing.iEntity[1] + gcd.Metros(6), gcd.Drawing.iEntity[0] + gcd.Metros(6), gcd.Drawing.iEntity[1], gcd.Drawing.iEntity[0], gcd.Drawing.iEntity[1] - gcd.Metros(6)], Color.Cyan, Color.Cyan)

            Case 0
                ' nada
            Case gcd.poiCenter, gcd.poiBasePoint

                glx.CIRCLE([gcd.Drawing.iEntity[0], gcd.Drawing.iEntity[1]], gcd.Metros(4), Color.Cyan, True, False)
                'glx.Rectangle2D(gcd.Drawing.iEntity[0] - gcd.Metros(4), gcd.Drawing.iEntity[1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Blue,,,, Color.Blue, 1, 1)

            Case Else
                glx.Rectangle2D(gcd.Drawing.iEntity[0] - gcd.Metros(4), gcd.Drawing.iEntity[1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Blue,,,, Color.Blue, 1)
        End Select

    Endif

    If gcd.Drawing.GrIdActive Then
        gl.CallList(gcd.Drawing.GLListGrId)
    End If
    ' If gcd.flgNewPosition Then
    '     ReCollect
    '     gcd.flgNewPosition = False
    ' End If

    gl.PopMatrix()
    ' test area
    ' gl.LoadIdentity
    '
    Dim flx, flx2 As New Float[]
    ' flx = puntos.DashedLineStrip([0, 0, 100, 0, 200, 200, 300, 200], [5, -2.5], 1, 0)
    '
    ' glx.ARC(100, 0, Pi / 3, Color.red)
    ' glx.ARC(100, -Pi, Pi / 3, Color.blue)

    ' flx = puntos.Arc3Point(-0.275, 0.6, -0.282, 0.59, -0.3, 0.575)
    ' gl.Translatef(flx[0], flx[1], 0)
    ' glx.ARC(flx[2], flx[3], flx[4], color.Blue)
    ' gl.Translatef(-flx[0], -flx[1], 0)

    'glx.ARC(100, 0, Pi, Color.red)
    'glx.ARC(100, 0, Pi, Color.red)

    ' glx.DrawLines(flxTrimmedLine, color.blue)
    ' glx.DrawLines([0, 20, 0, -20], color.blue)
    ' glx.DrawLines([100, 20, 100, -20], color.blue)
    ' flx = puntos.DashedLineStrip([0, 0, -100, 0], [5, -2.5], 1, 0, True)
    ' glx.DrawLines(flx, color.blue)
    '
    ' Dim fi As Float
    ' For fi = 0 To 2 * Pi Step Pi / 32
    '     flx = puntos.DashedLineStrip([0, 0, 100 * Cos(fi), 100 * Sin(fi)], [5, -2.5], 1, 10, False)
    '     glx.DrawLines(flx, color.blue)
    '
    ' Next

    ' flx2 = [0, 0, 200, 0, 200, 100, 0, 100, 0, 0]
    ' glx.Polygon(flx2, Color.Blue)
    '
    '
    ' flx2 = puntos.LinePolyIntersection([-20, 20, 230, 55], flx2)
    ' flx = puntos.DashedLineStrip(flx2, [5, -2.5], 1, 3, False)
    ' glx.DrawLines(flx, color.red)
    '
    ' flx2 = [0, 0, 200, 0, 200, 100, 0, 100, 0, 0]
    '
    ' flx2 = puntos.LinePolyIntersection([230, 65, -20, 30], flx2)
    ' flx = puntos.DashedLineStrip(flx2, [5, -2.5], 1, 3, True)
    ' glx.DrawLines(flx, Color.Yellow)

End

' NUEVO Protocolo del Mouse para OpenGL: todo se envia a la clsJob actuante

Public Sub GLArea1_MouseDown()

    If Not gcd.drawingready Then Return
    If Mouse.Middle Then cadPan.MouseDown()
    gcd.clsJob.mouseDown()
    Redraw

End

' Public Sub GLPaper_MouseDown()
'
'     gcd.clsJob.mouseDown()
'
' End

Public Sub GLArea1_DblClick()

    If Not gcd.drawingready Then Return
    gcd.clsJob.DblClick()

End

Public Sub GLArea1_MouseMove()

    If Not gcd.drawingready Then Return
    'If flgWheelCounter > 0 Then Return

    Me.CursorX = Mouse.X
    Me.Cursory = Mouse.y
    If Not gcd.clsJob Then Return
    Xr = gcd.Xreal(Mouse.x)
    Yr = gcd.Yreal(Mouse.y)

    ' Universal:
    gcd.clsJob.MouseMove()

    'FIXME: ver esto
    ReSearch()

    'Me.lblCoordX.Text = Mouse.x & ":" & Mouse.y & " <-> " & Format(Xr, Config.FormatCoord) & " : " & Format(Yr, config.FormatInquiries)
    Me.lblCoordX.Text = "X: " & Mouse.x & " -> " & Format(Xr, Config.FormatCoord)
    Me.lblCoordY.Text = "Y: " & Mouse.y & " -> " & Format(Yr, config.FormatCoord)
    ' Me.lblCoordX.Refresh
    ' Me.lblCoordY.Refresh

    If Mouse.MIddle Then
        cadPan.MouseMove()
    Else If Mouse.Left Then

    Else If Mouse.Right Then

    Else
        ' If gcd.flgsearchingallowed Then
        '     gcd.Drawing.HoveredEntity = clsMouseTracking.CheckAboveEntity(Xr, Yr)
        '     If gcd.Drawing.HoveredEntity Then gcd.redraw
        '     ' If gcd.Drawing.HoveredEntityPrevious <> gcd.Drawing.HoveredEntity Then
        '     '     gcd.Drawing.HoveredEntityPrevious = gcd.Drawing.HoveredEntity
        '     '     gcd.Drawing.HoveredEntity = Null
        '     '
        '     ' Endif
        ' End If
        'ReSearch

    End If

    '   If gcd.clsJob.gender <> "Pan" Then
    '     gcd.clsJobPreZoom = gcd.clsJob
    '     gcd.clsJob = cadPan
    '     gcd.clsJob.Start()
    '     ' glarea1.Refresh  ' glarea1.Refresh
    '     '
    '     '
    '   Else
    '
    '     gcd.clsJob = gcd.clsJobPreZoom
    '
    '   End If
    '
    ' End If
    Redraw
    'glarea1.Refresh

End

Public Sub GLArea1_MouseUp()

    If Not gcd.drawingready Then Return
    If Mouse.Middle Then
        cadPan.MouseUp()
    Else
        gcd.clsJob.MouseUp()
    End If
    Redraw

End

' Public Sub GLPaper_MouseUp()
'
'     gcd.clsJob.MouseUp()
'
' End

Public Sub GLArea1_MouseWheel()

    ' If Not gcd.drawingready Then Return
    ' 2024
    Inc flgWheelCounter
    gcd.flgQuitSearch = True
    gcd.flgNewPosition = True
    gcd.clsJob.MouseWHEEL()

    tmrQuiet.Restart
    Dec flgWheelCounter

End

' Public Sub GLPaper_Draw()
'
'     Dim iParent As Integer
'     Dim i As Integer
'     Dim L As Layer
'
'     Dim vpt As Viewport
'     Dim e As Variant
'
'     If Not gcd.DrawingReady Then Return
'
'     glx.ClearColor(Color.Black) 'gcd.gColor[Color.Red))
'
'     gl.Clear(gl.DEPTH_BUFFER_BIT Or gl.COLOR_BUFFER_BIT)
'
'     gl.LoadIdentity
'
'     gl.Translatef(gcd.Drawing.CurrSheet.PanX, gcd.Drawing.CurrSheet.PanY, 0)
'
'     gl.Scalef(gcd.Drawing.CurrSheet.ScaleZoom, gcd.Drawing.CurrSheet.ScaleZoom, 1)
'
'     ' el orden del dibujo es importante en paint, porque una cosa tapa a la otra; en openGL aparentemente es al reves, lo primero se dibuja primero
'
'     ' Primero la grid
'     ' DrawingAids.DrawGrid
'
'     ' ' TEST
'     ' Dim fArcParams As Float[]
'     '
'     ' ' aqui podria usar una rutina de arco entre 3 puntos
'     ' fArcParams = puntos.Arc3Point(0, 0, -100, 50, -300, 20)
'     ' ' traslado el centro
'     ' gl.Translatef(fArcParams[0], fArcParams[1], 0)
'     ' glx.ARC(fArcParams[2], fArcParams[3], fArcParams[4] - fArcParams[3], Color.Blue, 1, 0)
'     ' gl.Translatef(-fArcParams[0], -fArcParams[1], 0)
'     ' fArcParams = Null
'     '
'
'     ' If gcd.Drawing.HoveredEntityPrevious Then
'     '     ' si no esta seleccionada, la resalto
'     '     'If Not arrEntities[iEntity[3]].Selected Then
'     '     'iParent = clsEntities.GetParentBlock(gcd.Drawing.iEntity[3]) ' esto verifica si tiene que resaltar el bloque completo
'     '
'     '     If gcd.DrawHoveredEntity Then gl.CallList(gcd.Drawing.HoveredEntityPrevious.glDrwListRemark)
'     '     '     Gcd.CCC[gcd.Drawing.HoveredEntityPrevious.gender].DrawRemark(gcd.Drawing.HoveredEntityPrevious)
'     '     ' End If
'     ' End If
'
'     ' If gcd.DrawHoveredEntity Then
'     '     If gcd.Drawing.HoveredEntity Then gl.CallList(gcd.Drawing.HoveredEntity.glDrwListRemark)
'     ' End If
'     ' DrawingAids.DrawCoordenadas
'     '
'     ' DrawingAids.DibujaHelper
'     '
'     ' gl.CallList(gcd.Drawing.GlListSelectedEntities)
'     glx.Rectangle2D(0, 0, gcd.Drawing.CurrSheet.pPrintStyle.PaperSizeW, gcd.Drawing.CurrSheet.pPrintStyle.PaperSizeH, gcd.Drawing.CurrSheet.BackGroundColor)
'
'     For Each vpt In gcd.Drawing.CurrSheet.vViewports
'         gl.LoadIdentity
'         gl.Translatef(vpt.PanX, vpt.PanY, 0)
'         gl.Scalef(vpt.ScaleZoom, vpt.ScaleZoom, 1)
'         gl.Scissor()
'         For Each L In vpt.Layers
'             If L.Visible Then gl.CallList(L.glList)
'         Next
'     Next
'
'     For Each e In gcd.Drawing.CurrSheet.Entities
'         gcd.CCC[e.gender].Draw(e)
'     Next
'
'     gcd.clsJob.Draw()
'
' End
'
' ' El objetivo es que el zoom dinamico se haga manteniendo el dibujo que esta en la pos del mouse
' Public Sub GLPaper_MouseWheel()
'
'     Dim px, py, dx, dy, factor As Float
'     ' chequeamos si vale la pena seguir dibujando la grid, o sea, menos de 3 pixels
'     ' Inc flgWheelCounter
'     ' Debug "Mouse weel", flgWheelCounter
'
'     ' TODO: revisar la siguiente linea
'     'If gcd.Pixels(FMain.GridSpacing) < 5 Then FMain.GridActive = False Else FMain.GridActive = True
'     '
'     ' px = gcd.Xreal(Mouse.x) ' posicion real en donde esta el mouse, previo al zoom
'     ' py = gcd.Yreal(Mouse.y)
'
'     ' TODO: , redondear para que la escala sea 1:100 1:75 1:50 etc
'
'     factor = (1 + 0.075 * Mouse.Delta)
'
'     gcd.Drawing.CurrSheet.ScaleZoom *= factor
'
'     Debug "ScaleZoom", gcd.Drawing.CurrSheet.ScaleZoom
'     '
'     ' dx = gcd.Xreal(Mouse.x) ' posicion real en donde esta el mouse, posterior al zoom
'     ' dy = gcd.Yreal(Mouse.y)
'
'     ' pero con ciertos limites TODO: imponer
'     ' If ScaleZoom < 0.001 Then ScaleZoom = 0.001
'     ' If ScaleZoom > 50 Then ScaleZoom = 50
'
'     ' nuevo metodo (el Pan esta en pixels)
'     ' gcd.Drawing.PanX += gcd.pixels(dx - px)
'     ' gcd.Drawing.PanY += gcd.pixels(dy - py)
'     '
'     ' gcd.flgNewPosition = True
'     '
'     ' gcd.redraw 'glarea1.Refresh
'     gcd.Drawing.CurrSheet.GLSheet.Refresh
'     ' despues de actualizar la pantalla, recolectamos las entidades visibles
'
'     ' Dec flgWheelCounter
'
' End

Public Sub tabFile_MouseWheel()

    Stop Event

End

Public Sub redraw()

    $hDrawTimer.Trigger

End

Public Sub ReSearch()

    ' If tskReSearch.Running Then Return
    '
    ' tskReSearch = New TskSearch
    ' tskReSearch.Xreal = xr
    ' tskReSearch.Yreal = yr
    ' Return
    If Not gcd.flgSearchingAllowed Then Return
    $hSearchTimer.Trigger

End

Public Sub ReCollect()

    $hRecollectTimer.Trigger

End

Public Sub CheckBestPOI()

End

' Public Sub txtInput_KeyRelease()
'
'     If Key.code = Key.Esc Then
'         txtInput.Hide
'         Me.SetFocus
'     End If
'
'     If (Key.code = Key.Enter) Or (Key.code = Key.Return) Then
'         gcd.clsJob.KeyText(txtInput.Text)
'
'         txtInput.Hide
'         Me.SetFocus
'     End If
'
' End
' Public Sub form_KeyPress()
'
'     If Key.Code = Key["C"] And If Key.Control Then
'         actions.ActionActivate("mentities-copy")
'     Else If Key.Code = Key["V"] And If Key.Control Then
'         actions.ActionActivate("mentities-paste")
'
'     Else
'         gcd.clsJob.KeyDown(Key.Code)
'
'     End If
'
' End

Public Sub form_KeyPress()

    Dim com As Variant
    Dim umx As Integer     '' Index in undo array
    Dim uEnty As Entity    '' Undo entity
    Dim aEnty, e As Entity    '' Actual entity
    Dim imx As Integer     '' Index in Entities array
    Dim SelectMode As Boolean
    Dim s As String
    ' Print Key.Code
    Dim t As Float = Timer

    ' If txtInput.Visible Then Return

    Select Key.Code

        Case Key.Enter, Key.Return
            Debug KeysAccumulator
            ' txtInput.Visible = False
            ' gcd.clsJob.KeyText(txtInput.Text)
            ' txtInput.Text = ""
            '
            ' Me.SetFocus
            '            Form_Activate()

            gcd.clsJob.KeyText(KeysAccumulator)
            KeysAccumulator = ""

        Case Key.f2

            fp.FillGeneral(gcd.Drawing.CurrLayer)

            'Dim stl1 As Stlmodel3d
            'stl1 = stl.LoadBinarySTL("/home/martin/Descargas/Axle shaft.stl")

            ' t = Timer
            ' Dim NE As New Entity
            ' Debug "Creando 500.000 lineas"
            ' For a = 1 To 500000
            '     NE = cadLine.NewEntity([Rnd(-100, 100), Rnd(-100, -100), Rnd(100, 100), Rnd(100, 100)])
            '     Ngcd.CCC[e.gender].finish(ne)
            '     gcd.Drawing.oEntities.Add(ne, ne.Handle)
            '
            ' Next
            ' Debug "Creadas", Timer - t
            ' t = Timer
            ' gcd.FillLayers()
            ' gcd.Regen
            ' cadZoomE.Start()
            ' clsEntities.CollectVisibleEntities
            '
            ' Debug "Regen en ", Timer - t
            ' Dim oka As Boolean
            ' t = Timer
            ' For Each NE In gcd.Drawing.oEntities
            '     oka = Ngcd.CCC[e.gender].MouseOverMe(NE, 2000, 2000, 10)
            ' Next
            ' Debug "Tracking via Gcd.CCC[e.gender] en ", Timer - t
            '
            ' t = Timer
            '
            ' NE = clsMouseTracking.CheckAboveEntity(2000, 2000, 10)
            '
            ' Debug "Tracking via clsMouseTRacking en ", Timer - t
            '
            ' ' lleno poi
            ' t = Timer
            ' For Each NE In gcd.Drawing.oEntities
            '     Inc a
            '     gcd.Drawing.poiLines.Insert(NE.p.Copy())
            '     gcd.Drawing.oExtras.Add(ne.Handle, Str(a))
            ' Next
            ' Debug "Llenado del POI en ", Timer - t
            ' t = Timer
            ' a = puntos.inPolySegment(gcd.Drawing.poiLines, 2000, 2000, 10)
            ' Debug "Busqueda via POI en ", Timer - t
            ' Stop
            ' ftring = puntos.PolygonTriangulation3([185, -315, 185, -295, 179, -295, 179, -296, 184, -296, 184, -314, 179, -314, 179, -315])

            'ftring2 = puntos.PolygonTriangulation([185, -315, 185, -295, 179, -295, 179, -296, 184, -296, 184, -314, 179, -314, 179, -315])

            'puntos.Translate(ftring2, 80, 0)
            ' Dim NE As New Entity
            ' ne = cadLWPolyline.NewEntity(ftring2)
            ' gcd.Drawing.oEntities.Add(ne, ne.Handle)
            '
            ' ftring2 = [0, 0, 0, 20, -10, 20, -10, 15, -5, 15, -5, 10, -10, 10, -10, 0, 0, 0]
            ' 'ftring2 = puntos.InvertPolyline(ftring2)
            ' ne = cadLWPolyline.NewEntity(ftring2)
            ' gcd.Drawing.oEntities.Add(ne, ne.Handle)
            '
            ' ftring2 = New Float[]
            ' ftring2 = puntos.LinePolyIntersection([-10, 8, -1, 12], ne.p)
            ' Stop
        Case Key.F3  ' tecla reservada para Test de todo tipo
            Try gcd.debugInfo("-----------------------------------------------------------------------")
            Try gcd.debugInfo("Selected: " & gcd.Drawing.Sheet.EntitiesSelected.Count)
            Try gcd.debugInfo("clsJob: " & gcd.clsJob.gender)
            Try gcd.debugInfo("clsJob.Pointsdone: " & gcd.clsJob.Pointsdone)
            Try gcd.debugInfo("clsJobPrevious: " & gcd.clsJobPrevious.gender)
            Try gcd.debugInfo("clsJobPreZoom: " & gcd.clsJobPreZoom.gender)
            Try gcd.debugInfo("clsJobCallback: " & gcd.clsJobCallBack.gender)
            Try gcd.debugInfo("clsJobCallback.PointsDone: " & gcd.clsJobCallBack.Pointsdone)
            fDebug.Show

        Case Key.f5

            If FInspector.MyState > 0 Then FInspector.Close

            If gcd.Drawing.Sheet.EntitiesSelected.Count > 0 Then
                FInspector.run(gcd.Drawing.Sheet.EntitiesSelected[gcd.Drawing.Sheet.EntitiesSelected.First])
            End If

        Case Key.f6

            ' gcd.DrawBounds = Not gcd.DrawBounds
            ' Me.redraw
            ' Dim flxContorno As New Float[]
            ' flxContorno = gcd.Drawing.Sheet.EntitiesSelected[gcd.Drawing.Sheet.EntitiesSelected.First].p.copy()
            '
            ' flxTrimmedLine = puntos.LinePolyIntersection(gcd.Drawing.Sheet.EntitiesSelected[gcd.Drawing.Sheet.EntitiesSelected.Last].p, flxContorno)
            ShowBenchMarkInfo = Not ShowBenchMarkInfo
        Case Key.f8
            clsMouseTracking.WaitEnabled = Not clsMouseTracking.WaitEnabled
        Case Key.f7

            Action_Activate("savesvg")
        Case Key.F4

            gcd.DrawHatch = Not gcd.DrawHatch
            gcd.RegenList

        Case Key.BackSpace

            KeysAccumulator = Left(KeysAccumulator, -1)
            DrawingAIds.Refresh
        Case Key.F11

        Case Key.Esc
            'SetToolsMode("tools")
            gcd.clsJob.KeyText("_CANCEL")

        Case Key.Space
            Stop Event

        Case Key.Del
            gcd.clsJob.KeyText("Erase")

        Case Key.ControlKey

        Case Else
            ' A GOOD KEY
            gcd.clsJob.KeyPress(Key.Code, Key.Text)

            If InStr(KeysAccumulator, "Function") > 0 Then

                ' Select Key.Code
                '   Case Asc("1") ' Properties
                '
                '     Select PropertiesFlag
                '       Case 1 ' Tools
                '         PropertiesFlag = 2
                '         pnlProperties.Visible = True
                '         pnlIcons.Visible = False
                '         'btnSelectionMode.Value = False
                '       Case 2 ' Props
                '         PropertiesFlag = 0
                '         pnlProperties.Visible = False
                '         pnlIcons.Visible = False
                '         'btnSelectionMode.Value = True
                '
                '       Case Else ' Invisible
                '         PropertiesFlag = 1
                '         pnlProperties.Visible = False
                '         pnlIcons.Visible = True
                '
                '     End Select
                '
                '     If PropertiesFlag = False Then
                '       pnlProperties.Visible = True
                '       PropertiesFlag = True
                '       pnlIcons.Visible = False
                '       btnSelectionMode.Value = False
                '     Else
                '       pnlProperties.Visible = False
                '       PropertiesFlag = False
                '       pnlIcons.Visible = True
                '       btnSelectionMode.Value = True
                '     Endif
                '
                '   Case Asc("2") ' Layers
                '
                '     'Case Asc("3") ' Blocks
                '
                '     'Case Asc("4...") ' More...
                '     'KeysAccumulator &= "-" & Key.Text
                '     'Case Else
                '     '    KeysAccumulator = ""
                '     'pnlProperties.Visible = False
                '     'pnlDebug.Visible = False
                '
                '   Case Asc("3") ' Raw properties for debuging
                '     If RawFlag = False Then
                '       pnlRaw.Visible = True
                '       RawFlag = True
                '     Else
                '       pnlRaw.Visible = False
                '       RawFlag = False
                '     Endif
                '
                '   Case Asc("a"), Asc("A") ' Select/Unselect All
                '     SelectMode = True
                '     For Each aEnty In gcd.Drawing.arrEntities
                '       If aEnty.Selected Then
                '         SelectMode = False
                '         Break
                '       Endif
                '     Next
                '
                '     If SelectMode Then
                '       For Each aEnty In gcd.Drawing.arrEntities
                '         If aEnty.Selected = False Then
                '           aEnty.Selected = True
                '         Endif
                '       Next
                '     Else
                '       For Each aEnty In gcd.Drawing.arrEntities
                '         If aEnty.Selected Then
                '           aEnty.Selected = False
                '         Endif
                '       Next
                '     Endif
                '     fMain.regen
                '
                '   Case Asc("z"), Asc("Z") ' Undo
                '
                '     If gcd.Drawing.arrUndo.Count > 0 Then
                '       umx = gcd.Drawing.arrUndo.Max
                '
                '       uEnty = gcd.Drawing.arrUndo[umx]
                '       For Each aEnty In gcd.Drawing.arrEntities
                '         If aEnty.Handle = uEnty.Handle Then
                '           gcd.Drawing.arrEntities.Remove(imx, 1)
                '           gcd.Drawing.arrEntities.Add(uEnty, imx)
                '           gcd.Drawing.arrUndo.Remove(umx, 1)
                '           fMain.regen
                '           'gcd.Redraw
                '           Break
                '         Endif
                '         Inc imx
                '       Next
                '
                '     Endif
                '   Case Else
                '     KeysAccumulator = ""
                '
                ' End Select

            Else
                If key.text <> "" Then

                    KeysAccumulator &= Key.Text
                    'gcd.clsJob.KeyPress()

                    DrawingAIds.ErrorMessage = ""
                    DrawingAIds.Refresh
                End If
                ' If fmain.txtInput.Visible Then Return
                ' If Key.Normal <> "" Then
                '     fmain.txtInput.X = fmain.W / 2
                '     fmain.txtInput.Y = fmain.h / 2
                '     fmain.txtInput.SetFocus()
                '     fmain.txtInput.Text = Key.Text
                '     fmain.txtInput.Visible = True
                ' End If

            Endif

    End Select
    tmrSlash.Trigger
    gcd.clsJob.KeyUp(Key.Code)

    fMain.txtCommand.Refresh
    'DrawingAids.DibujaHelper

End

Public Sub grdLayers_Click()

    If gcd.flgShowingLayers Then
        fLayersOnScreen.HIde
        gcd.flgShowingLayers = False

    Else
        If grdLayers.Column = 1 Then ' Visibility
            gcd.Drawing.CurrLayer.Visible = Not gcd.Drawing.CurrLayer.Visible

            If gcd.Drawing.CurrLayer.Visible Then grdLayers[0, 1].Picture = fLayersOnScreen.picVisibleOn Else grdLayers[0, 1].Picture = fLayersOnScreen.picVisibleOff
            clsEntities.CollectVisibleEntities()
        Else If grdLayers.Column = 2 Then ' frozen
            gcd.Drawing.CurrLayer.Frozen = Not gcd.Drawing.CurrLayer.Frozen

            If gcd.Drawing.CurrLayer.Frozen Then grdLayers[0, 2].Picture = fLayersOnScreen.picFrozenOn Else grdLayers[0, 2].Picture = fLayersOnScreen.picFrozenOff

        Else If grdLayers.Column = 3 Then ' lock
            gcd.Drawing.CurrLayer.Locked = Not gcd.Drawing.CurrLayer.Locked

            If gcd.Drawing.CurrLayer.Locked Then grdLayers[0, 3].Picture = fLayersOnScreen.picLockedOn Else grdLayers[0, 3].Picture = fLayersOnScreen.picLockedOff

        Else

            gcd.flgShowingLayers = True

            fLayersOnScreen.Run()
            'fLayersOnScreen.Move(grdLayers.ScreenX, grdLayers.ScreenY + grdLayers.h + 1)
            ' puede venir un cambio de Layers, lo que con una seleccion implica que se cambian
            ' las propiedades de dichas entidades y hay que regenerar
            'fLayersOnScreen.Y = grdLayers.ScreenY + grdLayers.h + 1
        End If

    End If

End

' Public Sub FillWindowMenu()
'
'     Dim d As Drawing
'     Dim mItem As Menu
'
'     mnuWindow.Children.Clear
'
'     For Each d In gcd.Drawings
'         mItem = New Menu(mnuWindow)
'         mItem.Text = d.FileName
'         If d = gcd.Drawing Then mItem.Checked = True Else mItem.Checked = False
'         mItem.Action = "windowchange_" & d.FileName
'     Next
'
'     mItem = New Menu(mnuWindow)
'     mItem.Text = "" ' separador
'
'     ' y ahora agrego dos
'     mItem = New Menu(mnuWindow)
'     mItem.Text = ("Close")
'     mItem.Action = "window_close"
'
'     mItem = New Menu(mnuWindow)
'     mItem.Text = ("Close all")
'     mItem.Action = "window_closeall"
'
' End

' Public Sub ToggleButton3_Click()
'
'     If Not ToggleButton3.Value Then
'         ToggleButton3.Tag = CStr(ToggleButton3.Parent.h)
'         ToggleButton3.Parent.h = ToggleButton3.H
'     Else
'
'         ToggleButton3.Parent.h = CInt(ToggleButton3.tag)
'     End If
'
' End
'
' Public Sub ToggleButton4_Click()
'
'     If Not ToggleButton4.Value Then
'         ToggleButton4.Tag = CStr(ToggleButton4.Parent.h)
'         ToggleButton4.Parent.h = ToggleButton4.H
'     Else
'
'         ToggleButton4.Parent.h = CInt(ToggleButton4.tag)
'     End If
'
' End

' Public Sub tmrAutosave_Timer()
'
'     ' el autosave funciona solo si guarde antes, o sea si el dibujo tiene nombre
'     ' ademas se guarda solo en formato dxf, para acelerar el proceso
'
'     If Not gcd.Drawing.RequiresFileRename Then
'         If gcd.Drawing.RequiresSaving Then
'             If Dxf.SaveFile(gcd.Drawing.FileName & ".Autosave", gcd.Drawing.cModel) < 0 Then
'                 Print "Autosave error"
'             Else
'                 Print ("Autosaved to ") & gcd.Drawing.FileName & ".Autosave"
'             Endif
'         End If
'     End If
'
' End

' Public Sub tbnInspector_MouseUp()
'
'     If Mouse.Left Then
'
'         Config.TrackShowInspector = Not Config.TrackShowInspector
'         tbnInspector.Value = Config.TrackShowInspector
'         If Not Config.TrackShowInspector Then
'             Try fInspector.Close
'         Endif
'
'     Else If Mouse.Right Then
'
'         fDetectOptions.Show()
'
'     Endif
'
' End

' Public Sub tbnOrtho2_Click()
'
'     gcd.DrawBounds = Not gcd.DrawBounds
'     Me.redraw
'
' End

Public Function UpdatDimTypeTypeCombo()

    Dim oDimStyle As DimStyle
    Dim i As Integer

    If IsNull(gcd.Drawing.CurrDimStyle) Then gcd.Drawing.CurrDimStyle = gcd.Drawing.DimStyles[gcd.Drawing.DimStyles.First]
    fMain.cmbDimStyle.Clear
    ' agrego el que llama al formulario
    ' fMain.cmbDimStyle.Add(("Dim Styles..."))
    ' fMain.cmbDimStyle.Add("")
    fMain.cmbDimStyle.Action = "dimstyle_change"
    For Each oDimStyle In gcd.Drawing.DimStyles
        fMain.cmbDimStyle.Add(oDimStyle.name)

        If gcd.Drawing.CurrDimStyle.name = oDimStyle.name Then i = fMain.cmbDimStyle.Count
    Next
    If i = 0 Then i = 1
    If fMain.cmbDimStyle.Count > 0 Then fMain.cmbDimStyle.Index = i - 1

End
'' Transfer layers to main windows ComboBox

Public Sub UpdateLayersCombo()

    Dim i As Integer
    Dim sName As String = "_menuLay"
    Dim mLayer As New Menu(fMain), m2 As Menu
    Dim aLayer As Layer

    For i = 0 To fMain.Menus.Count - 1
        If fMain.Menus[i].Name = sName Then
            fMain.Menus[i].Delete
            Break
        End If
    Next
    mLayer.Name = sName
    For Each aLayer In gcd.Drawing.Layers
        If aLayer.HIdden Then Continue
        m2 = New Menu(mLayer)
        m2.Text = aLayer.Name
        m2.Picture = paintPlus.picCirculito(8, gcd.GetGBColor(aLayer.Colour), Color.ButtonForeground)
        m2.Action = "layer_change_" & aLayer.Name
    Next
    ' fMain.mbtLayers.Menu = sName
    ' fMain.mbtLayers.Text = mLayer.Children[0].Text
    ' fMain.mbtLayers.Picture = mLayer.Children[0].Picture
    If Not gcd.Drawing.CurrLayer Then gcd.Drawing.CurrLayer = gcd.Drawing.Layers[gcd.Drawing.Layers.First]

    fMain.grdLayers[0.0, 0.0].Picture = mLayer.Children[0].Picture
    fMain.grdLayers[0, 4].Text = gcd.Drawing.CurrLayer.Name
    fMain.grdLayers[0, 1].Picture = IIf(gcd.Drawing.CurrLayer.Visible, fLayersOnScreen.picVisibleOn, fLayersOnScreen.picVisibleOff)
    fMain.grdLayers[0, 2].Picture = IIf(gcd.Drawing.CurrLayer.Frozen, fLayersOnScreen.picFrozenOn, fLayersOnScreen.picFrozenOff)
    fMain.grdLayers[0, 3].Picture = IIf(gcd.Drawing.CurrLayer.Locked, fLayersOnScreen.picLockedOn, fLayersOnScreen.picLockedOff)

    For i = 0 To fmain.grdLayers.Columns.Max
        fmain.grdLayers.Columns[i].Background = Color.ButtonBackground
    Next

    fmain.grdLayers.Rows[0].Height = fmain.grdLayers.Height

    ' fMain.tbnLayersOnScreen.Picture = paintPlus.picTexto(gcd.Drawing.arrLayers.First.Name, fMain.Font.H, fMain.tbnLayersOnScreen.w, fMain.tbnLayersOnScreen.h, Color.ButtonForeground, Color.ButtonBackground, Align.Left)

    Return

End

'' Should be called after updating layers
Public Sub UpdateLineWtCombo()

    Dim imagen As Image

    Dim LW As Float
    Dim f As Float

    ' lo vacio

    fMain.tblLineWt.tbnChilds.Clear

    ' primero agregamos la correspondiente a ByLayer
    imagen = New Image(fMain.tblLineWt.w * 0.9, fMain.tblLineWt.h * 0.9, fMain.tblLineWt.Background)

    Paint.Begin(imagen)
    '  +------------------------------------+
    '  +   ---------------------  0.00mm    +
    '  +------------------------------------+
    Paint.Brush = Paint.Color(Color.ButtonForeground)
    Paint.MoveTo(0, imagen.h / 2)
    lw = gcd.Drawing.CurrLayer.LineWt '][dxf.codLWht] / 100 * 3
    Paint.LineWIdth = lw
    If Paint.LineWIdth < 1 Then Paint.LineWIdth = 1
    Paint.RelLineTo(imagen.w / 2, 0)
    Paint.Stroke
    Paint.MoveTo(imagen.w / 10 * 5.5, imagen.h * 0.1)
    Paint.LineWIdth = 1
    Paint.Text("ByLayer",,,, imagen.h * 0.6, Align.Left)
    Paint.Fill
    Paint.End

    fMain.tblLineWt.AddToolButton("tbnLineWtByLayer",, imagen.Picture, "linewt_change_" & CStr(lw * 100))

    ' ahora espesores especificos
    For f = 0.1 To 1.2 Step 0.1
        ' primero agregamos la correspondiente a ByLayer
        imagen = New Image(fMain.tblLineWt.w * 0.9, fMain.tblLineWt.h * 0.9, fMain.tblLineWt.Background)

        Paint.Begin(imagen)
        Paint.AntiAlias = True
        '  +------------------------------------+
        '  +   ---------------------  0.00mm    +
        '  +------------------------------------+
        Paint.Brush = Paint.Color(Color.ButtonForeground)
        Paint.MoveTo(0, imagen.h / 2)
        lw = f * 3
        Paint.LineWIdth = lw
        If Paint.LineWIdth < 1 Then Paint.LineWIdth = 1
        Paint.RelLineTo(imagen.w / 2, 0)
        Paint.Stroke
        Paint.MoveTo(imagen.w / 10 * 5.5, imagen.h * 0.1)
        Paint.LineWIdth = 1
        Paint.Text(Format(f, "0.00mm"),,,, imagen.h * 0.6, Align.Left)
        Paint.Fill
        Paint.End

        fMain.tblLineWt.AddToolButton("tbnLineWt" & CStr(f),, imagen.Picture, "linewt_change_" & CStr(lw * 100))

    Next

    '   test id[mm]
    ' # ¡DIV/0!	0	0
    ' 0, 05 1 0, 05
    ' 0, 09 2 0, 09
    ' 0, 1 3 0, 1
    ' 0, 13 4 0, 13
    ' 0, 15 5 0, 15
    ' 0, 18 6 0, 18
    ' 0, 2 7 0, 2
    ' 0, 25 8 0, 25
    ' 0, 3 9 0, 3
    ' 0, 35 10 0, 35
    ' 0, 4 11 0, 4
    ' 0, 45 12 0, 45
    ' 0, 5 13 0, 5
    ' 0, 53 14 0, 53
    ' 0, 6 15 0, 6
    ' 0, 65 16 0, 65
    ' 0, 7 17 0, 7
    ' 0, 8 18 0, 8
    ' 0, 9 19 0, 9
    ' 1 20 1
    ' 0, 4761904761905 21 1, 06
    ' 0, 9090909090909 22 1, 2
    ' 1, 304347826087 23 1, 4
    ' 1, 6666666666667 24 1, 58
    ' 2 25 2
    ' 	26 2, 11
    ' 	27
    ' 	28
    ' ByLayer 29
    ' ByBlock 30
    ' Default 31

End

Public Sub UpdateLineTypeCombo()

    ' se define en DXF con los codigos:
    ' 40 = largo total por tramo ( = suma de Abs(code 49) )
    ' 73 = numero de elementos (linea,espacio, punto) = 0 si es continua
    ' 49 = largo de cada elemento: 0 = dot, negativo = espacio, positivo = linea
    Dim imagen As Image
    Dim i As Integer
    Dim lty As LineType
    Dim d As Float

    '  +------------------------------------+
    '  + Phantom                            +
    '  + -- - -- - -- - -- - -- - -- - --   +
    '  +------------------------------------+

    fMain.tblLTypes.tbnChilds.Clear

    ' ahora espesores especificos
    For Each lty In gcd.Drawing.LineTypes
        Inc i
        For Each d In lty.TrameLength
            d = Abs(d)
        Next

        ' primero agregamos la correspondiente a ByLayer
        imagen = New Image(fMain.tblLTypes.w * 0.9, fMain.tblLTypes.h * 0.9, fMain.tblLTypes.Background)

        Paint.Begin(imagen)
        Paint.Brush = Paint.Color(Color.ButtonForeground)
        Paint.AntiAlias = True
        Paint.MoveTo(0, imagen.h * 0.8)
        Paint.LineWIdth = 1
        Paint.Dash = lty.TrameLength
        Paint.RelLineTo(imagen.w, 0)
        Paint.Stroke
        Paint.Dash = Null
        ' Texto
        Paint.MoveTo(0, 0)
        Paint.LineWIdth = 1
        Paint.Text(lty.Name,,,, imagen.h * 0.5, Align.topLeft)
        Paint.Fill
        Paint.End

        fMain.tblLTypes.AddToolButton("tbnLType" & CStr(i),, imagen.Picture, "ltype_change_" & lty.Name)

    Next
    gcd.Drawing.CurrLineType = gcd.Drawing.LineTypes[gcd.Drawing.LineTypes.First]

End

Public Sub tabDrawings_Click()

    Dim t As Object

    If InUse Then Return

    ' For Each t In tabDrawings.Current.Children
    '     Object.Detach(t)
    ' Next

    gcd.Drawing = tabDrawings[tabDrawings.Index].Tag

    If Not gcd.Drawing Then
        Debug "ERROR: no Drawing"
        Return
    Else
        Me.Title = gcd.Drawing.FileName
    Endif

    'If gcd.Drawing Then FillBlock ' FIXME: pasa al nuevo formulario flotante
    If Not gcd.Drawing.Sheet.GLSheet Then
        Debug "ERROR: no Sheet"
        Return
    Endif
    'Object.Detach(GLArea1)
    Me.GLArea1 = gcd.Drawing.Sheet.GLSheet
    GLArea1.Enabled = True
    'Object.Attach(GLArea1, Me, "GLArea1")
    Me.GLArea1.Refresh

    'Debug gcd.Drawing.FileName, gcd.Drawing.Sheet.Name

End

Public Sub tabSheets_Click()

    Dim s As Sheet

    If InUse Then Return

    If Last.current.tag Then

        ' For Each s In gcd.Drawing.Sheets
        '     Object.Detach(s.GLSheet)
        ' Next

        gcd.Drawing.Sheet = Last.current.tag

        gcd.Drawing.LastLayer = gcd.Drawing.CurrLayer

        Me.GLArea1 = gcd.Drawing.Sheet.GLSheet
        GLArea1.Enabled = True
        'Object.Attach(GLArea1, Me, "GLArea1")

        Me.GLArea1.Refresh

        If Not gcd.Drawing.Sheet.Shown Then
            'cadZoomE.Start()
            gcd.Drawing.Sheet.Shown = True
        End If

        Me.ReCollect

        'Debug gcd.Drawing.FileName, gcd.Drawing.Sheet.Name

    End If

End

'' Crea una nueva Tab para alojar un nuevo grafico
Public Function NewTabForDrawing(nDrawing As Drawing)

    Dim i As Integer
    Dim s As Sheet

    InUse = True

    NDrawing.iEntity.Insert([0, 0, 0, 0])
    NDrawing.Sheet.ScaleZoom = gcd.ScreenDensity / 10

    Me.tabDrawings.Count += 1
    Me.tabDrawings.Refresh
    i = Me.tabDrawings.Count - 1
    Me.tabDrawings.Index = i
    Me.tabDrawings[i].Text = Left(Utils.FileFromPath(nDrawing.FileName), 12)
    'Me.tabDrawings[i].Tooltip = sName
    Me.tabDrawings[i].Expand = True
    Me.tabDrawings[i].tag = nDrawing

    Me.tabDrawings.Refresh
    Dim tabFileNew As New TabPanel(Me.tabDrawings[i])
    tabFileNew.Expand = True
    tabFileNew.Arrangement = Arrange.Fill
    tabFileNew.Orientation = Align.Bottom
    Object.Attach(tabFileNew, Me, "tabSheets")
    Me.tabDrawings.Refresh

    tabFileNew.Refresh

    NewSheet(tabFileNew, nDrawing.Sheets["Model"], True)

    ' Workaround
    Dim MaxOrder, MinOrder As Integer
    MinOrder = 1000
    For Each s In nDrawing.Sheets
        If s.Name = "Model" Then Continue

        If s.TabOrder > MaxOrder Then MaxOrder = s.TabOrder
        If s.TabOrder < MinOrder Then MinOrder = s.TabOrder

    Next
    For i = MinOrder To MaxOrder

        For Each s In nDrawing.Sheets
            If s.Name = "Model" Then Continue

            If i = s.TabOrder Then
                NewSheet(tabFileNew, s)
                Break
            End If

        Next
    Next
    GLArea1 = nDrawing.Sheet.GlSheet

    InUse = False
    tabFileNew.Index = 0

    Me.Refresh

    Return

End

'' Crea una nueva Tab para alojar una nueva hoja
Public Function NewSheet(tabSheets As TabPanel, s As Sheet, Optional UseFirst As Boolean = False)

    Dim i As Integer
    Dim glaFile2 As GLArea

    InUse = True
    gcd.DrawingReady = False

    If Not UseFirst Then
        tabSheets.Count += 1
        tabSheets.Index = tabSheets.Count - 1
    Else
        tabSheets.Index = 0
    End If
    tabSheets.Text = s.Name
    tabSheets.Refresh

    glaFile2 = New GLArea(tabSheets.Current) As "glarea1"

    glaFile2.Background = Config.ModelBackgroundColor
    glaFile2.Expand = True
    glaFile2.Tracking = True
    glaFile2.Mouse = Cursor.CrossHair
    glaFile2.Refresh

    ' Object.Attach(glaFile2, Me, "GLArea1")
    GLArea1 = glaFile2

    s.GLSheet = glaFile2
    's.GLSheet.Refresh

    tabSheets.Current.Tag = s
    tabSheets.Current.Refresh
    glarea1.Cursor = gcd.CursorCross

    glx.Resize(glarea1)
    gcd.DrawingReady = True
    InUse = False

End

Public Sub tabDrawings_Close(Index As Integer)

    Dim c, c2 As Control
    Dim childs As Integer

    InUse = True
    ' tengo q elminar todos los controles que tiene adentro antes de eliminar el tab
    For Each c In tabDrawings[Index].Children
        childs = 0

        Try childs = c.Children.count
        If childs = 0 Then
            c.Delete
        Else
            For Each c2 In c.Children
                c2.Delete
            Next
            c.Delete
        End If

    Next
    tabDrawings[Index].Delete
    If tabDrawings.Count = 0 Then
        actions.FileNew
    End If
    'tabDrawings.Index = tabDrawings.Count - 1
    InUse = False
    tabDrawings_Click

End

Public Sub tabDrawings_CloseAll()

    Dim i As Integer

    For i = tabDrawings.Count - 1 To 0 Step -1
        tabDrawings_Close(i)
    Next
    actions.FileNew

End

Public Sub tbnNewSheet_Click()

    fSheet.ShowModal()

    GLArea1.Refresh

End

Public Sub LoadButtons(Optional iSize As Integer = 32, iColumns As Integer = 2)

    Dim tb As ToolButton
    Dim iBorder As Integer = 15
    Dim lp As Integer[]

    panEntities.W = iSize * iColumns + iBorder
    panDimensions.W = iSize * iColumns + iBorder
    panBlocks.W = iSize * iColumns + iBorder
    panTools.W = iSize * iColumns + iBorder
    panInquiry.W = iSize * iColumns + iBorder

    ' Entidades
    Utils.TBNCreator(panentities, "cad/draw-line", "cadLine",,, ("Line"))
    Utils.TBNCreator(panentities, "cad/draw-ray", "cadRay",,, ("Ray"))
    Utils.TBNCreator(panentities, "cad/draw-circle", "cadCircle",,, ("Circle"))
    Utils.TBNCreator(panentities, "cad/draw-arc", "cadArc",,, ("Arc"))
    Utils.TBNCreator(panentities, "cad/draw-arc", "cadArc3point",,, ("Arc 3 point"))
    Utils.TBNCreator(panentities, "cad/draw-polyline", "cadLWPolyline",,, ("Polyline"))
    Utils.TBNCreator(panentities, "cad/draw-ellipse", "cadEllipse",,, ("Ellipse"))
    Utils.TBNCreator(panentities, "cad/draw-text", "cadMText",,, ("Text"))
    Utils.TBNCreator(panentities, "cad/alter-attdef", "cadAttdef",,, "Attdef")
    Utils.TBNCreator(panentities, "cad/draw-mtext", "cadMtext",,, "M-Text")
    Utils.TBNCreator(panentities, "cad/draw-leader", "cadLeader",,, ("Leader"))
    Utils.TBNCreator(panentities, "cad/draw-spline", "cadSPline",,, ("Spline"))
    Utils.TBNCreator(panentities, "cad/draw-rectangle", "cadRectangle",,, ("Rectangle"))
    Utils.TBNCreator(panentities, "cad/draw-polygon", "cadPolygon",,, ("Polygon"))
    Utils.TBNCreator(panentities, "cad/draw-point", "cadPoint",,, ("Point"))
    Utils.TBNCreator(panentities, "cad/draw-solid", "cadSolId",,, ("Solid"))
    Utils.tbnCreator(panentities, "cad/draw-pattern", "cadhatch",,, ("Pattern"))

    'Dimensiones
    Utils.tbnCreator(panDimensions, "cad/dim-linear", "cadDimension_Linear",,, ("Linear dimmension"))
    Utils.tbnCreator(panDimensions, "cad/dim-aligned", "caddimension_aligned",,, ("Aligned dimmension"))
    Utils.tbnCreator(panDimensions, "cad/dim-ang3pt", "caddimension_ang3pt",,, ("Angle dimmension"))
    Utils.tbnCreator(panDimensions, "cad/dim-diameter", "caddimension_diameter",,, ("Diameter dimmension"))
    Utils.tbnCreator(panDimensions, "cad/dim-radius", "caddimension_radius",,, ("Radius dimmension"))
    Utils.tbnCreator(panDimensions, "cad/dim-ordinate", "caddimension_ordinate",,, ("Ordinate dimmension"))
    Utils.tbnCreator(panDimensions, "cad/dim-arc", "cadArc_dimension",,, ("Arc dimmension"))
    Utils.tbnCreator(panDimensions, "cad/dim-linear_h", "cadDimension_Linear&1",,, ("Horizontal dimmension"))
    Utils.tbnCreator(panDimensions, "cad/dim-linear_v", "cadDimension_Linear&2",,, ("Vertical dimmension"))
    Utils.tbnCreator(panDimensions, "cad/dim-baseline", "cadDimension_linear&20",,, ("Baseline dimmension"))
    Utils.tbnCreator(panDimensions, "cad/dim-continue", "cadDimension_linear&10",,, ("Continue dimmension"))

    ' Bloques
    Utils.tbnCreator(panBlocks, "cad/alter-complex", "cadblocks",,, ("Blocks"), False)
    Utils.tbnCreator(panBlocks, "cad/draw-pattern", "cadhatch",,, ("Pattern"), False)
    Utils.tbnCreator(panBlocks, "cad/set-sheet-add", "new_sheet",,, ("New sheet"), False)
    Utils.tbnCreator(panBlocks, "cad/set-viewport", "cadViewport",,, ("Viewport"), False)

    'Tools
    Utils.tbnCreator(panTools, "cad/alter-copy", "cadcopy",,, ("Copy"), False)
    Utils.tbnCreator(panTools, "cad/alter-move", "cadmove",,, ("Move"), False)
    Utils.tbnCreator(panTools, "cad/alter-delete", "caderase",,, ("Delete"), False)
    Utils.tbnCreator(panTools, "cad/alter-rotate", "cadrotate",,, ("Rotate"), False)
    Utils.tbnCreator(panTools, "cad/alter-stretch", "cadstretch",,, ("Stretch"), False)
    Utils.tbnCreator(panTools, "cad/alter-scale", "cadscale",,, ("Scale"), False)
    Utils.tbnCreator(panTools, "cad/alter-fillet", "cadfillet",,, ("Fillet"), False)
    Utils.tbnCreator(panTools, "cad/alter-chamfer", "cadchamfer",,, ("Chamfler"), False)
    Utils.tbnCreator(panTools, "cad/alter-explode", "cadExplode",,, ("Explode"), False)
    Utils.tbnCreator(panTools, "cad/alter-trim", "cadtrim",,, ("Trim"), False)
    Utils.tbnCreator(panTools, "cad/alter-array", "cadarray",,, ("Array"), False)
    'Utils.tbnCreator(panTools, "cad/alter-array_polar", "cadarray")
    Utils.tbnCreator(panTools, "cad/alter-break", "cadbreak",,, ("Break"), False)
    Utils.tbnCreator(panTools, "cad/alter-divide", "caddivIde",,, ("Divide"), False)
    Utils.tbnCreator(panTools, "cad/alter-mirror", "cadMirror",,, ("Mirror"), False)
    Utils.tbnCreator(panTools, "cad/alter-offset", "cadoffset",,, ("Offset"), False)

    ' Info
    Utils.tbnCreator(panInquiry, "cad/measure-ruler", "cadRuler",,, ("Distance measure"), False)
    Utils.tbnCreator(panInquiry, "cad/measure-protractor", "cadProtractor",,, ("Angle measure"), False)
    Utils.tbnCreator(panInquiry, "cad/measure-area", "cadArea",,, ("Area measure"), False)
    Utils.tbnCreator(panInquiry, "cad/alter-properties", "properties",,, ("Alter properties"), False)
    ' rigth bar
    ' Utils.tbnCreator(pnlToolBarRigth, "tbnNewSelection", "selectnew",,, ("New selection"))
    'Utils.tbnCreator(pnlToolBarRigth, "cad/select", "selectnew",,, ("New selection"), False)

    ' Estos botones estan al pedo, Ctrl agrega y Shift quita de la seleccion
    'Utils.tbnCreator(pnlToolBarRigth, "tbnselectadd", "selectadd",,, ("Add to selection"))
    'Utils.tbnCreator(pnlToolBarRigth, "tbnselectrem", "selectrem",,, ("Remove from selection"))

    ' DEPRE: vuelvo a sentido de seleccion, izq crossing, derecha full
    ' Utils.tbnCreator(pnlToolBarRigth, "tbnselectcross", "selectcross",,, ("Select crossing entities"), True)

    Utils.tbnCreator(panTop, "cad/select", "selectnew",,, ("New Selection"), False)
    Utils.tbnCreator(panTop, "cad/select-polyline", "selectpoly",,, ("Select with polyline"), False)
    Utils.tbnCreator(panTop, "cad/locks-grid", "grid",,, ("Toggle Grid"), False)
    Utils.tbnCreator(panTop, "cad/locks-ortho", "ortho",,, ("Toggle Ortho"), False)

    Utils.tbnCreator(panTopRigth, "cad/select", "selectnew",,, ("New Selection"), False)
    Utils.tbnCreator(panTopRigth, "cad/select-polyline", "selectpoly",,, ("Select with polyline"), False)
    Utils.tbnCreator(panTopRigth, "cad/locks-grid", "grid",,, ("Toggle Grid"), False)
    Utils.tbnCreator(panTopRigth, "cad/locks-ortho", "ortho",,, ("Toggle Ortho"), False)

    ' Snap points

    Utils.tbnCreator(pansnap, "cad/snap-apparent_intersection", "snapapparentintersection",,, ("Snap apparent intersection"), True)
    Utils.tbnCreator(pansnap, "cad/snap-center_point", "snapcenter",,, ("Snap center"), True)
    Utils.tbnCreator(pansnap, "cad/snap-end_point", "snapend",,, ("Snap end point"), True)
    Utils.tbnCreator(pansnap, "cad/snap-geometric_center", "snapaparentcenter",,, ("Snap apparent center"), True)
    Utils.tbnCreator(pansnap, "cad/snap-insert", "snapbase",,, ("Snap insert point"), True)
    Utils.tbnCreator(pansnap, "cad/snap-intersection", "snapintersection",,, ("Snap intersection"), True)
    Utils.tbnCreator(pansnap, "cad/snap-mid_point", "snapmid",,, ("Snap mid point"), True)
    Utils.tbnCreator(pansnap, "cad/snap-nearest", "snapnearest",,, ("Snap nearest"), True)
    Utils.tbnCreator(pansnap, "cad/snap-node", "snapnode",,, ("Snap node"), True)
    Utils.tbnCreator(pansnap, "cad/snap-perpendicular", "snapperpendicular",,, ("Snap perpendicular"), True)
    Utils.tbnCreator(pansnap, "cad/snap-quadrant", "snapquadrant",,, ("Snap quadrant"), True)
    Utils.tbnCreator(pansnap, "cad/snap-tangent", "snaptangent",,, ("Snap tangent"), True)
    ' ' Force the resize event
    ' lp = splitterH.Layout.Copy()
    ' splitterH.Layout = [2, 1]
    ' splitterH.Layout = lp.Copy()

End

Public Sub FixPanelHeight(p As Variant)

    Dim nx As Integer 'numero de botones segun X
    Dim ny As Integer 'numero de botones segun y
    Dim fy As Float
    Dim iSize As Integer 'tamaño de los botones
    Dim iBorderPixels, iMargin, iBorder As Integer

    Dim iTitleHeight As Integer
    Dim f As Font

    Try f = panentities.Font
    Try iTitleHeight = f.Height
    If iTitleHeight > 0 Then
        If p.text = "" Then iTitleHeight = 0
    Endif

    Try iMargin = p.Padding
    Try iBorder = p.Border

    If p.Children.count = 0 Then Return
    If iBorder <> 0 Then iBorderPixels = 2
    iSize = p.Children[0].W
    nx = (p.w - iMargin * 2) / isize

    If nx = 0 Then Return
    ' supongo que el ancho esta prestablecido
    fy = p.Children.Count / nx
    ny = p.Children.Count / nx
    If fy > ny Then Inc ny

    p.h = ny * iSize + iMargin * 2 + iBorderPixels + iTitleHeight * 1.5

End

Public Sub togSnap_MouseDown()

    If Mouse.Right Then fPoiOptions.show

End

Public Sub splitterH_Resize()

    Dim obj As Object
    Dim q, e As Integer

    Config.SplitterH = splitterH.Layout

    form_Arrange
    '
    '     'splitterH.Layout[0] = panTop.w
    '
    '     ' For Each obj In pnlToolbarLeft.Children
    '     '     If Object.Type(obj) = "Frame" And obj.Visible Then
    '     '         q = obj.W / 32
    '     '
    '     '         e = (obj.Children.count - 1) / q
    '     '         If e < 1 Then
    '     '             e = 1
    '     '         Endif
    '     '         obj.H = 23 + ((e + 1) * 32)
    '     '     Endif
    '     ' Next
    '

End

Public Sub tmrSlash_Timer()

    'Return ' FIXME:
    Dim sCB, sJO As String

    If gcd.clsJob Then
        If gcd.clsJobCallBack Then
            scb = gcd.clsJobCallBack.gender & ": "
            sjo = gcd.clsJob.Prompt
        Else

            If gcd.clsJob.gender = "SELECT" Then
                sjo = ""

            Else
                sjo = gcd.clsJob.gender & ": " & gcd.clsJob.Prompt
            End If
        End If
    End If
    If PromtSlash = "|" Then PromtSlash = "" Else PromtSlash = "|"

    Try fMain.txtCommand.Text = " > " & SCB & sJO & KeysAccumulator & PromtSlash
    fMain.txtCommand.Refresh

    ' BenchMArkInfo
    If ShowBenchMarkInfo Then
        ' gcd.debugInfo("GLArea refresh " & Str(benGLAreaRefresh * 2))
        ' gcd.debugInfo("SearchTime " & Str(benMouseTracking))
        txtHelp.Text = "GLArea refresh " & Str(benGLAreaRefresh * 2) & gb.CrLf
        txtHelp.text &= "SearchTime " & Str(benMouseTracking)
        benGLAreaRefresh = 0
    End If

End

Public Sub Form_Activate()

    Dim sFile As String

    If ActivationCompleted Then Return

    ActivationCompleted = True

End

Public Sub Form_Open()

    Dim x As Integer

    'Layout.Fix(Me)
    'Me.Border = False
    'Layout.Shoot(Me)
    aThemes.Add("default")
    aLinux = GUI.Linux()
    File.Save("/tmp/themes.json", JSON.Encode2(aLinux))
    GUI.oThemes = aLinux
    oTags = GUI.Tags2(Me)

    GUI.Update(pnlToolbarLeft, "default", "es", oTags)
    GUI.Update(pnlToolbarTop, "default", "es", oTags)
    GUI.Update(pnlToolBarRigth, "default", "es", oTags)
    GUI.Update(pnlCommand, "default", "es", oTags)

    ' x = splitterH.W
    ' splitterH.W = x - 10
    ' splitterH.W = x
    ' 'Layout.Fix(Me, 75)
    ' splitterH_Resize

End

Public Sub cmbDimStyle_Click()

    gcd.Drawing.CurrDimStyle = gcd.Drawing.DimStyles[fMain.cmbDimStyle.Text]
    If gcd.Drawing.Sheet.EntitiesSelected.Count = 0 Then fp.FillGeneral(gcd.Drawing.CurrDimStyle)

End

Public Sub panTop_MouseDown()

End

' Este timer se activa cuando el user deja de hacer Zoom o Pan
Public Sub tmrQuiet_Timer()

    'Return ' FIXME:
    gcd.flgQuitSearch = False
    If gcd.flgNewPosition Then
        ReCollect
        gcd.setdashes
        DrawingAIds.RebuildGrId
        If Config.AutoRegen Then
            ' veo si tengo que hacer un auto regen
            If gcd.Drawing.Sheet.ScaleZoom > gcd.Drawing.Sheet.ScaleZoomLast Then
                If gcd.Drawing.Sheet.ScaleZoom / gcd.Drawing.Sheet.ScaleZoomLast > Config.AutoRegenFactor Then gcd.Regen()
            Else
                If gcd.Drawing.Sheet.ScaleZoomLast / gcd.Drawing.Sheet.ScaleZoom > Config.AutoRegenFactor Then gcd.Regen()
            End If
        End If
        gcd.flgNewPosition = False
    End If

End

Public Sub splRigth_Resize()

    Config.splRigth = splRigth.Layout

End
