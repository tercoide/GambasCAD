' Gambas module file

' Organizacion del DXF y sus Handles
' ----------------------------------
'
' HEADERS no usan handles
' CLASSES no usan handles
' TABLES
'       VPORT, LTYPE, LAYER, STYLES, VIEWS, APPID, UCS, DIMSTYLE
'               handles = variable
'               owner  = 0, el handle 0 representa el Drawing madre
'               Las tablas hijas tienen como owner a la cabecera, ver la tabla siguiente para ejemplo
'       BLOCK_RECORD
'               handle = variable, generalmente el 1
'               layout = 0 o un OBJECT LAYOUT en caso de ser una Sheet como *Model *Paper_Space u otras
'               owner  = 0
'                 ^     BLOCK_RECORD1
'                 |                 handles = hBlock_record <-+
'                 +--------------<  owner  = 0                |
' BLOCKS                                                      |
'       BLOCK 1                                               |
'               handle = hBlock1                              |
'               owner  = hBlock_record                     >--+ el handle que se corresponde en el BLOCK_RECORD
'               ENTITY1
'                      handle = hEntity1
'                      owner  = hBlock_record
'           Las Sheets como *Model o *Paper_Space tienen un BLOCK asociado sin entidades
'
' ENTITIES
'       ENTITY 1
'               handle = hEntity1
'               owner  =
'       ENTITY INSERT
'               handle = hEntityInsert
'               owner  =
'       ENTITY ATTRIB
'               handle = hEntity2
'               owner  = hEntityInsert
' OBJECTS
'     handle = variable HO
'     owner  = 0

'       DICTIONARY
'
'       OBJECT 1
'               handle = hObject1
'               owner  = HO
'       OBJECT LAYOUT
'               handle = hObject1
'               owner  = HO

Public LoadingPercent As Single
Private LoadLastPercent As Single
Private LoadTotalBytes As Integer
Private LoadedBytes As Integer
Private iHandle As Integer = 2
Private fp As File
Private hFile As File

Private lpCode As String
Private lpValue As String

Private LastCodeReadIndex As Integer = 0
Private eExports As Boolean
' Private Handle_Block_REcord As New Collection
' Private Handle_Block As New Collection
' Private Handle_Layout As New Collection
Private hObjects As String
Private hDictionary As String
Public hContainers As New Collection
Private ReadTimes As New Collection
Private ReadEntities As New Collection
Public cEntitiesUnread As Collection
Public nEntitiesUnread As Integer
Public nEntitiesRead As Integer

' Codigos del DXF
Public Const codEntity As String = "0"
Public Const codid As String = "5"
Public Const codidContainer As String = "330"
Public Const codColor As String = "62"
Public Const codLType As String = "6"
Public Const codLayer As String = "8"
Public Const codLWht As String = "370"
Public Const codName As String = "2"
Public Const codX0 As String = "10"
Public Const codY0 As String = "20"
Public Const codZ0 As String = "30"
Public Const codX1 As String = "11"
Public Const codY1 As String = "21"
Public Const codZ1 As String = "31"
Public Const codX2 As String = "12"
Public Const codY2 As String = "22"
Public Const codZ2 As String = "32"
Public Const codX3 As String = "13"
Public Const codY3 As String = "23"
Public Const codZ3 As String = "33"
Public Const codCenterX As String = "10"
Public Const codCenterY As String = "20"
Public Const codCenterZ As String = "30"
Public Const codRadius As String = "40"
Public Const codAngleStart As String = "50"
Public Const codAngleEnd As String = "51"

Public Function DWGtoDXF(sDwgFile As String) As String

    Dim str, tmpfile As String
    ' elimino el archivo temporal que hubiese creado
    tmpfile = sDwgFile & ".tmp"
    If Exist(tmpfile) Then Kill tmpfile
    ' convierte DWG a DXF version 2010
    Shell "/usr/local/bin/dwgread '" & sDwgFile & "' -O DXF -a r2010 -o '" & tmpfile & "'" Wait To str
    gcd.debuginfo("Resultados de la conversion DWG a DXF " & Str)
    Wait
    Return tmpfile

End

'' Carga el DXF y lo mete en cModel del dibujo actual
' Verbose=0 nada, 1=minimo, 2=grupos, 3=todo
Public Function LoadFile(sFile As String, drw As Drawing, Optional IgnoreTables As Boolean = False, IgnoreBlocks As Boolean = False, IgnoreHeader As Boolean = False, VerboseLevel As Integer = 0, UpdateGraphics As Boolean = True, ReadObjects As Boolean = True) As Boolean

    Dim t As Float = Timer
    Dim cLlaveActual, cSectionActual, cTable As Collection
    Dim cToFill As New Collection

    fp = Open sFile ' For Read

    If Not fp Then Error.Raise("Error !")

    LoadedBytes = 0
    LoadTotalBytes = Lof(fp)

    cEntitiesUnread = New Collection
    nEntitiesUnread = 0
    nEntitiesRead = 0
    hContainers = New Collection        '' Clave = Handle , Dato = Colection

    While Not Eof(fp)
        'Wait 0.0001
        ReadData
        If lpCode = "0" And lpValue = "SECTION" Then

            ' vemos que seccion es
            ReadData
            If lpCode = "2" And lpValue = "HEADER" And Not IgnoreHeader Then
                ' creo la llave, pero solo si es necesario
                If Not cToFill.Exist("HEADER") Then
                    cLlaveActual = New Collection
                    cToFill.Add(cLlaveActual, "HEADER")
                Else
                    cLlaveActual = cToFill["HEADER"]
                End If

                Load1HeadersDirect(drw.Headers)
                If VerboseLevel > 2 Then gcd.debugInfo("Leidos Headers",,, True)
                Wait

            End If

            If lpCode = "2" And lpValue = "CLASSES" Then

                Load2Classes(drw)
                If VerboseLevel > 2 Then gcd.debugInfo("Leidas Classes",,, True)
                Wait
            End If

            If lpCode = "2" And lpValue = "TABLES" And Not IgnoreTables Then
                If Not cToFill.Exist("TABLES") Then
                    cLlaveActual = New Collection
                    cToFill.Add(cLlaveActual, "TABLES")
                Else
                    cLlaveActual = cToFill["TABLES"]
                End If
                Load3Tables(cLlaveActual)
                If VerboseLevel > 2 Then gcd.debugInfo("Leidos Tables",,, True)
                Wait
                ' con las tablas cargadas, llenamoslas colecciones de objetos
                ReadViewports(cToFill, drw)
                ReadLTypes(cToFill, drw)
                ReadStyles(cToFill, drw)
                ReadLayers(cToFill, drw)
                If VerboseLevel > 2 Then gcd.debugInfo("Tables al Drawing",,, True)
                Wait
            End If

            '
            If lpCode = "2" And lpValue = "BLOCKS" And Not IgnoreBlocks Then
                ' creo la llave
                cLlaveActual = New Collection
                cToFill.Add(cLlaveActual, "BLOCKS")
                Load4Blocks(cLlaveActual)
                If VerboseLevel > 2 Then gcd.debugInfo("Leidos Blocks",,, True)
                Wait
            End If

            If lpCode = "2" And lpValue = "ENTITIES" Then
                ' creo la llave
                cLlaveActual = New Collection
                cToFill.Add(cLlaveActual, "ENTITIES")

                Load5Entities(cLlaveActual)
                If VerboseLevel > 2 Then gcd.debugInfo("Leidas Entidades",,, True)
                Wait
            End If
            '
            If lpCode = "2" And lpValue = "OBJECTS" Then

                If Not cToFill.Exist("OBJECTS") Then
                    cLlaveActual = New Collection
                    cToFill.Add(cLlaveActual, "OBJECTS")
                Else
                    cLlaveActual = cToFill["OBJECTS"]
                End If

                Load6Objects(cLlaveActual)
                If VerboseLevel > 2 Then gcd.debugInfo("Leidos Objetos",,, True)
                Wait
            End If

            If lpCode = "2" And lpValue = "THUMBNAILIMAGE" Then

                If Not cToFill.Exist("THUMBNAILIMAGE") Then
                    cLlaveActual = New Collection
                    cToFill.Add(cLlaveActual, "THUMBNAILIMAGE")
                Else
                    cLlaveActual = cToFill["THUMBNAILIMAGE"]
                End If

                Load7Thumbnail(cLlaveActual)
                Wait
            End If

        Endif
    Wend
    gcd.debugInfo("DXF a Collection",,, True, True)

    If ReadObjects Then ReadObjectsFromDXF(cToFill, drw)
    If UpdateGraphics Then
        ImportBlocksFromDXF(cToFill, drw)
        Wait
        'depre clsEntities.BuildPoi()
        DXFtoEntity(cToFill["ENTITIES"], drw)
        Wait
        gcd.debugInfo("Drawing generated",,, True, True)
        clsEntities.BuildGeometry()
        Wait
        'gcd.DigestInserts()
        SetViewports(cToFill, drw)
        gcd.debugInfo("Geometry generated",,, True, True)
        Wait
    End If

    ' For Each ft As Float In ReadTimes
    '     gcd.debugInfo(ReadEntities[ReadTimes.Key] & " " & gb.Tab & ReadTimes.Key & gb.Tab & gb.Tab & gb.Tab & " total time: " & Format(fT, "0.0000"))
    ' Next
    ' Wait
    ' If VerboseLevel > 1 Then
    '     If VerboseLevel > 2 Then
    '         gcd.debuginfo("DXF: Leidas " & nEntitiesread & " entidades")
    '         If cEntitiesUnread.Count > 0 Then
    '             gcd.debuginfo("DXF: Un total de" & nEntitiesUnread & " entidades no pudieron ser leidas:")
    '             For Each unread As String In cEntitiesUnread
    '                 Print unread
    '             Next
    '         Endif
    '         Print
    '     End If
    '     gcd.debuginfo("DXF: fin lectura en " & Str(Timer - t))
    '
    ' Else
    '     gcd.debuginfo("DXF: fin lectura en " & Str(Timer - t))
    ' End If
    ' Wait
    Return False

End

Private Sub DiscardBlocks(drw As Drawing)

    Dim b As Block

    For Each b In drw.Blocks
        If (Left(b.name) = "*") And (b.idAsociatedLayout <> "0") Then drw.Blocks.Remove(drw.Blocks.Key)
    Next

End

Private Sub ReadData()

    Line Input #fp, lpcode
    Line Input #fp, lpValue

    LoadedBytes += Len(lpcode)
    LoadedBytes += Len(lpvalue)

    If Right(lpcode, 1) = gb.Cr Then lpcode = Left(lpcode, -1)
    If Right(lpvalue, 1) = gb.cr Then lpvalue = Left(lpvalue, -1)

    lpcode = Trim$(lpcode)
    lpvalue = Trim$(lpvalue)

    ' updating percentage

    LoadingPercent = LoadedBytes / LoadTotalBytes

    If LoadingPercent - LoadLastPercent > 0.01 Then
        gcd.debugInfo("Loging file " & CInt(LoadingPercent * 100) & "%", True, True)
        LoadLastPercent = LoadingPercent
    End If

End

Private Sub Load1HeadersDirect(Headers As Headers)

    ' Los header se guardan asi
    '   9                     Indica que es una variable
    ' $EXTMAX                 Nombre de la variable
    '  10                     Tipo de dato1
    ' 198.0411690635561       Dato1
    '  20                     Tipo de dato2
    ' 178.7767572407179       Dato2
    '  30                     etc
    '   0

    ' Yo usare dos colecciones

    Dim sVarName As String
    Dim cVariable As Variant[]
    Dim v As Variant
    Dim slx As New Single[]
    Dim inx As New Integer[]
    Dim i As Integer

    ReadData
    Do

        If lpCode = "0" And lpValue = "ENDSEC" Then Break

        If lpcode = "9" Then ' nueva variable
            cVariable = New Variant[]
            sVarName = Mid(lpvalue, 2)

            Do                          ' este bucle es por si la variable es un array
                ReadData
                If lpcode = "0" Or lpCode = "9" Then Break
                cVariable.Add(lpvalue)
            Loop
            If Not Headers.SetValues(sVarName, cVariable) Then gcd.debugInfo("Var " & sVarName & " not found.")
            Inc i

        Endif

    Loop

    gcd.debuginfo("DXF: Leidas " & i & " variables de ambiente")

End

Private Sub Load2Classes(drwLoading As Drawing)

    Dim cClass As CadClass

    Do

        If lpValue = "CLASSES" Then ReadData
        If lpValue = "ENDSEC" Then Return

        cClass = New CadClass
        drwLoading.CadClasses.Add(cClass)

        ReadData

        While (lpcode <> "0") And Not Eof(fp)
            If lpcode = "0" Then cClass.recordtype = lpValue
            If lpcode = "1" Then cClass.recordname = lpValue
            If lpcode = "2" Then cClass.CPPName = lpValue
            If lpcode = "3" Then cClass.AppName = lpValue
            If lpcode = "90" Then cClass.ProxyCapp = CInt(lpValue)
            If lpcode = "91" Then cClass.InstanceCount = CInt(lpValue)
            If lpcode = "280" Then cClass.ProxyFlag = CInt(lpValue)
            If lpcode = "281" Then cClass.EntityFlag = CInt(lpValue)

            ReadData

        Wend

    Loop

End

Private Sub Load3Tables(cTables As Collection)

    Dim sTableName As String
    Dim sTableid As String  ' in hex
    Dim sTableContainer As String   ' in hex , 0 = nobody
    Dim iTableEntries As Integer
    Dim cTable As Collection

    ' creamos una table inicial con los handles de las tables
    cTable = New Collection
    cTables.Add(cTable, "__AuxData__")

    ReadData
    Do
        If Eof(fp) Then Break

        If lpCode = "0" And lpValue = "ENDSEC" Then Break

        If lpCode = "0" And lpValue = "TABLE" Then

            ' OBTENGO DATOS DE LA TABLA
            ' -1 APP: entity name(changes Each Time a drawing Is Opened)
            ' 0 Object type(TABLE)
            ' 2 Table name
            ' 5 Handle
            ' 330 Soft - pointer ID / handle To owner object
            ' 100 Subclass marker(AcDbSymbolTable)
            ' 70 Maximum number Of entries In table
            ReadData
            While lpcode <> "0"

                If lpcode = "5" Then sTableid = lpvalue

                If lpcode = "2" Then sTableName = lpvalue
                If lpcode = "330" Then sTableContainer = lpvalue

                'If sTableName = "VIEW" Then Stop

                ' WARNING: este dato no es valido para todas las versiones de DXF
                ' en algunos archivos hay mas tablas que lo que indica este numero
                ' No hay que darle importancia a este numero!!!
                If lpcode = "70" Then iTableEntries = CInt(lpvalue)

                ReadData
            Wend

            ' agrego datos a la tabla auxiliar del dibujo
            cTables["__AuxData__"].Add(sTableid, sTableName)

            cTable = New Collection

            cTables.Add(cTable, sTableName)

            ' verifico que la tabla no tenga entradas, lo que me altera la carga
            If lpvalue <> "ENDTAB" Then
                'NewObject(cTable, sTableHandle)
                Load31Table(cTable, iTableEntries)
            End If
        End If
        ReadData
    Loop

End
'' Lee todas las tables de esta table

Private Sub Load31Table(cVars As Collection, iEntries As Integer)

    ' Yo usare dos colecciones

    Dim sTableName, sid As String
    Dim cTable As Collection
    Dim i As Integer

    Dim iCode As Integer, NewKey As String

    ' Tengo q leer iEntries
    'For i = 1 To iEntries
    Do
        Inc i
        cTable = New Collection
        sTableName = ""
        iCode = 0

        ReadData

        ' esto lee todas las tables en la table

        'If lpCode = "0" Then Break

        While lpcode <> "0"
            NewKey = lpcode
            If cTable.Exist(NewKey) Then
                Do
                    iCode += 1
                    NewKey = lpcode & "_" & CStr(iCode)

                    If Not cTable.Exist(NewKey) Then Break
                Loop
            Endif
            cTable.Add(lpvalue, NewKey)

            If lpcode = Me.codid Then sTableName = lpvalue
            ReadData

        Wend
        'If cTable.Count = 1 Then Stop
        If cTable.Count > 0 Then
            If sTableName = "" Then sTableName = CStr(i)
            cVars.Add(cTable, sTableName)

        Endif

        If lpcode = "0" And lpValue = "ENDTAB" Then Break

    Loop

    If cTable.Exist("5") Then
        sid = cTable["5"]
    Else If cTable.Exist("105") Then
        sid = cTable["105"]
    Else If cTable.Exist("2") Then
        sid = cTable["2"]
    Else
        sid = gcd.Newid()

    Endif
    'NewObject(cTable, sHandle)

    'gcd.JSONtoLayers

    Try gcd.debuginfo("DXF: Leidas" & cTable.count & " tablas")

End

Private Sub Load4Blocks(cBlocks As Collection)

    Dim mBlock As Block
    Dim unread As Variant
    Dim i As Integer

    Dim sTableName As String

    Dim cTable, cEntities As Collection

    Dim iCode As Integer, NewKey As String

    ReadData
    Do

        mBlock = New Block

        If lpCode = "0" And lpValue = "ENDSEC" Then Break

        If (lpcode = "0") And (lpvalue = "BLOCK") Then
            Inc i
            cTable = New Collection

            ReadData

            If lpcode = "" Then Break

            While lpcode <> "0"
                NewKey = lpcode
                If cTable.Exist(NewKey) Then
                    Do
                        iCode += 1
                        NewKey = lpcode & "_" & CStr(iCode)

                        If Not cTable.Exist(NewKey) Then Break
                    Loop
                Endif

                If lpcode = Me.codid Then sTableName = lpvalue
                cTable.Add(lpvalue, NewKey)
                ReadData

            Wend    ' fin del encabezado del Block, siguen sus entidades
            'NewObject(cTable, cTable["5"])
            ' si estoy leyendo bloques, significa que estoy abriendo un plano
            cEntities = New Collection
            cTable.Add(cEntities, "entities")

            Load5Entities(cEntities)

            If sTableName = "" Then sTableName = CStr(i)

            cBlocks.Add(cTable, sTableName)

        Endif
    Loop

    gcd.debuginfo("DXF: Leidos " & cBlocks.Count & " bloques")

End

Private Sub Load5Entities(cEntities As Collection)

    Dim sClave As String[]
    Dim sValue As String[]
    Dim sEntidad, sKey As String
    Dim clsidr As Object
    Dim eNueva As Entity
    Dim Reads As Boolean

    Dim cEntity As Collection
    Dim iEntity As Integer

    Dim iCode As Integer, NewKey As String

    Do
        'Debug lpcode, lpvalue
        sClave = New String[]

        sValue = New String[]

        If lpValue = "ENTITIES" Then ReadData
        If lpValue = "ENDSEC" Then Return

        sEntidad = lpValue
        Inc iEntity
        cEntity = New Collection

        cEntity.Add(sEntidad, "0")
        iCode = 0

        ' Leo descentralizadamente las entidades
        ReadData

        While (lpcode <> "0") And Not Eof(fp)

            NewKey = lpcode
            If cEntity.Exist(NewKey) Then
                Do
                    iCode += 1
                    NewKey = lpcode & "_" & CStr(iCode)

                    If Not cEntity.Exist(NewKey) Then Break
                Loop
            Endif

            If sEntidad <> "ENDSEC" Then cEntity.Add(lpvalue, NewKey)
            ReadData

        Wend

        'NewObject(cEntity, cEntity[dxf.codHandle])

        If cEntity.Exist(dxf.codid) Then
            sKey = cEntity[dxf.codid]
        End If
        If sKey = "" Then

            sKey = gcd.NewId()

        End If

        If sEntidad <> "ENDBLK" Then cEntities.Add(cEntity, sKey)

        If sEntidad = "ENDBLK" Or sEntidad = "ENDSEC" Then Return

    Loop Until Eof(fp)

End

Private Sub Load6Objects(cObjects As Collection)

    Dim sClave As String[]
    Dim sValue As String[]
    Dim sEntidad, h As String
    Dim clsidr As Object
    Dim eNueva As Entity
    Dim Reads As Boolean

    Dim cObject As Collection
    Dim iObject As Integer

    Dim iCode As Integer, NewKey As String

    Do
        'Debug lpcode, lpvalue
        sClave = New String[]

        sValue = New String[]

        If lpValue = "OBJECTS" Then ReadData
        If lpValue = "ENDSEC" Then Return

        sEntidad = lpValue
        Inc iObject
        cObject = New Collection

        cObject.Add(sEntidad, "0")
        iCode = 0

        ' Leo descentralizadamente las entidades
        ReadData

        'If sEntidad = "HATCH" Then Stop
        While (lpcode <> "0") And Not Eof(fp)

            NewKey = lpcode
            If cObject.Exist(NewKey) Then
                Do
                    iCode += 1
                    NewKey = lpcode & "_" & CStr(iCode)

                    If Not cObject.Exist(NewKey) Then Break
                Loop
            Endif
            cObject.Add(lpvalue, NewKey)
            ReadData

        Wend
        'NewObject(cObject, cObject["5"])
        If cObject.Exist("5") Then
            h = cObject["5"]
        Else
            h = CStr(iObject)
        Endif
        cObjects.Add(cObject, h)

        If sEntidad = "ENDBLK" Or sEntidad = "" Then Return

    Loop

End

Private Sub Load7Thumbnail(cThumbnail As Collection)

    Dim iCode As Integer, NewKey As String

    Do

        If lpValue = "ENDSEC" Then Return

        ' Leo descentralizadamente las entidades
        ReadData

        While (lpcode <> "0") And Not Eof(fp)

            NewKey = lpcode
            If cThumbnail.Exist(NewKey) Then
                Do
                    iCode += 1
                    NewKey = lpcode & "_" & CStr(iCode)

                    If Not cThumbnail.Exist(NewKey) Then Break
                Loop
            Endif
            cThumbnail.Add(lpvalue, NewKey)
            ReadData

        Wend

    Loop

End

Public Function SaveFile(sName As String, drwToSAve As Drawing, Optional LoadMinimal As Boolean = False, SaveHeader As Boolean = True, SaveTables As Boolean = True, SaveBlocks As Boolean = True, SaveThumbnail As Boolean = True) As Integer

    hFile = Open sName For Create

    ' Las HANDLES
    ' 0 -> Es el Drawing
    ' 1 -> Es la tabla Block_Record
    ' 2 -> Es la entrada en el Block_Record del model view
    ' 3 -> Es el BLOCK del *Model
    ' 4 -> Es el Block_Record del *Paper
    ' 5 -> Es el BLOCK del *Paper
    ' A -> Es el OBJECT LAYOUT asociado al *Model
    ' B -> Es el OBJECT LAYOUT asociado al *Paper
    '   -> Tabla LType
    '   -> Tabla Layer
    '   -> Tabla Style
    '   -> Tabla DimStyle
    '10 -> Tabla Viewport
    '   -> Tabla View
    '   -> Tabla AppId

    '
    ' Las TABLES tiene su entrada y su owner es el 0=Drawing
    ' Los BLOCKS tienen su handle y su owner es la entrada en el Block_Record
    ' Las entidades tienen su handle y su owner es un BLOCK o el MODEL o algun PAPER o alguna entidad contenedora (INSERT HATCH, etc), que son bloques tambien
    gcd.ResetChronograph
    Inc Application.Busy
    If SaveHeader Then
        If Save1HeadersAndVarsDirect(drwToSAve) Then Goto Error1

        If Save2Classes(drwToSAve) Then Goto Error1
    End If
    If SaveTables Then
        If Save3TablesDirect(drwToSAve) Then Goto Error1
    End If
    If SaveBlocks Then
        If Save4BlocksDirect(drwToSAve) Then Goto Error1

    End If
    Dim s As Sheet, cEntities As Collection
    Print #hFIle, "  0"
    Print #hFIle, "SECTION"
    Print #hFIle, "  2"
    Print #hFIle, "ENTITIES"
    For Each s In drwToSAve.Sheets

        If Save5EntitiesDirect(s.Entities, s.Block.idContainer) Then Goto Error1

    Next
    ' end section code
    Print #hFIle, "  0"
    Print #hFIle, "ENDSEC"

    If Save6Objects(drwToSAve) Then Return False
    If SaveThumbnail Then
        Save7ThumbNail(Null)
    End If

    hFile.Close
    Dec Application.Busy
    gcd.debugInfo(("Saved to ") & sName,,, True, True)
    Return 0
    ' Catch
Error1:
    '     hFile.Close
    '
    '     Message.Error(("Error saving file"))
    '     Return -1

End

Private Function Save1HeadersAndVarsDirect(drw As Drawing) As Integer

    Dim sValues As String
    Dim stxHeaders As String[]

    Print #hFIle, "999"
    Print #hFIle, "GambasCAD"
    Print #hFIle, "  0"
    Print #hFIle, "SECTION"
    Print #hFIle, "2"
    Print #hFIle, "HEADER"

    'Intento guardar algunas cosas utiles para cuando abra de nuevo este archivo
    drw.Headers.CLAYER = drw.CurrLayer.Name

    stxHeaders = drw.Headers.ExportDXF()

    For Each sValues In stxHeaders
        Print #hFile, sValues
    Next
    Print #hFIle, "  0"
    Print #hFIle, "ENDSEC"

End

' Las classes de cad no las usamos. En teoria, no tienen ninguna utilidad fuera de AutoCAD.
' Abriendo un DXF, se guadaran todas las classes a efectos de recosntruir el DXF.
Private Function Save2Classes(drwSaving As Drawing) As Integer

    Dim cClass As CadClass

    ' Dim i As Integer

    Print #hFIle, "  0"
    Print #hFIle, "SECTION"
    Print #hFIle, "  2"
    Print #hFIle, "CLASSES"

    ' For Each cClass In drwSaving.CadClasses
    '     Print #hFIle, "  0"
    '     Print #hFIle, "CLASS"
    '
    '     Print #hFile, "  1"
    '     Print #hFIle, cClass.RecordName
    '
    '     Print #hFile, "  2"
    '     Print #hFIle, cClass.CPPName
    '
    '     Print #hFile, "  3"
    '     Print #hFIle, cClass.AppName
    '
    '     Print #hFile, " 90"
    '     Print #hFIle, CStr(cClass.ProxyCapp)
    '
    '     Print #hFile, " 91"
    '     Print #hFIle, CStr(cClass.InstanceCount)
    '
    '     Print #hFile, "280"
    '     Print #hFIle, CStr(cClass.ProxyFlag)
    '
    '     Print #hFile, "281"
    '     Print #hFIle, CStr(cClass.EntityFlag)
    '
    ' Next
    ' end section code
    Print #hFIle, "  0"
    Print #hFIle, "ENDSEC"

End

Private Function Save3TablesDirect(drw As Drawing) As Integer

    Dim cTable, cTableEntry, cVar, cVars As Collection
    Dim sValues, lpclave, sHandle1, ss As String
    Dim sTableid As String
    Dim i, iDimCounter, iSheetCounter As Integer, s As Sheet, b As Block, e, e2 As Entity

    ' antes que nada armo el block_record
    sHandle1 = NewHandle(1)
    ' Handle_Block_REcord = New Collection
    ' Handle_Block = New Collection
    ' Handle_Layout = New Collection
    '

    ' For Each s In drw.Sheets
    '
    '     s.Block.idContainer = NewHandle()
    '     s.Block.id = NewHandle()
    '     s.id = NewHandle()
    '     s.Block.idAsociatedLayout = s.id
    '     For Each e In s.Block.entities
    '         e.IdContainer = s.Block.idContainer
    '         e.id = NewHandle()
    '     Next
    '
    ' Next
    For Each s In drw.Sheets

        s.Block.idContainer = NewHandle()
        s.Block.id = NewHandle()
        s.id = NewHandle()
    Next
    hObjects = NewHandle()
    hDictionary = NewHandle()
    For Each b In drw.Blocks
        If b.Sheet Then Continue
        b.idContainer = NewHandle()
        b.id = NewHandle()
        ' For Each e In b.entities
        '     e.IdContainer = b.idContainer
        '     e.id = NewHandle()
        ' Next
    Next

    ' For Each s In drw.Sheets
    '     For Each e In s.Entities
    '         If InStr(e.Gender, "DIMENSION") > 0 Then
    '             e.pBlock.name = "*D" & Str(iDimCounter)
    '             e.pBlock.idContainer = NewHandle()
    '             e.pBlock.id = NewHandle()
    '             For Each e2 In e.pBlock.entities
    '                 e2.IdContainer = e.pBlock.idContainer
    '                 e2.id = NewHandle()
    '             Next
    '             ' Handle_Block_Record.Add(NewHandle(), e.pBlock.name)
    '             ' Handle_Block.Add(NewHandle(), e.pBlock.name)
    '             Inc iDimCounter
    '         Endif
    '     Next
    '     Inc iSheetCounter
    ' Next

    ' For Each s In drw.Sheets
    '     For Each e In s.Entities
    '         If InStr(e.Gender, "DIMENSION") > 0 Then
    '             For Each e2 In e.pBlock.entities
    '                 e2.IdContainer = e.pBlock.idContainer
    '                 e2.id = NewHandle()
    '             Next
    '             ' Handle_Block_Record.Add(NewHandle(), e.pBlock.name)
    '             ' Handle_Block.Add(NewHandle(), e.pBlock.name)
    '             Inc iDimCounter
    '         Endif
    '     Next
    '     Inc iSheetCounter
    ' Next

    ' Empiezo la seccion tables
    Print #hFIle, "  0"
    Print #hFIle, "SECTION"
    Print #hFIle, "2"
    Print #hFIle, "TABLES"

    Save3TableViewPorts(drw)
    Save3TableLineTypes(drw)
    Save3TableLayers(drw)
    Save3TableTextStyles(drw)
    Save3TableViews(drw)
    Save3TableAppID(drw)
    Save3TableUCSs(drw)
    Save3TableDimStyles(drw)
    save31BlockRecord(drw)
    Print #hFIle, "  0"
    Print #hFIle, "ENDSEC"

End

Private Function Save3TableAppID(drw As Drawing) As Integer

    Dim hTableHandle As String

    hTableHandle = NewHandle()'Utils.FindItem(drw.Tables, drw.AppIDs)

    Print #hFIle, "  0"
    Print #hFIle, "TABLE"
    Print #hFIle, "  2"
    Print #hFIle, "APPID"
    Print #hFIle, "  5"         ' handle
    Print #hFIle, hTableHandle
    Print #hFIle, "  330"   ' handle al padre de esta tabla, que es 0 porque pertenece al drawing
    Print #hFIle, "0"
    Print #hFIle, "  100"
    Print #hFIle, "AcDbSymbolTable"
    Print #hFIle, "  70"
    Print #hFIle, CStr(drw.AppIDs.Count)

    ' APPID
    Dim oneAppid As APPID
    For Each oneAppid In drw.AppIDs

        Print #hFIle, "  0"
        Print #hFIle, "APPID"
        Print #hFIle, "  5"                     ' handle propio
        Print #hFIle, NewHandle()'oneAppid.id
        Print #hFIle, "  330"                   ' handle del padre
        Print #hFIle, hTableHandle
        Print #hFIle, "  100"
        Print #hFIle, "AcDbSymbolTableRecord"
        Print #hFIle, "  100"
        Print #hFIle, "AcDbRegAppTableRecord"
        Print #hFIle, "  2"
        Print #hFIle, oneAppid.APPName_2
        Print #hFIle, " 70"
        Print #hFIle, CStr(oneAppid.Flags_70)
    Next
    Print #hFIle, "  0"
    Print #hFIle, "ENDTAB"

End

Private Function Save3TableLayers(drw As Drawing) As Integer

    Dim hTableHandle As String

    hTableHandle = NewHandle()'Utils.FindItem(drw.Tables, drw.Layers)

    Print #hFIle, "  0"
    Print #hFIle, "TABLE"
    Print #hFIle, "  2"
    Print #hFIle, "LAYER"
    Print #hFIle, "  5"         ' handle
    Print #hFIle, hTableHandle
    Print #hFIle, "  330"   ' handle al padre de esta tabla, que es 0 porque pertenece al drawing
    Print #hFIle, "0"
    Print #hFIle, "  100"
    Print #hFIle, "AcDbSymbolTable"
    Print #hFIle, "  70"
    Print #hFIle, CStr(drw.Layers.Count)

    Dim oneLayer As Layer
    For Each oneLayer In drw.Layers

        Print #hFIle, "  0"
        Print #hFIle, "LAYER"
        Print #hFIle, "  5"                     ' handle propio
        Print #hFIle, NewHandle()'oneLayer.id
        Print #hFIle, "  330"                   ' handle del padre
        Print #hFIle, hTableHandle
        Print #hFIle, "  100"
        Print #hFIle, "AcDbSymbolTableRecord"
        Print #hFIle, "  100"
        Print #hFIle, "AcDbLayerTableRecord"
        Print #hFIle, "  2"
        Print #hFIle, oneLayer.Name
        Print #hFIle, " 70"                       ' layer flags, bit coded
        Print #hFIle, CStr(-oneLayer.Frozen - oneLayer.Locked * 4)
        Print #hFIle, " 62"
        Print #hFIle, oneLayer.Colour * IIf(oneLayer.Visible, 1, -1)
        Print #hFIle, "  6"
        Print #hFIle, oneLayer.LineType.Name
        Print #hFIle, "290"                   ' plotting flag
        Print #hFIle, IIf(oneLayer.Printable, "1", "0")
        Print #hFIle, "370"                   ' linewt
        Print #hFIle, CStr(oneLayer.LineWt)
        Print #hFIle, "390"                   ' plotstyle object
        Print #hFIle, " "
        Print #hFIle, "347"                   ' material
        Print #hFIle, " "

    Next
    Print #hFIle, "  0"
    Print #hFIle, "ENDTAB"

End

Private Function Save3TableTextStyles(drw As Drawing) As Integer

    Dim hTableHandle As String

    hTableHandle = NewHandle()'Utils.FindItem(drw.Tables, drw.TextStyles)

    Print #hFIle, "  0"
    Print #hFIle, "TABLE"
    Print #hFIle, "  2"
    Print #hFIle, "STYLE"
    Print #hFIle, "  5"         ' handle
    Print #hFIle, hTableHandle
    Print #hFIle, "  330"   ' handle al padre de esta tabla, que es 0 porque pertenece al drawing
    Print #hFIle, "0"
    Print #hFIle, "  100"
    Print #hFIle, "AcDbSymbolTable"
    Print #hFIle, "  70"
    Print #hFIle, CStr(drw.TextStyles.Count)

    Dim oneTextStyle As TextStyle
    For Each oneTextStyle In drw.TextStyles

        Print #hFIle, "  0"
        Print #hFIle, "STYLE"
        Print #hFIle, "  5"                     ' handle propio
        Print #hFIle, NewHandle()'oneTextStyle.Id
        Print #hFIle, "  330"                   ' handle del padre
        Print #hFIle, hTableHandle
        Print #hFIle, "  100"
        Print #hFIle, "AcDbSymbolTableRecord"
        Print #hFIle, "  100"
        Print #hFIle, "AcDbTextStyleTableRecord"
        Print #hFIle, "  2"
        Print #hFIle, oneTextStyle.name
        Print #hFIle, " 70"                       ' flags, bit coded
        Print #hFIle, oneTextStyle.Flags
        Print #hFIle, " 40"
        Print #hFIle, CStr(oneTextStyle.FixedH_40)
        Print #hFIle, " 41"
        Print #hFIle, CStr(oneTextStyle.WidthFactor)
        Print #hFIle, " 50"
        Print #hFIle, CStr(oneTextStyle.ObliqueAngle)
        Print #hFIle, " 71"
        Print #hFIle, CStr(oneTextStyle.iDirection)
        Print #hFIle, " 42"
        Print #hFIle, CStr(oneTextStyle.fLastHeightUsed_42)
        Print #hFIle, "  3"
        Print #hFIle, oneTextStyle.sFont_3
        Print #hFIle, "  4"
        Print #hFIle, oneTextStyle.sBigFont_4

    Next
    Print #hFIle, "  0"
    Print #hFIle, "ENDTAB"

End

Private Function Save3TableDimStyles(drw As Drawing) As Integer

    Dim hTableHandle As String

    hTableHandle = NewHandle()'Utils.FindItem(drw.Tables, drw.DimStyles)

    Print #hFIle, "  0"
    Print #hFIle, "TABLE"
    Print #hFIle, "  2"
    Print #hFIle, "DIMSTYLE"
    Print #hFIle, "  5"         ' handle
    Print #hFIle, hTableHandle
    Print #hFIle, "  330"   ' handle al padre de esta tabla, que es 0 porque pertenece al drawing
    Print #hFIle, "0"
    Print #hFIle, "  100"
    Print #hFIle, "AcDbSymbolTable"
    Print #hFIle, "  70"
    Print #hFIle, CStr(drw.DimStyles.Count)

    Dim oneDimtStyle As DimStyle
    For Each oneDimtStyle In drw.DimStyles

        Print #hFIle, "  0"
        Print #hFIle, "DIMSTYLE"
        Print #hFIle, " 105"                     ' handle propio
        Print #hFIle, NewHandle()'oneDimtStyle.id
        Print #hFIle, " 330"                   ' handle del padre
        Print #hFIle, hTableHandle
        Print #hFIle, " 100"
        Print #hFIle, "AcDbSymbolTableRecord"
        Print #hFIle, " 100"
        Print #hFIle, "AcDbDimStyleTableRecord"
        Print #hFIle, "  2"
        Print #hFIle, oneDimtStyle.name
        Print #hFIle, " 70"                       ' flags, bit coded
        Print #hFIle, "0"                         ' no lo usamos
        SaveCode(3, oneDimtStyle.DIMPOST)
        SaveCode(4, oneDimtStyle.DIMAPOST)
        SaveCode(5, oneDimtStyle.DIMBLK)
        SaveCode(6, oneDimtStyle.DIMBLK1)
        SaveCode(7, oneDimtStyle.DIMBLK2)
        SaveCode(40, oneDimtStyle.DIMSCALE)
        SaveCode(41, oneDimtStyle.DIMASZ)
        SaveCode(42, oneDimtStyle.DIMEXO)
        SaveCode(43, oneDimtStyle.DIMDLI)
        SaveCode(44, oneDimtStyle.DIMEXE)
        SaveCode(45, oneDimtStyle.DIMRND)
        SaveCode(46, oneDimtStyle.DIMDLE)
        SaveCode(47, oneDimtStyle.DIMTP)
        SaveCode(48, oneDimtStyle.DIMTM)
        SaveCode(140, oneDimtStyle.DIMTXT)
        SaveCode(141, oneDimtStyle.DIMCEN)
        SaveCode(142, oneDimtStyle.DIMTSZ)
        SaveCode(143, oneDimtStyle.DIMALTF)
        SaveCode(144, oneDimtStyle.DIMLFAC)
        SaveCode(145, oneDimtStyle.DIMTVP)
        SaveCode(146, oneDimtStyle.DIMTFAC)
        SaveCode(147, oneDimtStyle.DIMGAP)
        SaveCode(148, oneDimtStyle.DIMALTRND)
        SaveCode(71, oneDimtStyle.DIMTOL)
        SaveCode(72, oneDimtStyle.DIMLIM)
        SaveCode(73, oneDimtStyle.DIMTIH)
        SaveCode(74, oneDimtStyle.DIMTOH)
        SaveCode(75, oneDimtStyle.DIMSE1)
        SaveCode(76, oneDimtStyle.DIMSE2)
        SaveCode(77, oneDimtStyle.DIMTAD)
        SaveCode(78, oneDimtStyle.DIMZIN)
        SaveCode(79, oneDimtStyle.DIMAZIN)
        SaveCode(170, oneDimtStyle.DIMALT)
        SaveCode(171, oneDimtStyle.DIMALTD)
        SaveCode(172, oneDimtStyle.DIMTOFL)
        SaveCode(173, oneDimtStyle.DIMSAH)
        SaveCode(174, oneDimtStyle.DIMTIX)
        SaveCode(175, oneDimtStyle.DIMSOXD)
        SaveCode(176, oneDimtStyle.DIMCLRD)
        SaveCode(177, oneDimtStyle.DIMCLRE)
        SaveCode(178, oneDimtStyle.DIMCLRT)
        SaveCode(179, oneDimtStyle.DIMADEC)
        SaveCode(270, oneDimtStyle.DIMUNIT)
        SaveCode(271, oneDimtStyle.DIMDEC)
        SaveCode(272, oneDimtStyle.DIMTDEC)
        SaveCode(273, oneDimtStyle.DIMALTU)
        SaveCode(274, oneDimtStyle.DIMALTTD)
        SaveCode(275, oneDimtStyle.DIMAUNIT)
        SaveCode(276, oneDimtStyle.DIMFRAC)
        SaveCode(277, oneDimtStyle.DIMLUNIT)
        SaveCode(278, oneDimtStyle.DIMDSEP)
        SaveCode(279, oneDimtStyle.DIMTMOVE)
        SaveCode(280, oneDimtStyle.DIMJUST)
        SaveCode(281, oneDimtStyle.DIMSD1)
        SaveCode(282, oneDimtStyle.DIMSD2)
        SaveCode(283, oneDimtStyle.DIMTOLJ)
        SaveCode(284, oneDimtStyle.DIMTZIN)
        SaveCode(285, oneDimtStyle.DIMALTZ)
        SaveCode(286, oneDimtStyle.DIMALTTZ)
        SaveCode(287, oneDimtStyle.DIMFIT)
        SaveCode(288, oneDimtStyle.DIMUPT)
        SaveCode(289, oneDimtStyle.DIMATFIT)
        SaveCode(340, oneDimtStyle.DIMTXSTY)
        SaveCode(341, oneDimtStyle.DIMLDRBLK)
        SaveCode(342, oneDimtStyle.DIMBLK)
        SaveCode(343, oneDimtStyle.DIMBLK1)
        SaveCode(344, oneDimtStyle.DIMBLK2)
        SaveCode(371, oneDimtStyle.DIMLWD)
        SaveCode(372, oneDimtStyle.DIMLWE)

    Next
    Print #hFIle, "  0"
    Print #hFIle, "ENDTAB"

End

Private Function Save3TableLineTypes(drw As Drawing) As Integer

    Dim hTableHandle As String

    hTableHandle = NewHandle()'Utils.FindItem(drw.Tables, drw.LineTypes)

    Print #hFIle, "  0"
    Print #hFIle, "TABLE"
    Print #hFIle, "  2"
    Print #hFIle, "LTYPE"
    Print #hFIle, "  5"         ' handle
    Print #hFIle, hTableHandle
    Print #hFIle, "  330"   ' handle al padre de esta tabla, que es 0 porque pertenece al drawing
    Print #hFIle, "0"
    Print #hFIle, "  100"
    Print #hFIle, "AcDbSymbolTable"
    Print #hFIle, "  70"
    Print #hFIle, CStr(drw.LineTypes.Count)

    Dim oneLtype As LineType
    For Each oneLtype In drw.LineTypes

        Print #hFIle, "  0"
        Print #hFIle, "LTYPE"
        Print #hFIle, "  5"                     ' handle propio
        Print #hFIle, NewHandle()'oneLtype.id
        Print #hFIle, "  330"                   ' handle del padre
        Print #hFIle, hTableHandle
        Print #hFIle, "  100"
        Print #hFIle, "AcDbSymbolTableRecord"
        Print #hFIle, "  100"
        Print #hFIle, "AcDbLinetypeTableRecord"
        SaveCode(2, oneLtype.Name)
        SaveCode(70, oneLtype.Flags)
        SaveCode(3, oneLtype.Description)
        SaveCode(72, 65)                    ' para compatibilidad
        SaveCode(73, oneLtype.nTrames)
        SaveCode(40, CStr(oneLtype.Length))
        For Each fLenght As Float In oneLtype.TrameLength
            SaveCode(49, CStr(fLenght))
        Next

        ' Hay tipos de linea mas complejos, que se generan con codigos que GambasCAD no maneja de momento

    Next
    Print #hFIle, "  0"
    Print #hFIle, "ENDTAB"

End

Private Function Save3TableUCSs(drw As Drawing) As Integer

    Dim hTableHandle As String

    hTableHandle = NewHandle()'Utils.FindItem(drw.Tables, drw.UCSs)

    Print #hFIle, "  0"
    Print #hFIle, "TABLE"
    Print #hFIle, "  2"
    Print #hFIle, "UCS"
    Print #hFIle, "  5"         ' handle
    Print #hFIle, hTableHandle
    Print #hFIle, "  330"   ' handle al padre de esta tabla, que es 0 porque pertenece al drawing
    Print #hFIle, "0"
    Print #hFIle, "  100"
    Print #hFIle, "AcDbSymbolTable"
    Print #hFIle, "  70"
    Print #hFIle, CStr(drw.UCSs.Count)

    Dim oneUCS As UCS
    For Each oneUCS In drw.UCSs

        Print #hFIle, "  0"
        Print #hFIle, "UCS"
        Print #hFIle, "  5"                     ' handle propio
        Print #hFIle, NewHandle()'oneUCS.id
        Print #hFIle, "  330"                   ' handle del padre
        Print #hFIle, hTableHandle
        Print #hFIle, "  100"
        Print #hFIle, "AcDbSymbolTableRecord"
        Print #hFIle, "  100"
        Print #hFIle, "AcDbUCSTableRecord"
        SaveCode(2, oneUCS.Name_2)
        SaveCode(70, oneUCS.Flags_70)
        SaveCode(10, oneUCS.OriginX_10)
        SaveCode(20, oneUCS.OriginY_20)
        SaveCode(30, oneUCS.OriginZ_30)

        SaveCode(11, oneUCS.XAxisX_11)
        SaveCode(21, oneUCS.XAxisY_21)
        SaveCode(31, oneUCS.XAxisZ_31)

        SaveCode(12, oneUCS.YAxisX_12)
        SaveCode(22, oneUCS.YAxisY_22)
        SaveCode(32, oneUCS.YAxisZ_32)

        SaveCode(79, 0)

        SaveCode(146, oneUCS.Elevation_146)
        SaveCode(346, oneUCS.BaseUCS_346)

        SaveCode(13, oneUCS.OriginForThisOrthographicTypeX_13)
        SaveCode(23, oneUCS.OriginForThisOrthographicTypeY_23)
        SaveCode(33, oneUCS.OriginForThisOrthographicTypeZ_33)

    Next
    Print #hFIle, "  0"
    Print #hFIle, "ENDTAB"

End

Private Function Save3TableViews(drw As Drawing) As Integer

    Dim hTableHandle As String

    hTableHandle = NewHandle()'Utils.FindItem(drw.Tables, drw.Views)

    Print #hFIle, "  0"
    Print #hFIle, "TABLE"
    Print #hFIle, "  2"
    Print #hFIle, "VIEW"
    Print #hFIle, "  5"         ' handle
    Print #hFIle, hTableHandle
    Print #hFIle, "  330"   ' handle al padre de esta tabla, que es 0 porque pertenece al drawing
    Print #hFIle, "0"
    Print #hFIle, "  100"
    Print #hFIle, "AcDbSymbolTable"
    Print #hFIle, "  70"
    Print #hFIle, CStr(drw.Views.Count)

    Dim oneView As View, sData As String
    For Each oneView In drw.Views

        Print #hFIle, "  0"
        Print #hFIle, "VIEW"
        Print #hFIle, "  5"                     ' handle propio
        Print #hFIle, NewHandle()'oneView.id
        Print #hFIle, "  330"                   ' handle del padre
        Print #hFIle, hTableHandle
        Print #hFIle, "  100"
        Print #hFIle, "AcDbSymbolTableRecord"
        Print #hFIle, "  100"
        Print #hFIle, "AcDbViewTableRecord"
        For Each sData In oneView.Datos
            Print #hFIle, sData
        Next

    Next
    Print #hFIle, "  0"
    Print #hFIle, "ENDTAB"

End

Private Function Save3TableViewPorts(drw As Drawing) As Integer

    Dim hTableHandle As String

    hTableHandle = NewHandle() 'Utils.FindItem(drw.Tables, drw.Viewports)

    Print #hFIle, "  0"
    Print #hFIle, "TABLE"
    Print #hFIle, "  2"
    Print #hFIle, "VPORT"
    Print #hFIle, "  5"         ' handle
    Print #hFIle, hTableHandle
    Print #hFIle, "  330"   ' handle al padre de esta tabla, que es 0 porque pertenece al drawing
    Print #hFIle, "0"
    Print #hFIle, "  100"
    Print #hFIle, "AcDbSymbolTable"
    Print #hFIle, "  70"
    Print #hFIle, CStr(drw.Viewports.Count)

    Dim oneViewport As Viewport, sData As String
    For Each oneViewport In drw.Viewports

        Print #hFIle, "  0"
        Print #hFIle, "VPORT"
        Print #hFIle, "  5"                     ' handle propio
        Print #hFIle, NewHandle()
        Print #hFIle, "  330"                   ' handle del padre
        Print #hFIle, hTableHandle
        Print #hFIle, "  100"
        Print #hFIle, "AcDbSymbolTableRecord"
        Print #hFIle, "  100"
        Print #hFIle, "AcDbViewportTableRecord"
        For Each sData In oneViewport.Datos
            Print #hFIle, sData
        Next

    Next
    Print #hFIle, "  0"
    Print #hFIle, "ENDTAB"

End

Private Function save31BlockRecord(drw As Drawing) As Integer

    Dim eBlock As Block
    Dim s As Sheet
    Dim cTable, cTableEntry, cVar, cVars As Collection
    Dim sValues, lpclave, sHandle1 As String
    Dim sTableid, sBlockName, sBlockHandle As String
    Dim i, iDimCounter, iPaperSpaceCounter As Integer, b As Block, e As Entity

    Dim InsertUnits, Explotability, Scalability, idAsociatedLayout As String

    ' For Each s In drw.Sheets
    '     For Each e In s.Entities
    '         If InStr(e.Gender, "DIMENSION") > 0 Then
    '             Inc iDimCounter
    '         Endif
    '     Next
    '
    ' Next

    Print #hFIle, "  0"
    Print #hFIle, "TABLE"
    Print #hFIle, "  2"
    Print #hFIle, "BLOCK_RECORD"
    Print #hFIle, "  5"         ' handle
    Print #hFIle, "1"
    Print #hFIle, "  330"   ' handle al padre de esta tabla, que es 0 porque pertenece al drawing
    Print #hFIle, "0"
    Print #hFIle, "  100"
    Print #hFIle, "AcDbSymbolTable"
    Print #hFIle, "  70"
    Print #hFIle, CStr(drw.Sheets.Count + drw.Blocks.Count + iDimCounter)

    ' For Each s In drw.Sheets
    '     sBlockHandle = s.Block.idContainer
    '     sBlockName = s.Block.name
    '     idAsociatedLayout = s.id
    '     InsertUnits = "0"
    '     Explotability = "1"
    '     Scalability = "0"
    '     GoSub SaveBlock
    ' Next
    For Each b In drw.Blocks
        sBlockHandle = b.idContainer
        sBlockName = b.name
        If b.Sheet Then
            idAsociatedLayout = b.Sheet.id
        Else
            idAsociatedLayout = "0"
        End If
        InsertUnits = b.InsertUnits
        Explotability = b.Explotability
        Scalability = b.Scalability
        GoSub SaveBlock
    Next

    ' For Each s In drw.Sheets
    '     For Each e In s.Entities
    '         If InStr(e.Gender, "DIMENSION") > 0 Then
    '             ' e.pBlock.name = "*D" & Str(iDimCounter)
    '             ' e.pBlock.idContainer = NewHandle()
    '             ' e.pBlock.id = NewHandle()
    '             ' Handle_Block_Record.Add(NewHandle(), e.pBlock.name)
    '             ' Handle_Block.Add(NewHandle(), e.pBlock.name)
    '             sBlockHandle = e.pBlock.idContainer
    '             sBlockName = e.pBlock.name
    '             idAsociatedLayout = "0"
    '             GoSub SaveBlock
    '         Endif
    '     Next
    '
    ' Next

    ' For Each sBlockHandle In Handle_Block_Record
    '     ' busco datos extra
    '     sBlockName = Handle_Block_Record.Key
    '     If drw.Sheets.Exist(sBlockName) Then
    '         idAsociatedLayout = Handle_Layout[sBlockName]
    '         If drw.Sheets[sBlockName].IsModel Then
    '             sBlockName = "*Model_Space"
    '         Else
    '             sBlockName = "*Paper_Space" & Str(iPaperSpaceCounter)
    '             Inc iPaperSpaceCounter
    '         Endif
    '         InsertUnits = "0"
    '         Explotability = "1"
    '         Scalability = "0"
    '     Else If drw.Blocks.Exist(sBlockName) Then
    '         InsertUnits = drw.Blocks[sBlockName].InsertUnits
    '         Explotability = drw.Blocks[sBlockName].Explotability
    '         Scalability = drw.Blocks[sBlockName].Scalability
    '         idAsociatedLayout = "0"
    '     Else
    '         sBlockName = Handle_Block_Record.Key
    '         InsertUnits = "0"
    '         Explotability = "0"
    '         Scalability = "0"
    '         idAsociatedLayout = "0"
    '     Endif
    '     GoSub SaveBlock
    ' Next

    Print #hFIle, "  0"
    Print #hFIle, "ENDTAB"
    Return

SaveBlock:

    Print #hFIle, "  0"
    Print #hFIle, "BLOCK_RECORD"
    Print #hFIle, "  5"         ' handle
    Print #hFIle, sBlockHandle
    Print #hFIle, " 330"
    Print #hFIle, "1"
    Print #hFIle, " 100"
    Print #hFIle, "AcDbSymbolTableRecord"
    Print #hFIle, " 100"
    Print #hFIle, "AcDbBlockTableRecord"
    Print #hFIle, "  2"
    Print #hFIle, sBlockName
    Print #hFIle, " 340"
    Print #hFIle, idAsociatedLayout
    Print #hFIle, "  70"
    Print #hFIle, InsertUnits
    Print #hFIle, " 280"
    Print #hFIle, Explotability
    Print #hFIle, " 281"
    Print #hFIle, Scalability

    Return

End

Private Function Save4BlocksDirect(drw As Drawing) As Integer

    Dim i, iPaperSpaceCounter As Integer, bCan As Boolean
    Dim iii As Integer
    Dim eBlock As Block, stxEnty As New String[], eEnty As Entity
    Dim sValues, lpclave, sBlockName As String
    Dim s As Sheet, eBlocks As Collection, e, e2 As Entity

    SaveCode(0, "SECTION")
    SaveCode(2, "BLOCKS")

    ' For Each s In drw.Sheets
    '
    '     Print #hFIle, "  0"
    '     Print #hFIle, "BLOCK"
    '     Print #hFIle, "  5"         ' handle
    '     Print #hFIle, s.Block.id ' Handle_Block[s.name] ' Handle_Block[drw.Sheets.name]
    '     Print #hFIle, "  330"
    '     Print #hFIle, s.Block.idContainer 'Handle_Block_Record[s.name] 'eBlock.idContainer' Handle_Block_Record[drw.Sheets.key] 'eBlock.idContainer
    '     Print #hFIle, "  100"
    '     Print #hFIle, "AcDbEntity"
    '     Print #hFIle, " 8"          ' layer name
    '     Print #hFIle, "0" ' eBlock.layer
    '     Print #hFIle, "100"
    '     Print #hFIle, "AcDbBlockBegin"
    '     Print #hFIle, "  2"
    '     Print #hFIle, s.Block.name 'sBlockName 'drw.Sheets.key ' eBlock.name
    '     Print #hFIle, "  70"
    '     Print #hFIle, "0" 'eBlock.Flags
    '     Print #hFIle, codX0
    '     Print #hFIle, 0 'eBlock.x0
    '     Print #hFIle, cody0
    '     Print #hFIle, 0' eBlock.y0
    '     Print #hFIle, codz0
    '     Print #hFIle, 0' eBlock.z0
    '     Print #hFIle, "  3"
    '     Print #hFIle, s.Block.name 'sBlockName 'drw.Sheets.key ' eBlock.name
    '     Print #hFIle, "  1"
    '     Print #hFIle, ""            ' X ref path
    '
    '     SaveCode(0, "ENDBLK")
    '     SaveCode(5, NewHandle())
    '     SaveCode(330, s.Block.idContainer)
    '     SaveCode(100, "AcDbEntity")
    '     SaveCode(8, "0")
    '     SaveCode(100, "AcDbBlockEnd")
    ' Next

    For Each eBlock In drw.Blocks

        SaveCode(0, "BLOCK")
        SaveCode(5, eBlock.id)              'Handle_Block[eBlock.name]
        SaveCode(330, eBlock.idContainer)   'Handle_Block_Record[eBlock.name]
        SaveCode(100, "AcDbEntity")
        SaveCode(8, eBlock.layer)
        SaveCode(100, "AcDbBlockBegin")
        SaveCode(2, eBlock.name)
        SaveCode(70, eBlock.Flags)
        SaveCode(codX0, eBlock.x0)
        SaveCode(cody0, eBlock.y0)
        SaveCode(codz0, eBlock.z0)
        SaveCode(3, eBlock.name)
        SaveCode(1, "")            ' X ref path
        If (eBlock.entities.Count > 0) And (eBlock.name <> "*Model_Space") Then

            For Each eEnty In eBlock.entities

                'If Gcd.CCC[eEnty.gender].DXF_export Then
                DXFSaveCommonEntityData(eEnty)
                Gcd.CCC[eEnty.gender].SaveDxfData(eEnty)
                ' Else    ' trato de exportar como vino
                '
                '     gcd.debugInfo(("No puedo guardar este tipo de entidades ") & eEnty.Gender,,, True)
                ' End If
                ' For i = 0 To stxEnty.max Step 2
                '     lpclave = stxEnty[i + 1]
                '     lpvalue = stxEnty[i]
                '     If lpclave = "330" Then lpvalue = eBlock.idContainer 'Handle_Block_Record[eBlock.name]
                '     SaveCode(lpclave, lpvalue)
                ' Next
            Next

            ' que pasa con el ENDBLK?
            ' Al leer, lo guardo como una entidad y, por lo tanto lo tengo en el bloque, pero...corresponde?
            ' no seria mejor generarlo? al fin y al cabo es solo una señal para el lector de archivos (como el SEQEND)

        Endif
        SaveCode(0, "ENDBLK")
        SaveCode(5, NewHandle())
        SaveCode(330, eBlock.idContainer)
        SaveCode(100, "AcDbEntity")
        SaveCode(8, "0")
        SaveCode(100, "AcDbBlockEnd")

    Next

    ' ''dimensions
    ' For Each s In drw.Sheets
    '
    '     For Each e In s.Entities
    '         If InStr(e.Gender, "DIMENSION") > 0 Then
    '
    '             Print #hFIle, "  0"
    '             Print #hFIle, "BLOCK"
    '             Print #hFIle, "  5"         ' handle
    '             Print #hFIle, e.pBlock.id 'Handle_Block[e.pBlock.name]
    '             Print #hFIle, "  330"
    '             Print #hFIle, e.pBlock.idContainer 'Handle_Block_Record[e.pBlock.name]
    '             Print #hFIle, "  100"
    '             Print #hFIle, "AcDbEntity"
    '             Print #hFIle, " 8"          ' layer name
    '             Print #hFIle, "0" ' eBlock.layer
    '             Print #hFIle, "100"
    '             Print #hFIle, "AcDbBlockBegin"
    '             Print #hFIle, "  2"
    '             Print #hFIle, e.pBlock.name
    '             Print #hFIle, "  70"
    '             Print #hFIle, "0" 'eBlock.Flags
    '             Print #hFIle, codX0
    '             Print #hFIle, 0 'eBlock.x0
    '             Print #hFIle, cody0
    '             Print #hFIle, 0' eBlock.y0
    '             Print #hFIle, codz0
    '             Print #hFIle, 0' eBlock.z0
    '             Print #hFIle, "  3"
    '             Print #hFIle, e.pBlock.name
    '             Print #hFIle, "  1"
    '             Print #hFIle, ""            ' X ref path
    '             If (e.pBlock.entities.Count > 0) Then
    '
    '                 For Each eEnty In e.pBlock.entities
    '                     stxEnty = New String[]
    '
    '                     If Gcd.CCC[eEnty.gender].DXF_export Then
    '                         clsEntities.DXFExportCommonCol(eEnty, stxEnty)
    '                         Gcd.CCC[eEnty.gender].ExportDXFCol(eEnty, stxEnty)
    '                     Else    ' trato de exportar como vino
    '
    '                         gcd.debugInfo(("No puedo guardar este tipo de entidades ") & eEnty.Gender,,, True)
    '                     End If
    '                     For i = 0 To stxEnty.max Step 2
    '                         lpclave = stxEnty[i + 1]
    '                         lpvalue = stxEnty[i]
    '                         'If lpclave = "330" Then lpvalue = e.pBlock.idContainer 'Handle_Block_Record[e.pBlock.name]
    '                         Print #hFile, lpclave
    '                         Print #hFIle, lpvalue
    '                     Next
    '                 Next
    '
    '                 ' que pasa con el ENDBLK?
    '                 ' Al leer, lo guardo como una entidad y, por lo tanto lo tengo en el bloque, pero...corresponde?
    '                 ' no seria mejor generarlo? al fin y al cabo es solo una señal para el lector de archivos (como el SEQEND)
    '
    '             Endif
    '
    '             SaveCode(0, "ENDBLK")
    '             SaveCode(5, NewHandle())
    '             SaveCode(330, e.pBlock.idContainer) 'Handle_Block_Record[e.pBlock.name])
    '             SaveCode(100, "AcDbEntity")
    '             SaveCode(8, "0")
    '             SaveCode(100, "AcDbBlockEnd")
    '         End If
    '     Next
    ' Next
    SaveCode(0, "ENDSEC")

End

Private Sub DXFSaveCommonEntityData(e As Entity)

    Dim sGender As String

    sGender = e.Gender
    If InStr(sGender, "DIMENSION_") > 0 Then sGender = "DIMENSION"
    SaveCode(dxf.codEntity, sGender)
    SaveCode(dxf.codid, e.id)
    SaveCode(dxf.codidContainer, e.Container.idContainer)
    SaveCode("100", "AcDbEntity")
    SaveCode(dxf.codLayer, e.pLayer.Name)
    SaveCode(dxf.codLType, e.LineType.Name)
    SaveCode(dxf.codColor, e.colour)
    SaveCode(dxf.codLWht, CStr(e.LineWidth))

End

Private Function Save5EntitiesDirect(eEntys As Collection, hContainer As String) As Integer

    Dim stxEnty As String[]
    Dim eEnty, eBlock As Entity
    Dim sValues, lpclave, hNewHandle As String
    Dim i As Integer, bCan As Boolean

    ' here go all entities
    For Each eEnty In eEntys
        stxEnty = New String[]
        ' veo si lo tengo
        hNewHandle = NewHandle()
        ' bCan = Gcd.CCC[eEnty.gender].DXF_export
        ' If bCan Then
        DXFSaveCommonEntityData(eEnty)
        Gcd.CCC[eEnty.gender].SaveDxfData(eEnty)

        ' For i = 0 To stxEnty.max Step 2
        '     lpclave = stxEnty[i + 1]
        '     lpvalue = stxEnty[i]
        '
        '     If lpclave = "5" Then lpvalue = hNewHandle
        '     If lpclave = "330" Then
        '         If eEnty.Container Then
        '             lpvalue = eEnty.Container.idContainer
        '         Else
        '             lpvalue = hContainer
        '         End If
        '     End If
        '     SaveCode(lpclave, lpvalue)
        ' Next

        If eEnty.Gender = "INSERT" Then
            If (eEnty.pBlock.entities.Count > 0) Then

                For Each eBlock In eEnty.pBlock.entities

                    If eBlock.Gender = "ATTRIB" Then

                        'If Gcd.CCC[eBlock.gender].DXF_export Then
                        DXFSaveCommonEntityData(eBlock)
                        Gcd.CCC[eBlock.gender].SaveDxfData(eBlock)
                        ' Else    ' trato de exportar como vino
                        '
                        '     gcd.debugInfo(("No puedo guardar este tipo de entidades ") & eBlock.Gender,,, True)
                        ' End If
                        ' For i = 0 To stxEnty.max Step 2
                        '     lpclave = stxEnty[i + 1]
                        '     lpvalue = stxEnty[i]
                        '     If lpclave = "5" Then lpvalue = NewHandle()
                        '
                        '     If lpclave = "330" Then
                        '         lpvalue = hNewHandle
                        '     End If
                        '     SaveCode(lpclave, lpvalue)
                        ' Next
                    End If
                Next

                ' que pasa con el ENDBLK?
                ' Al leer, lo guardo como una entidad y, por lo tanto lo tengo en el bloque, pero...corresponde?
                ' no seria mejor generarlo? al fin y al cabo es solo una señal para el lector de archivos (como el SEQEND)

            Endif

            SaveCode(0, "SEQEND")
            SaveCode(5, NewHandle())
            SaveCode(330, hNewHandle)
            SaveCode(100, "AcDbEntity")
            SaveCode(8, "0")
            SaveCode(100, "AcDbBlockEnd")
        Else If (eEnty.Gender = "POLYLINE") Or (eEnty.Gender = "POLYLINE_2D") Then
            If (eEnty.pBlock.entities.Count > 0) Then

                For Each eBlock In eEnty.pBlock.entities

                    'If Gcd.CCC[eBlock.gender].DXF_export Then
                    DXFSaveCommonEntityData(eBlock)
                    Gcd.CCC[eBlock.gender].SaveDxfData(eBlock)
                    ' Else    ' trato de exportar como vino
                    '
                    '     gcd.debugInfo(("No puedo guardar este tipo de entidades ") & eBlock.Gender,,, True)
                    ' End If
                    ' For i = 0 To stxEnty.max Step 2
                    '     lpclave = stxEnty[i + 1]
                    '     lpvalue = stxEnty[i]
                    '     If lpclave = "5" Then lpvalue = NewHandle()
                    '
                    '     If lpclave = "330" Then
                    '         lpvalue = hNewHandle
                    '     End If
                    '     SaveCode(lpclave, lpvalue)
                    ' Next

                Next

            Endif

            SaveCode(0, "SEQEND")
            SaveCode(5, NewHandle())
            SaveCode(330, hNewHandle)
            SaveCode(100, "AcDbEntity")
            SaveCode(8, "0")
            SaveCode(100, "AcDbBlockEnd")
        Endif
        ' Else    ' trato de exportar como vino
        '
        '     gcd.debugInfo(("No puedo guardar este tipo de entidades ") & eEnty.Gender,,, True)
        ' End If
    Next

End

Private Function Save6Objects(drw As Drawing) As Boolean

    Dim sValues, lpclave As String
    Dim i As Integer

    Dim cObject As Collection
    Dim cObjects As New Collection
    Dim s As Sheet

    ' armo un diccionary, requerido por acad
    cObject = New Collection
    InsertCode(0, "DICTIONARY", cObject)
    InsertCode(5, hDictionary, cObject)
    InsertCode(330, "0", cObject)
    For Each s In drw.Sheets
        InsertCode(3, S.Name, cObject)
        InsertCode(350, S.Block.idContainer, cObject)
    Next
    cObjects.Add(cObject, "DICTIONARY")

    For Each s In drw.Sheets
        cObject = New Collection
        objLayout.ExportDXF(s, cObject)
        ' pequeña correccion del handle
        cObject["330"] = hDictionary
        cObjects.Add(cObject, s.Name)
    Next

    SaveCode(0, "SECTION")
    SaveCode(2, "OBJECTS")
    SaveCode(0, "DICTIONARY")
    SaveCode(5, "A")
    SaveCode(330, 0)
    SaveCode(100, "AcDbDictionary")
    SaveCode(280, 0)
    SaveCode(281, 1)
    SaveCode(3, "ACAD_COLOR")
    SaveCode(350, "B")
    SaveCode(3, "ACAD_GROUP")
    SaveCode(350, "C")
    SaveCode(3, "ACAD_LAYOUT")
    SaveCode(350, "D")
    SaveCode(3, "ACAD_MATERIAL")
    SaveCode(350, "E")
    SaveCode(3, "ACAD_MLEADERSTYLE")
    SaveCode(350, "F")
    SaveCode(3, "ACAD_MLINESTYLE")
    SaveCode(350, "10")
    SaveCode(3, "ACAD_PLOTSETTINGS")
    SaveCode(350, "11")
    SaveCode(3, "ACAD_PLOTSTYLENAME")
    SaveCode(350, "12")
    SaveCode(3, "ACAD_SCALELIST")
    SaveCode(350, "14")
    SaveCode(3, "ACAD_TABLESTYLE")
    SaveCode(350, "15")
    SaveCode(3, "ACAD_VISUALSTYLE")
    SaveCode(350, "16")

    SaveCode(2, "DICTIONARY")
    SaveCode(5, "B")
    SaveCode(330, "A")
    SaveCode(100, "AcDbDictionary")
    SaveCode(280, 0)
    SaveCode(281, 1)

    '' FIXME: reparar los papaerspaces
    For Each cObject In cObjects
        SaveColection(cObject)
    Next
    ' end section code
    Print #hFIle, "  0"
    Print #hFIle, "ENDSEC"

End

Private Function Save7ThumbNail(imgGLArea As Image) As Integer

    Dim sValues, lpclave As String
    Dim i As Integer
    Dim cThumbs As Collection

    SaveCode(0, "SECTION")
    SaveCode(2, "THUMBNAILIMAGE")
    ' cThumbs = cData["THUMBNAILIMAGE"]
    ' If Not IsNull(cThumbs) Then
    '   For Each sValues In cThumbs
    '     lpclave = cThumbs.Key
    '     I = InStr(lpclave, "_")
    '     If i > 0 Then lpclave = Left(lpclave, i - 1)
    '     Print #hFile, lpclave
    '     Print #hFIle, sValues
    '   Next
    ' End If
    ' ' end section code
    SaveCode(0, "ENDSEC")

    ' end file code
    SaveCode(0, "EOF")

End

'' Inserta un codigo en una coleccion considerando repeticiones de la Key
Public Sub InsertCode(iCode As Integer, sData As Variant, cAcumulator As Collection)

    Dim NewKey As String, iCodeAux As Integer

    NewKey = Str(iCode)
    If cAcumulator.Exist(NewKey) Then
        Do
            iCodeAux += 1
            NewKey = Str(iCode) & "_" & CStr(iCodeAux)

            If Not cAcumulator.exist(NewKey) Then Break
        Loop
    Endif
    cAcumulator.Add(CStr(sData), NewKey)

End

'   Helper para leer DXF: retorna la posicion en la que encontro la clave o -1 si no la encontro
'   iCode = el codigo DXF
'   stxClaves = array de claves DXF
'   stxValues = array de valores DXF
'   RetValue = el valor a retornar, pasado por referencia
'   iStartPos = la posivion inicial en los array para la busqueda (def = 0)
'   ExactPos = si se busca solo en la posicion inicial (def = false)
Public Function ReadCode(iCode As Integer, stxClaves As String[], stxValues As String[], ByRef RetValue As Variant, Optional iStartPos As Integer = 0, ExactPos As Boolean = False) As Integer

    Dim i, iMax As Integer

    If iStartPos < 0 Then Return iStartPos
    If stxClaves.max <> stxValues.max Then
        Debug "ReadCode: error, bad lists"
        Return -1
    Endif
    If ExactPos Then iMax = iStartPos Else imax = stxClaves.Max
    For i = iStartPos To iMax
        If CInt(stxClaves[i]) = iCode Then
            Select Case TypeOf(RetValue)
                Case gb.Integer
                    RetValue = CInt(stxValues[i])
                    Return i
                Case gb.Float
                    RetValue = CFloat(stxValues[i])
                    Return i
                Case gb.String
                    RetValue = stxValues[i]
                    Return i
            End Select

        Endif
    Next
    Return -1

End
'   Helper para leer DXF: retorna la posicion en la que encontro la clave, -posicion si encotro el escape o 0 si no la encontro
'   iCode = el codigo DXF
'   stxClaves = array de claves DXF
'   stxValues = array de valores DXF
'   RetValue = el valor a retornar, pasado por referencia
'   iStartPos = la posicion inicial en los array para la busqueda (def = 0)
'   iEscapeCode = si encuentra este codigo, sale

Public Function ReadCodePlus(iExpectedCode As Integer, stxClaves As String[], stxValues As String[], ByRef RetValue As Variant, Optional iStartPos As Integer = 0, iEscapeCode As Integer = -1, iStartCode As Integer = -1) As Integer

    Dim i, iMax As Integer
    Dim StartOK As Boolean = True

    If stxClaves.max <> stxValues.max Then
        Debug "ReadCode: error, bad lists"
        Return -1
    Endif
    'If ExactPos Then iMax = iStartPos Else imax = stxClaves.Max
    If iStartCode >= 0 Then StartOK = False
    For i = iStartPos To stxClaves.max
        ' veo si proveyo un codigo inicial
        If iStartCode >= 0 Then

            If CInt(stxClaves[i]) = iStartCode Then
                StartOK = True
            Endif
        Endif

        If Not StartOK Then Continue

        If CInt(stxClaves[i]) = iExpectedCode Then
            Select Case TypeOf(RetValue)
                Case gb.Integer
                    RetValue = CInt(stxValues[i])

                Case gb.Float
                    RetValue = CFloat(stxValues[i])
                Case gb.Single
                    RetValue = CSingle(stxValues[i])

                Case gb.String
                    RetValue = stxValues[i]

            End Select

            Return i + 1
        Else If CInt(stxClaves[i]) = iEscapeCode Then
            Select Case TypeOf(RetValue)
                Case gb.Integer
                    RetValue = 0

                Case gb.Float
                    RetValue = 0
                Case gb.Single
                    RetValue = 0

                Case gb.String
                    RetValue = ""

            End Select

            Return -i
            ' Else If iEscapeCode = -1 Then
            '     Select Case TypeOf(RetValue)
            '         Case gb.Integer
            '             RetValue = 0
            '
            '         Case gb.Float
            '             RetValue = 0
            '
            '         Case gb.String
            '             RetValue = ""
            '
            '     End Select
            '
            '     Return -i

        Endif
    Next
    Return 0

End

'' Lee el codigo de la coleccion que se importa del DXF, puede ignorar lo que esta entre llaves {} que es info de ACAD privativa y puede empezar desde el ultimo leido antes
Public Function GoToCodeFromCol(cDxfEntityData As Collection, iCode As Integer, sValue As String) As Integer

    Dim s, sKey As String, i, p As Integer, valid, OpenedSection As Boolean

    For Each s In cDxfEntityData
        Inc i

        If s = sValue Then
            LastCodeReadIndex = i
            Return i
        End If
    Next
    Return 0

End

'' Lee el codigo de la coleccion que se importa del DXF, puede ignorar lo que esta entre llaves {} que es info de ACAD privativa y puede empezar desde el ultimo leido antes
Public Function ReadCodeFromCol(cDxfEntityData As Collection, iCode As Integer, Optional ReadNext As Boolean = False, IgnoreAcadData As Boolean = True, vDefaultValue As Variant = "") As String

    Dim s, sKey As String, i, p As Integer, valid, OpenedSection As Boolean

    For Each s In cDxfEntityData
        Inc i

        If ReadNext Then
            If i < LastCodeReadIndex Then
                valid = False
            Else
                valid = True
            Endif
        Else
            valid = True

        End If

        If Left(s, 1) = "{" Then
            OpenedSection = True

        End If

        If Left(s, 1) = "}" And OpenedSection Then
            OpenedSection = False

        End If

        If valid And Not OpenedSection Then
            sKey = cDxfEntityData.Key
            ' elimino el posible _
            p = InStr(sKey, "_")
            If p > 0 Then
                sKey = Left(sKey, p - 1)
            Endif
            If CInt(skey) = iCode Then
                LastCodeReadIndex = i
                Return s
            End If
        End If

    Next

    Return CStr(vDefaultValue)

End

Private Sub SaveCode(sCode As String, sValue As String)

    Dim sToPrint As String

    Print #hFIle, Format(sCode, "###0")
    ' If IsFloat(sValue) Then
    '   sToPrint = CStr(svalue)
    ' Else
    '   sToPrint = svalue
    ' Endif
    Print #hFIle, svalue

End Sub

Public Sub SaveCodeInv(sValue As String, sCode As String)

    SaveCode(scode, svalue)

End

Private Sub SaveColection(cData As Collection)

    Dim sValues, lpclave As String, i As Integer

    For Each sValues In cData
        lpclave = cData.Key
        I = InStr(lpclave, "_")
        If i > 0 Then lpclave = Left(lpclave, i - 1)
        SaveCode(lpclave, sValues)
    Next

End Sub

' '' Adds a new object to object by handle collection
' Private Sub NewObject(drw As Drawing, oNew As Variant, sHandle As String)
'
'     If sHandle = "" Then Return
'
'     If drw.Handles.Exist(sHandle) Then
'         gcd.debugInfo("WARNING: Handle repedida " & sHandle)
'     Else
'
'         drw.handles.Add(oNew, sHandle)
'     End If
'
' End

'' Reads layers collection and puts data in oLayers
Public Sub ReadViewports(cVptData As Collection, drw As Drawing)

    Dim vNew As Viewport

    ' ' primero eliminamos lo q haya
    If Not cVptData["TABLES"].Exist("VPORT") Then Return
    Drw.Viewports.Clear
    For Each cViewp As Collection In cVptData["TABLES"]["VPORT"]
        vNew = New Viewport
        ' hLay.Name = cLay[dxf.codName]
        ' hLay.Visible = CInt(cLay[dxf.codColor]) >= 0
        ' hLay.Colour = Abs(CInt(cLay[dxf.codColor]))
        ' hLay.handle = cLay[dxf.codHandle]
        ' If hLay.handle = "" Then hLay.handle = gcd.NewHandle()()
        ' Drw.oLayers.Add(hLay, hLay.handle)
    Next

    ' ' es inaceptable no tener al menos un layrr
    ' If drw.oLayers.Count = 0 Then
    '     hLay = New Layer
    '     hLay.Name = "0"
    '     hLay.Visible = True
    '     hLay.Colour = 0
    '     hLay.handle = gcd.NewHandle()()
    '     Drw.oLayers.Add(hLay, hLay.handle)
    ' Endif
    '
    ' ' aprovecho para setear el layer actual
    ' Drw.CurrLayer = Drw.oLayers[Drw.oLayers.First]

End

'' Reads layers collection and puts data in oLayers
Public Sub ReadLayers(cLaydata As Collection, drw As Drawing)

    Dim hLay As Layer

    ' ' primero eliminamos lo q haya
    Drw.Layers.Clear
    For Each cLay As Collection In cLayData["TABLES"]["LAYER"]
        hLay = New Layer
        hLay.Name = cLay[dxf.codName]
        hLay.id = cLay[dxf.codid]
        hLay.Visible = CInt(cLay[dxf.codColor]) >= 0
        hLay.Colour = Abs(CInt(cLay[dxf.codColor]))
        hLay.LineType = drw.LineTypes[cLay[Me.codLType]]

        Try hLay.LineWt = cLay["370"]       ' algunos dxf no traen esta info
        If hLay.LineWt = 0 Then hLay.LineWt = 1

        If hLay.id = "" Then hLay.id = gcd.NewId()
        Drw.Layers.Add(hLay, hLay.Name)
    Next

    ' es inaceptable no tener al menos un layrr
    If drw.Layers.Count = 0 Then
        hLay = New Layer
        hLay.Name = "0"
        hLay.Visible = True
        hLay.Colour = 0
        hLay.LineType = drw.LineTypes[drw.LineTypes.First]
        hLay.id = gcd.NewId()
        Drw.Layers.Add(hLay, hLay.Name)
    Endif

    ' aprovecho para setear el layer actual
    Drw.CurrLayer = Drw.Layers[Drw.Layers.First]

    ' o mejor este, pero puede fallar
    Try drw.CurrLayer = drw.Layers[drw.Headers.CLAYER]

End

'' Reads Styles and DimStyles collection and puts data in arrStyles
Public Sub ReadStyles(cData As Collection, drw As Drawing)

    Dim hlty As TextStyle
    Dim t, i As Integer
    Dim fTrameLength As Float
    Dim sH2, sNextKey As String
    Dim RefStyle As TextStyle
    Dim hdim As DimStyle
    Dim n As String

    ' primero eliminamos lo q haya
    Drw.TextStyles.Clear
    ' Leo los styles de texto
    If cData["TABLES"].Exist("STYLE") Then
        For Each c As Collection In cData["TABLES"]["STYLE"]
            hlty = New TextStyle

            hlty.Name = Lower(c[dxf.codName])
            hlty.Id = c[dxf.codid]
            If hLty.id = "" Then hLty.id = gcd.NewId()
            hlty.sFont_3 = Lower(c["3"])

            hlty.FixedH_40 = CFloat(c["40"])

            ' Esto no puede usarse asi, LastHeightUsed_2 es solo un dato de historial
            ' If hlty.FixedH_40 = 0 Then hlty.FixedH_40 = CFloat(c["42"])

            If hlty.name <> "" Then
                n = Lower(hlty.name)
            Else If hlty.sFont_3 <> "" Then
                n = Utils.FileWithoutExtension(hlty.sFont_3)
            Else
                Continue
            End If

            Drw.TextStyles.Add(hlty, n)

        Next

        drw.CurrTextStyle = Drw.TextStyles[Drw.TextStyles.First]
    End If

    ' Leo lo styles de dimensiones
    If cData["TABLES"].Exist("DIMSTYLE") Then
        For Each c As Collection In cData["TABLES"]["DIMSTYLE"]
            hdim = New DimStyle

            hdim.Name = c[dxf.codName]

            If c.Exist("105") Then
                hdim.id = c["105"]
            Else
                hdim.id = gcd.NewId()
            Endif ' depre

            Try hdim.DIMSCALE = CFloat(c["40"])
            If hdim.DIMSCALE = 0 Then hdim.DIMSCALE = 1

            Try hdim.DIMASZ = CFloat(c["41"])
            If hdim.DIMASZ = 0 Then hdim.DIMASZ = 1

            Try hdim.DIMTXT = CFloat(c["140"])
            If hdim.DIMTXT = 0 Then hdim.DIMTXT = 1

            Try hdim.DIMTXSTY = Lower(c["340"])

            Try hdim.DIMBLK = cData["TABLES"]["BLOCK_RECORD"][c["341"]]["2"]
            If hdim.DIMBLK = "" Then hdim.DIMBLK = "_" & gcd.Drawing.Headers.DIMBLK
            Try hdim.DIMBLK1 = cData["TABLES"]["BLOCK_RECORD"][c["343"]]["2"]
            If hdim.DIMBLK1 = "" Then hdim.DIMBLK1 = "_" & gcd.Drawing.Headers.DIMBLK1
            Try hdim.DIMBLK2 = cData["TABLES"]["BLOCK_RECORD"][c["344"]]["2"]
            If hdim.DIMBLK2 = "" Then hdim.DIMBLK2 = "_" & gcd.Drawing.Headers.DIMBLK2

            If hdim.DIMTXSTY <> "" Then
                RefStyle = gcd.FindStyleByid(hdim.DIMTXSTY)
                If Not IsNull(RefStyle) Then
                    If RefStyle.FixedH_40 > 0 Then hdim.DIMTXT = RefStyle.FixedH_40
                    hdim.DIMTXSTY = RefStyle.sFont_3
                Endif
            Endif

            If hdim.name <> "" Then Drw.DimStyles.Add(hdim, hdim.name)

        Next

        drw.CurrDimStyle = Drw.DimStyles[Drw.DimStyles.First]
    End If

End

'' Reads LineTypes collection and puts data in arrLTypes
Public Sub ReadLTypes(cData As Collection, drw As Drawing)

    Dim hlty As LineType
    Dim t, i, ri As Integer
    Dim fTrameLength As Float
    Dim sNextKey, r As String
    Dim AbsoluteRotation, IsText, IsShape As Boolean

    ' primero eliminamos lo q haya
    Drw.LineTypes.Clear
    For Each c As Collection In cData["TABLES"]["LTYPE"]
        hlty = New LineType
        hlty.Name = c[dxf.codName]
        hlty.Description = c["3"]
        If c.Exist("5") Then hlty.id = c["5"]
        If hLty.id = "" Then hLty.id = gcd.NewId()
        Try hlty.nTrames = CInt(c["73"])
        If hlty.nTrames > 0 Then hlty.Length = CFloat(dxf.ReadCodeFromCol(c, 40))
        i = 0
        For t = 1 To hlty.nTrames

            r = dxf.ReadCodeFromCol(c, 49, True)
            hlty.TrameLength.Add(CFloat(r))
            ri = CInt(dxf.ReadCodeFromCol(c, 74, True,, 0))
            hlty.TrameType.Add(ri)
            Select Case ri
                Case 0
                    ' nada
                Case Else
                    If (ri And 1) = 1 Then AbsoluteRotation = True Else absoluterotation = False
                    If (ri And 2) = 2 Then IsText = True Else IsText = False
                    If (ri And 4) = 4 Then IsShape = True Else IsShape = False
                    hlty.TrameData.Add(dxf.ReadCodeFromCol(c, 75, True))
                    hlty.TrameStyle.Add(dxf.ReadCodeFromCol(c, 340, True))
                    hlty.TrameScale.Add(dxf.ReadCodeFromCol(c, 46, True))
                    hlty.TrameRotation.Add(dxf.ReadCodeFromCol(c, 50, True))
                    hlty.TrameOffX.Add(dxf.ReadCodeFromCol(c, 44, True))
                    hlty.TrameStyle.Add(dxf.ReadCodeFromCol(c, 45, True))
                    hlty.TrameData.Add(dxf.ReadCodeFromCol(c, 9, True))

            End Select

        Next

        Drw.LineTypes.Add(hlty, hlty.Name)

    Next
    If DRW.LineTypes.Count = 0 Then
        hlty = New LineType
        hlty.Name = "CONTINUOUS"
        hlty.Description = ""
        hlty.id = gcd.Newid()
        hlty.nTrames = 0
        drw.LineTypes.Add(hlty, hlty.Name)

    End If

    Drw.CurrLineType = Drw.LineTypes[Drw.LineTypes.First]

End

Public Sub ImportBlocksFromDXF(colData As Collection, drw As Drawing) ', obxEntities As Entity[]) As Integer

    Dim iTotalEntities As Integer, colent, colBlk As Collection, flxPoints As New Float[], P As Float[]
    Dim hBlock As String
    Dim cParent As Collection, cEntyList As New Collection
    Dim hEnty As Variant, iEnty As Integer
    Dim cEnty As Variant[]
    Dim i As Integer
    Dim S As New Sheet
    Dim newBlock As Block
    Dim hasBlocks, hasTables, hasBlockRecord, hasEntities As Boolean
    Dim cBlocks, cTables, cBlockRecord, cEntities As Collection
    Dim b As New Block

    If colData.Exist("BLOCKS") Then cBlocks = colData["BLOCKS"]
    If colData.Exist("TABLES") Then
        cTables = colData["TABLES"]
        If colData["TABLES"].Exist("BLOCK_RECORD") Then cBlockRecord = cTables["BLOCK_RECORD"]
    End If
    If Not cBlocks Then Return
    ' For Each colBlk In colData["TABLES"]["BLOCK_RECORD"]
    '     Dim newBlock As New Block
    '     newBlock.entities = New Collection
    '     newBlock.name = colBlk[dxf.codName]
    '     newBlock.handle = colBlk[dxf.codHandle]
    '     newBlock.HandleOwnerParent = colBlk[dxf.codHandleOwner]
    '     newBlock.HandleAsociatedLayout = colBlk["340"]
    '     Try newBlock.InsertUnits = colBlk["70"]
    '     Try newBlock.Explotability = colBlk["280"]
    '     Try newBlock.Scalability = colBlk["281"]
    '     drw.oBlocks.Add(newBlock, newBlock.handle)
    '
    ' Next
    ' hay DXF sin TAbles
    If cTables Then

        For Each colBlk In cBlocks
            newBlock = New Block
            newBlock.id = colBlk[dxf.codid]
            newBlock.entities = New Collection
            newBlock.name = colBlk[dxf.codName]
            newBlock.layer = colBlk[dxf.codLayer]
            Try newBlock.x0 = colBlk[dxf.codX0]
            Try newBlock.y0 = colBlk[dxf.codY0]
            Try newBlock.z0 = colBlk[dxf.codZ0]
            Try newBlock.flags = colBlk["70"]

            If cBlockRecord Then
                If cBlockRecord.Exist(colBlk["330"]) Then
                    newBlock.idContainer = cBlockRecord[colBlk["330"]]["5"]
                    newBlock.idAsociatedLayout = cBlockRecord[colBlk["330"]]["340"]
                    ' If newBlock.idAsociatedLayout <> "0" Then
                    '     hContainers.Add(newBlock, newBlock.idAsociatedLayout)
                    ' Else
                    hContainers.Add(newBlock, newBlock.idContainer)
                    ' End If
                End If
            End If
            'If Left(newBlock.name, 1) = "*" Then    ' puede ser una Dim o una Sheet
            ' If InStr(newBlock.name, "_Space") > 0 Then
            '     ' es una sheet, que ya fue creada por ReadObjectsFromDXF
            ' Else

            Drw.Blocks.Add(newBlock, newBlock.name)

            'Endif

            'Endif

        Next
    End If
    If (Drw.Blocks.Count = 0) Or Not Drw.Blocks.Exist("*Model_Space") Then ' agrego el Model

        ' lo agrego a los bloques

        b.name = "*Model_Space"
        b.entities = New Collection
        b.idContainer = gcd.NewId()
        b.id = gcd.NewId()
        b.idAsociatedLayout = gcd.NewId()
        b.IsAuxiliar = True
        b.IsReciclable = False
        Drw.Blocks.Add(b, b.name)
    End If

    ' voy a hacer un chequeo final, porque algunos DXF vienen sin el bloque Model
    If Not Drw.Sheets.Exist("Model") Then
        ' creo la Sheet
        S = New Sheet
        s.Name = "Model"
        s.IsModel = True
        s.Block = Drw.Blocks["*Model_Space"]
        s.id = Drw.Blocks["*Model_Space"].idAsociatedLayout
        Drw.Sheets.Add(s, "Model")
        drw.Sheet = s
        drw.Model = s

    End If

    ' ' ahora vinculo las Sheets con su bloque
    For Each s In Drw.Sheets
        For Each b In drw.Blocks
            If b.idAsociatedLayout = s.id Then
                s.Block = b
                s.Entities = b.entities
                b.Sheet = s
                Break
            Endif
        Next
    Next

    For Each colBlk In cBlocks

        If colBlk.Exist("entities") Then

            DXFtoEntity(colBlk["entities"], drw, drw.Blocks[colBlk["2"]])

        End If
        Inc i

    Next

End

Public Sub SetViewports(cDxfData As Collection, drw As Drawing)

    Dim e As Entity, v As Viewport, n, hLayout As String, s As Sheet, b As Block

    For Each b In drw.Blocks
        If drw.Sheets.Exist(b.idAsociatedLayout) Then
            For Each e In b.entities
                drw.Sheets[b.idAsociatedLayout].entities.Add(e, e.id)
                ' Try n = cDxfData["BLOCKS"][b.name]["2"]                      ' nombre del bloque
                ' Try hLayout = cDxfData["TABLES"]["BLOCK_RECORD"][n]["340"]
                ' If hLayout <> "" Then
                '     s.Entities = b.entities
                '
                '
            Next
        End If

    Next
    For Each s In drw.Sheets
        For Each e In s.entities
            If e.Gender = cadViewport.Gender Then
                s.Viewports.Add(e.pBlock, e.id)
                'cadViewport.SetViewport(e, s)
            Endif
        Next
        'gcd.Drawing.Sheet = s
        'cadZoomE.Start()
    Next

    'Next

End

'' Importa las cosas de manera descentralizada
Public Sub DXFtoEntity(cDxfEntities As Collection, drw As Drawing, Optional bContainer As Block)

    Dim e, obx, cLastParent As Collection
    Dim entNueva As Entity
    Dim flgIsPolyline, IsDummy, EntitiesToModel As Boolean
    Dim pBlockPolyline, b As Block
    Dim sid, sName, sIdLayout As String

    Dim fTime As Float
    Dim t As Date
    Dim hContainer As Variant

    For Each e In cDxfEntities                                              ' Para cada Coleccion de datos de vrx
        If e.Exist(dxf.codEntity) Then                                     ' es una entidad?
            ' entonces, creamos una nueva
            ' poner en minuscula para anular la entidad
            If InStr("VIEWPORT LEADER HATCH POLYLINE ENDBLK SEQEND VERTEX POINT ATTDEF ATTRIB LINE LWPOLYLINE CIRCLE ELLIPSE ARC TEXT MTEXT SPLINE SOLID INSERT DIMENSION DIMENSION_LINEAR DIMENSION_DIAMETEr DIMENSION_RADIUs DIMENSION_ANG3Pt DIMENSION_ALIGNED DIMENSION_ORDINATE LARGE_RADIAL_DIMENSION ARC_DIMENSION", UCase(e[dxf.codEntity])) = 0 Then IsDummy = True Else IsDummy = False

            If UCase(e[dxf.codEntity]) = "ENDBLK" Then Continue

            If IsDummy Then
                ' no esta implementada
                gcd.debuginfo("Entidad no implementada o con errores: " & e[dxf.codId] & "," & e[dxf.codEntity])

            Else

                t = Timer

                entNueva = clsEntities.DXFImportToEntity(drw, e, IsDummy)

                If IsNull(entNueva) Then Continue        ' si esta implementada, llenamos los datos
                If entNueva.Gender = cadEndBlk.Gender Then Continue

                'stats
                If Not ReadTimes.Exist(entNueva.Gender) Then ReadTimes.Add(fTime, entNueva.Gender)
                If Not ReadEntities.Exist(entNueva.Gender) Then ReadEntities.Add(1, entNueva.Gender)

                ' If NewIds Or (entNueva.Id = "") Then
                '     sId = gcd.NewId()
                '     entNueva.Id = sId
                ' Else
                '     sId = entNueva.Id
                ' End If
                'If e[dxf.codEntity] = "VERTEX" Then Stop
                'If flgIsPolyline Then
                'pBlockPolyline.entities.Add(entNueva, sId)
                'Else
                ' If cEntity Then                                         ' el contenedor fue provisto
                '     obx = cEntity
                ' Else

                ' esto puede ser un:
                'If ReadCodeFromCol(e, 5) = "129D" Then Stop
                'Debug "Contenedor", hContainer
                ' -hBlock-Record
                ' -hInsert
                ' -hHatch               OTRA ENTIDAD que tenga .pBlock.enities as Collection
                ' -Polyline

                If bContainer Then entNueva.Container = bContainer
                If entNueva.Container Then
                    obx = entNueva.Container.entities
                Else If bContainer Then
                    obx = bContainer.entities 'drw.Blocks[entNueva.IdContainer]
                    ' Else If hContainers.Exist(entNueva.idContainer) Then
                    '     obx = hContainers[entNueva.idContainer].entities
                Else
                    'If Not obx Then
                    obx = drw.Sheet.Entities
                    entNueva.Container = drw.Sheet.Block
                Endif

                ' If hContainer <> "" And cDxfData.Exist("TABLES") Then                 ' busco la hoja donde dibujar esta entidad
                '
                '     If cDxfData["TABLES"]["BLOCK_RECORD"].Exist(hContainer) Then      ' busco en los bloques
                '         sIdLayout = cDxfData["TABLES"]["BLOCK_RECORD"][hContainer]["340"]
                '         sName = Handle_Layout[sidLayout]
                '         If drw.Sheets.Exist(sName) Then                                 ' busco en las Sheets
                '             obx = drw.Sheets[sName].entities
                '         Else    ' los DXF viejos no tienen contenedores,   ni paperspace, probablemente
                '
                '             obx = drw.Sheet.entities
                '         End If
                '
                '     Else                                                               ' busco en otro lado
                '         obx = hContainers[hContainer]
                '     End If
                '
                ' End If

                'End If

                Select Case entNueva.Gender
                    Case "HATCH", "INSERT", "POLYLINE", "POLYLINE_2D"
                        If entNueva.pBlock Then
                            hContainers.Add(entNueva.pBlock, entNueva.Id)
                        End If
                End Select
                'End If

                obx.Add(entNueva, entNueva.Id)

                'gcd.debugInfo("Leida entidad tipo" & entNueva.Gender & " id " & entNueva.id,,, True)
                If e[dxf.codEntity] = "POLYLINE" Then 'Stop
                    flgIsPolyline = True
                    'obx = entNueva.pBlock
                    ' pBlockPolyline = New Block
                    ' pBlockPolyline.entities = New Collection
                    '
                    ' entNueva.pBlock = pBlockPolyline
                End If
                If (e[dxf.codEntity] = "SEQEND") And (flgIsPolyline = True) Then
                    flgIsPolyline = False
                    obx.Remove(obx.Last)
                    obx = Null

                End If

                fTime = (Timer - t)
                ReadTimes[entNueva.Gender] += fTime

                ReadEntities[entNueva.Gender] = ReadEntities[entNueva.Gender] + 1

                ' If entNueva.Gender = "HATCH" Then
                '     ReadTimes.Add(fTime, entNueva.Handle)
                ' Endif
                ' If entNueva.HandleOwner = "640" Then Debug "640", entNueva.Gender

                entNueva = Null                                           ' limpiamos

            End If
        End If
    Next

End

'' Transforma una coleccion en dos array de strings
Public Sub DigestColeccion(c As Collection, ByRef sClaves As String[], ByRef sValues As String[])

    Dim lpValue, lpclave As String
    Dim i As Integer

    sClaves.Clear
    sValues.Clear

    For Each lpValue In c
        lpclave = c.Key
        I = InStr(lpclave, "_")
        If i > 0 Then lpclave = Left(lpclave, i - 1)
        sClaves.Add(lpclave)           ' el codigo es el tipo de variable
        sValues.Add(lpValue)

    Next

End

Public Function ReadObjectsFromDXF(cData As Collection, drw As Drawing)

    Dim cObject As Collection, entNueva As Entity
    Dim sClaves, sValues As New String[]
    Dim s As Sheet

    gcd.debugInfo("Importing DXF object data",,, True)
    'Handle_Layout = New Collection
    If Not cData.Exist("OBJECTS") Then Return
    For Each cObject In cData["OBJECTS"]

        If cObject["0"] = "LAYOUT" Then

            Me.DigestColeccion(cObject, ByRef sClaves, ByRef sValues)
            s = New Sheet
            objLayout.importDXF(s, cObject)
            If s.name = "" Then s.name = s.pPrintStyle.ViewName
            If S.Name = "" Then s.name = "Sheet " & Str(drw.Sheets.Count)
            drw.Sheets.Add(s, s.name)
            'Handle_Layout.Add(s.Name, s.id)
            'hContainers.Add(s.Entities, s.id)
            If LCase(s.Name) = "model" Then
                s.IsModel = True
                drw.Sheet = s
                drw.Model = s

            End If

        Endif

    Next

End

'' busca un bloque con ese block record
Private Function GetBlock(cBlocks As Collection, hBlockRecord As String) As Block

    Dim b As Block

    For Each b In cBlocks
        If b.IdContainer = hBlockRecord Then Return b

    Next

    Return Null

End

'' Devuelve una nueva handle que acumula en la var publica hexHandle
Fast Private Function NewHandle(Optional iStart As Integer = "-1") As String

    If iStart < 0 Then
        Inc iHandle

    Else
        iHandle = iStart

    Endif
    Return Hex(iHandle)

End
