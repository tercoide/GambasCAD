' Gambas class file

' GambasCAD
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
Create Static
' Fast

Inherits CadmText
Public Const Gender As String = "TEXT"
Public Const DrawingOrder As Integer = 100 ' 1 a 32.724 esto debe Drawse primero y ser sobreescrito por el resto
Public Const PointsToDraw As Integer = 1             ' minimal point requered for drawing something usefull
Public Const CmdLineHelper As String = ("Inserts a text")
Public Const ParamType As String = "PAFT"
Public Const ParamHelper As String = "Start point;Angle;Heigth;"      ' a little text that is shown at the prompt waiting for user input during build
Public Const ParamDefault As String = " ; 0 ; 10 ; "

' The entity handler receives a user action, and returns the number of expected parameter
' If definitive = true, means the parameter is set
Public Function NewParameter(eBuild As Entity, vParam As Variant[], Optional Definitive As Boolean = False) As Boolean

    Dim f As Float
    Dim ip As Integer

    If gcd.StepsDone = 0 Then  '  posicion

        If vParam[0] <> "point" Then Return gcd.StepsDone

        Try eBuild.P[0] = vParam[1]
        Try eBuild.P[1] = vParam[2]

        If definitive Then

            Return True
        End If
    Else If gcd.StepsDone = 1 Then ' angulo del texto

        If vParam[0] <> "float" Then Return False

        eBuild.fParam[Me.ipaTextAngle] = vParam[1]

        If definitive Then Return True

    Else If gcd.StepsDone = 2 Then   ' altura

        If vParam[0] <> "float" Then Return False

        eBuild.fParam[Me.ipaTextHeight] = vParam[1]

        If definitive Then Return True

    Else If gcd.StepsDone = 3 Then    ' texto

        If vParam[0] <> "text" Then Return False

        eBuild.sParam[0] = vParam[1]

        If definitive Then Return True

    Else
        Return False
    End If

End

Public Sub SetMtextVars(oe As Entity)

    'If oe.StringData[Me.sdaText] = "DESTINO:" Then Stop
    cadMText.CurrentTextAngle = oE.fParam[Me.ipaTextAngle]
    cadMText.CurrentTextItalic = oE.fParam[Me.ipaHorizAngle]
    cadMText.CurrentTextHeigth = oE.fParam[Me.ipaTextHeight]
    cadMText.CurrentTextRelScaleX = oE.fParam[Me.ipaRelativeFactor]
    If cadMText.CurrentTextRelScaleX = 0 Then cadMText.CurrentTextRelScaleX = 1
    cadMText.CurrentTextColor = gcd.GetGBColor(oE.Colour, oe.pLayer)
    cadMText.TrimText = False
    If cadMText.CurrentTextHeigth = 0 Then cadMText.CurrentTextHeigth = 1

    cadMText.OriginalTextPosX = oE.p[0]    ' nada que corregir
    cadMText.OriginalTextPosY = oE.p[1]
    cadMText.CurrentTextOverline = False
    cadMText.CurrentTextUnderline = False
    cadMText.CurrentTextCrossed = False

    oe.pStyle = gcd.Drawing.TextStyles[oE.sParam[Me.sdaStyle]]
    If Not oe.pStyle Then oe.pStyle = gcd.Drawing.TextStyles[gcd.Drawing.TextStyles.First]

    cadMText.CurrentTextFont = Utils.FileWithoutExtension(oe.pStyle.sFont_3)

    If gcd.FontReplacements.Exist(cadMText.CurrentTextFont) Then
        cadMText.CurrentTextFont = gcd.FontReplacements[cadMText.CurrentTextFont]
    Else
        cadMText.CurrentTextFont = "romand"
    Endif

    If oe.P.Count = 2 Then          ' hay solo un punto, la alineacion es Baseline/Left

        cadMText.CurrentTextAlignmentVertical = 2
        cadMText.CurrentTextAlignment = 0

    Else    ' tengo dos puntos

        ' veo la alineacion vertical
        If oe.fParam[Me.ipaVertJustif] = 0 Then       'es Baseline/Bottom que es casi lo mismo

            cadMText.CurrentTextAlignmentVertical = 2

        Else If oe.fParam[Me.ipaVertJustif] = 1 Then   'Center

            cadMText.CurrentTextAlignmentVertical = 1

        Else                                            'top
            cadMText.CurrentTextAlignmentVertical = 0
        End If

        ' veo la alineacion horizontal
        If oe.fParam[Me.ipaHorizJustif] < 0 Then       'es Left

            cadMText.CurrentTextAlignment = 0
            cadMText.CurrentTextAlignmentVertical = 2

        Else If oe.fParam[Me.ipaHorizJustif] = 0 Then       'es Left

            cadMText.CurrentTextAlignment = 0

        Else If oe.fParam[Me.ipaHorizJustif] = 1 Then   'Center
            cadMText.CurrentTextAlignment = 1
            cadMText.CurrentTextBoxWIdth = (oe.P[2] - oe.P[0])
            cadMText.OriginalTextPosX = oE.p[0] + (oe.P[2] - oe.P[0]) / 2

        Else If oe.fParam[Me.ipaHorizJustif] = 2 Then   'Right
            cadMText.CurrentTextAlignment = 2
        Else If oe.fParam[Me.ipaHorizJustif] = 3 Then   'Aligned , pero no se que es:  me parece que texto confinado al espacio asignado
            cadMText.CurrentTextAlignment = 1
            cadMText.CurrentTextBoxWIdth = 0
            cadMText.OriginalTextPosX = oE.p[0] + (oe.P[2] - oe.P[0]) / 2

        Else If oe.fParam[Me.ipaHorizJustif] = 4 Then   ' Middle, se calcula en base al segunto punto.
            cadMText.CurrentTextAlignment = 1
            cadMText.CurrentTextAlignmentVertical = 1
            cadMText.CurrentTextBoxWIdth = 0
            cadMText.OriginalTextPosX = oE.P[2]    ' nada que corregir
            cadMText.OriginalTextPosY = oE.p[3]
            'cadMText.CurrentTextPosX = oE.p[0] + (oe.P[2] - oe.P[0]) / 2

        Else If oe.fParam[Me.ipaHorizJustif] = 5 Then   ' Fit, pero no tengo esta capability en glx.DrawTExt
            cadMText.CurrentTextAlignment = 0
            cadMText.OriginalTextPosX = oE.p[0] '+ (oe.P[2] - oe.P[0]) / 2
            cadMText.CurrentTextBoxWIdth = oe.P[2] - oe.P[0]            ' FIXME: activar el box fit
            cadMText.TrimText = True
        End If
    End If

End

Public Function SaveDxfData(e As Entity) As Boolean

    ' stxExport.insert(["TEXT", dxf.codEntity])
    ' Los datos comunes a todas las entidades son guardados por la rutina que llama a esta
    dxf.SaveCodeInv("AcDbText", "100")

    dxf.SaveCodeInv(CStr(e.p[0]), dxf.codX0)                    ' insertion point
    dxf.SaveCodeInv(CStr(e.p[1]), dxf.codY0)
    dxf.SaveCodeInv("0", dxf.codZ0)

    dxf.SaveCodeInv(CStr(e.fParam[Me.ipaTextHeight]), "40")      ' heigth
    dxf.SaveCodeInv(e.sParam[Me.sdaText], "1")             ' Text
    dxf.SaveCodeInv(CStr(e.fParam[Me.ipaTextAngle]), "50")       ' rotation

    dxf.SaveCodeInv("1", "41")
    dxf.SaveCodeInv("0", "51")
    dxf.SaveCodeInv(e.sParam[Me.sdaStyle], "7")             ' text style
    dxf.SaveCodeInv(e.fParam[Me.ipaGenerationFlags], "71")      ' generation flags
    dxf.SaveCodeInv(e.fParam[Me.ipaHorizJustif], "72")          ' horiz justiff

    If e.P.Count = 4 Then   ' some DXF come with z, some with
        dxf.SaveCodeInv(CStr(e.p[2]), dxf.codX1)                    ' second point
        dxf.SaveCodeInv(CStr(e.p[3]), dxf.codY1)
        dxf.SaveCodeInv("0", dxf.codZ1)
    End If
    dxf.SaveCodeInv("0", "210")                                 ' extrusion direction
    dxf.SaveCodeInv("0", "220")
    dxf.SaveCodeInv("1", "230")

    dxf.SaveCodeInv("AcDbText", "100")

    dxf.SaveCodeInv(e.fParam[Me.ipaVertJustif], "73")

End

Public Function ImportDXF(e As Entity, sClaves As String[], sValues As String[]) As Boolean

    Dim i As Integer
    'If e.id = "A9B" Then Stop
    e.fParam[Me.ipaHorizJustif] = -1
    For i = 0 To sClaves.Max

        If sClaves[i] = "10" Then e.p[0] = (CFloat(sValues[i]))         ' X0
        If sClaves[i] = "20" Then e.P[1] = (CFloat(sValues[i]))         ' Y0

        ' el segundo punto es alternativo
        If sClaves[i] = "11" Then e.p.Add((CFloat(sValues[i])))         ' X1
        If sClaves[i] = "21" Then e.P.Add((CFloat(sValues[i])))         ' Y1

        If sClaves[i] = "40" Then e.fParam[Me.ipaTextHeight] = CFloat(sValues[i])         ' Altura
        If sClaves[i] = "1" Then e.sParam[Me.sdaText] &= sValues[i]                ' Texto
        ' Importante , el TEXT no tiene code 3 para mas texto

        If sClaves[i] = "50" Then e.fParam[Me.ipaTextAngle] = CFloat(sValues[i])      ' rotacion
        If sClaves[i] = "7" Then e.sParam[Me.sdaStyle] = sValues[i]                ' texy
        If sClaves[i] = "41" Then e.fParam[Me.ipaRelativeFactor] = CFloat(sValues[i])
        If sClaves[i] = "51" Then e.fParam[Me.ipaHorizAngle] = CFloat(sValues[i])
        If sClaves[i] = "71" Then e.fParam[Me.ipaGenerationFlags] = CInt(sValues[i])
        If sClaves[i] = "72" Then e.fParam[Me.ipaHorizJustif] = CFloat(sValues[i])
        If sClaves[i] = "73" Then e.fParam[Me.ipaVertJustif] = CFloat(sValues[i])
    Next

    e.sParam[Me.sdaStyle] = Lower(e.sParam[Me.sdaStyle])
    If e.sParam[Me.sdaStyle] = "" Then e.sParam[Me.sdaStyle] = "standard"

    Return True

    ' catch

    Return False

End

' Group 72 and 73 integer codes
'
' Group 73/72         0     1       2       3       4     5
' 3 (top)          TLeft TCenter TRight
' 2 (middle)       MLeft MCenter MRight
' 1 (bottom)       BLeft BCenter BRight
' 0 (baseline)     Left  Center  Right  Aligned  Middle Fit

' '' Return if that position is over the entity within the tolerance
' fast Public Function OverMe(e As Entity, Xr As Float, Yr As Float, tolerance As Float) As Boolean
'
'     Return False
'
' End

'' Builds the geometry of the entity wthout drwing it
Public Function BuildGeometry(oE As Entity, Optional density As Float)

    SetMtextVars(oe)
    cadMText.ProcessText3(oE)
    Me.Limits(oe)

End
