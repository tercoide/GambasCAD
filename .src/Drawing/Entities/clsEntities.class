' Gambas class file

' GambasCAD
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA

Create Static

Public inxBuffersID As New Integer[]

Public Sub GenGrips(e As Entity)

    gcd.CCC[e.Gender].generategrips(e)

End

'' Changes the properties of the seleccted entities with given values
Public Function EditEntities(sProperty As String, vValue As Variant, Optional DoRegen As Boolean = True, cEntities As Collection = gcd.Drawing.Sheet.EntitiesSelected) As Boolean

    Dim e As Entity

    gcd.Drawing.uUndo.OpenUndoStage(sProperty, Undo.TypeModify)

    For Each e In cEntities
        gcd.Drawing.uUndo.AddUndoItem(e)
        Select Case sProperty

            Case "color"
                e.colour = vValue

            Case "linewidth"

                e.LineWidth = vValue
            Case "layer"

                e.pLayer = gcd.GetLayer(vValue)

            Case "linetype"
                e.LineType = vValue

            Case "points"
                e.p = vValue

        End Select
    Next

    gcd.Drawing.uUndo.CloseUndoStage()
    clsEntities.CollectVisibleEntities()
    If DoRegen Then gcd.Regen()

End

Public Sub DrawArrays()

    Dim iError, vOffset, nOffset, cOffset, tOffset As Integer

    If inxBuffersID.Count = 0 Then Return

    glx.glBindBuffer(glx.ARRAY_BUFFER, inxBuffersID[0])

    iError = glx.glGetError()
    If iError <> 0 Then gcd.debuginfo("GL Error: " & iError)
    glx.glEnableClientState(glx.VERTEX_ARRAY)
    glx.glEnableClientState(glx.NORMAL_ARRAY)
    glx.glEnableClientState(glx.COLOR_ARRAY)

    iError = glx.glGetError()
    If iError <> 0 Then gcd.debuginfo("GL Error: " & iError)

    vOffset = 0
    nOffset = glx.VBO_vertex.Count * SizeOf(gb.Single)
    cOffset = nOffset + glx.VBO_normals.Count * SizeOf(glx.VBO_normals.Type)
    'tOffset = cOffset + sizeof colors

    glx.glVertexPointer(3, glx.FLOAT, 0, vOffset)
    glx.glNormalPointer(glx.FLOAT, 0, nOffset)
    glx.glColorPointer(3, glx.FLOAT, 0, cOffset)

    iError = glx.glGetError()
    If iError <> 0 Then gcd.debuginfo("GL Error: " & iError)

    glx.glDrawArrays(glx.DrawLines, 0, glx.VBO_vertex.Count * 3)

    glx.gldisableClientState(glx.VERTEX_ARRAY)
    glx.gldisableClientState(glx.NORMAL_ARRAY)
    glx.gldisableClientState(glx.COLOR_ARRAY)

    glx.glBindBuffer(glx.ARRAY_BUFFER, 0)

End

Public Function FIndBlockIDbyid(Blockid As String) As Block

    Dim B As Block

    For Each B In gcd.Drawing.Blocks
        If B.id = Blockid Then Return B
    Next
    Return Null

End

Public Function FIndBlock(BlockName As String, cContainer As Collection) As Block

    Dim b As Block

    For Each b In cContainer
        If b.name = BlockName Then Return b
    Next
    Return Null

End

Public Function FindStyle(sName As String) As Style

    Dim b As Style

    For Each b In gcd.Drawing.oStyles
        If b.name = sName Then Return b
    Next
    Return

End

' Public Sub setEntity(e As Entity)
'
'     Try e.iParam.Resize(gcd.CCC[e.gender].iTotalParams)
'     Try e.fParam.Resize(gcd.CCC[e.gender].fTotalParams)
'     Try e.StringData.Resize(gcd.CCC[e.gender].sdaTotalParams) ' text, style
'     Try e.P.Resize(gcd.CCC[e.gender].TotalPoints * 2)
'
' End

Public Function ReconstruirBloques() As Boolean

    ' busco bloques y coloco puntos de referencias
    ' Armamos los bolques, que extraemos de las entidades
    Dim i, i2 As Integer, PartesEncontradas As Boolean, iStart As Integer
    Dim t As Float = Timer

    gcd.debuginfo("Recostruyendo bloques")

    For i = 0 To gcd.Drawing.Sheet.Entities
        Me.prompt = ("Loading blocks ") & Format$(i / gcd.Drawing.Sheet.Entities, "0.00%")
        Wait 0.0001
        If gcd.Drawing.Sheet.Entities[i].gender = "BLOCK" Then
            Dim newBlock As New Block
            newBlock.name = gcd.Drawing.Sheet.Entities[i].block
            newBlock.x = gcd.Drawing.Sheet.Entities[i].p[0]
            newBlock.y = gcd.Drawing.Sheet.Entities[i].p[1]
            newBlock.entities = New Collection
            ' busco los objetos de este bloque y los reconstruyo
            For i2 = iStart To gcd.Drawing.Sheet.Entities
                If gcd.Drawing.Sheet.Entities[i2].block = newBlock.name And gcd.Drawing.Sheet.Entities[i2].gender <> "BLOCK" Then ' sin recursividad en bloques
                    If gcd.Drawing.Sheet.Entities[i2].block = newBlock.name And gcd.Drawing.Sheet.Entities[i2].gender <> "INSERT" Then 'no quiero insertarme a mi mismo
                        PartesEncontradas = True
                        Dim o2 As Entity
                        o2 = ClonEntity(gcd.Drawing.Sheet.Entities[i2])

                        Gcd.CCC[o2.gender].finish(o2)
                        newBlock.entities.Add(o2)
                    End If
                Else
                    If PartesEncontradas Then ' estaba armando un bloque, pero ya termine porque esta entidad es otra cosa
                        PartesEncontradas = False
                        iStart = i2
                        Break
                    End If

                Endif
            Next
            gcd.Drawing.arrBlocks.Add(newBlock)
        End If
    Next

    Wait 0.001
    Debug "Reconstruccion finalizada en ", Str$(Timer - t)

End

'' Genera las listas GL de cada entidad individual, y la version seleccionada
'' Borra la lista anterior y genera una nueva
Public Sub glGenBuffers(Optional eEntity As Entity = Null)

    Dim idDrawing As Integer ' la instancia de dibujo en la que estamos
    Dim i, iVbo As Integer, e As Entity

    If eEntity Then

        ' If Not gl.islist(eEntity.glDrwList) Then eEntity.glDrwList = gl.GenLists(1)
        ' gl.NewList(eEntity.glDrwList, gl.COMPILE)
        ' eEntity.Gcd.CCC[e.gender].Draw(eEntity)
        ' gl.EndList
        '
        ' If Not gl.islist(eEntity.glDrwListSel) Then eEntity.glDrwListSel = gl.GenLists(1)
        ' gl.NewList(eEntity.glDrwListSel, gl.COMPILE)
        ' eEntity.Gcd.CCC[e.gender].DrawSelected(eEntity)
        ' gl.EndList

    Else

        ' If Not gl.islist(gcd.CurrDrawing.GlListAllEntities) Then gcd.CurrDrawing.GlListAllEntities = gl.GenLists(1)
        Dim t As Float = Timer
        Dim iError As Integer
        ' listas de entidades
        glx.VBOFlush
        'glx.InmediateMode = False

        If gcd.Drawing.Sheet.Entities.Count = 0 Then Return
        For Each e In gcd.Drawing.Sheet.Entities

            'If Not gl.islist(e.glDrwList) Then e.glDrwList = gl.GenLists(1)
            'gl.NewList(e.glDrwList, gl.COMPILE)
            gcd.CCC[e.gender].Draw(e)
            'gl.EndList

        Next
        glx.InmediateMode = True

        Dim oneBufferID As Integer
        inxBuffersID.Resize(3)

        iError = glx.glGetError()
        If iError <> 0 Then Print "GL Error:", Hex(iError)

        'glx.glGenBuffers(1, VarPtr(oneBufferID))
        glx.glGenBuffers(3, inxBuffersID.Data)                      ' genero un buffer ID
        iError = glx.glGetError()
        If iError <> 0 Then Print "GL Error:", Hex(iError)
        glx.glBindBuffer(glx.ARRAY_BUFFER, inxBuffersID[0])      ' lo conecto como Vertex Buffer
        iError = glx.glGetError()
        If iError <> 0 Then Print "GL Error:", Hex(iError)
        Dim BytesTotales As Integer
        BytesTotales = glx.VBO_vertex.Count + glx.VBO_normals.Count + glx.VBO_colors.Count
        BytesTotales *= SizeOf(gb.Single)

        ' Reservo espacio. 0 significa que despues le mando la data
        glx.glBufferData(glx.ARRAY_BUFFER, BytesTotales, 0, glx.STATIC_DRAW)
        iError = glx.glGetError()
        If iError <> 0 Then Print "GL Error:", Hex(iError)
        ' mando vertices
        glx.glBufferSubData(glx.ARRAY_BUFFER, 0, glx.VBO_vertex.Count * SizeOf(gb.Single), glx.VBO_vertex.Data)

        ' mando normales
        glx.glBufferSubData(glx.ARRAY_BUFFER, glx.VBO_vertex.Count * SizeOf(gb.Single), glx.VBO_normals.Count * SizeOf(gb.Single), glx.VBO_normals.Data)

        ' mando colores
        glx.glBufferSubData(glx.ARRAY_BUFFER, (glx.VBO_vertex.Count + glx.VBO_normals.Count) * SizeOf(gb.Single), glx.VBO_colors.Count * SizeOf(gb.Single), glx.VBO_colors.Data)
        iError = glx.glGetError()
        If iError <> 0 Then Print "GL Error:", Hex(iError)
        glx.glBindBuffer(glx.ARRAY_BUFFER, 0)      ' finlizo transferencia de datos a la GPU

        ' ' lista de entidaes seleccionadas
        ' For Each e In gcd.Drawing.oEntities
        '     If Not gl.islist(e.glDrwListSel) Then e.glDrwListSel = gl.GenLists(1)
        '     gl.NewList(e.glDrwListSel, gl.COMPILE)
        '     gcd.CCC[e.gender].DrawSelected(e)
        '     gl.EndList
        ' Next
        '
        ' ' lista de todas las entidades
        ' t = Timer
        ' glGenDrawListLAyers
        '
        ' Debug "GLlista de todas generada en  ", Timer - t
    End If

End

'' Genera las listas GL de cada entidad individual, y la version seleccionada
'' Borra la lista anterior y genera una nueva
Public Sub glGenDrawList(Optional eEntity As Entity = Null)

    Dim idDrawing As Integer ' la instancia de dibujo en la que estamos
    Dim i As Integer, e As Entity, b As Block, s As Sheet

    If eEntity Then
        If Not eEntity Then Return

        gcd.CCC[eEntity.gender].Translate(eEntity, -gcd.Drawing.Sheet.PanBaseRealX, -gcd.Drawing.Sheet.PanBaseRealY)

        If Not gl.islist(eEntity.glDrwList) Then eEntity.glDrwList = gl.GenLists(1)
        gl.NewList(eEntity.glDrwList, gl.COMPILE)
        Gcd.CCC[eEntity.gender].Draw(eEntity)
        gl.EndList

        If Not gl.islist(eEntity.glDrwListSel) Then eEntity.glDrwListSel = gl.GenLists(1)
        gl.NewList(eEntity.glDrwListSel, gl.COMPILE)
        Gcd.CCC[eEntity.gender].DrawSelected(eEntity)
        gl.EndList

        If Not gl.islist(eEntity.glDrwListRemark) Then eEntity.glDrwListRemark = gl.GenLists(1)
        gl.NewList(eEntity.glDrwListRemark, gl.COMPILE)
        Gcd.CCC[eEntity.gender].DrawRemark(eEntity)
        gl.EndList

        gcd.CCC[eEntity.gender].Translate(eEntity, gcd.Drawing.Sheet.PanBaseRealX, gcd.Drawing.Sheet.PanBaseRealY)

    Else

        ' If Not gl.islist(gcd.CurrDrawing.GlListAllEntities) Then gcd.CurrDrawing.GlListAllEntities = gl.GenLists(1)
        Dim t As Float = Timer
        ' listas de entidades
        For Each s In gcd.Drawing.Sheets
            'gcd.ReEscalar(s)
            'gcd.GetZoomExtents(s)
            For Each e In s.Entities

                'If Not e.Visible Then Continue

                Translate(e, -s.PanBaseRealX, -s.PanBaseRealY)

                If Not gl.islist(e.glDrwList) Then e.glDrwList = gl.GenLists(1)

                gl.NewList(e.glDrwList, gl.COMPILE)
                gcd.CCC[e.gender].Draw(e)
                gl.EndList

                If Not gl.islist(e.glDrwListSel) Then e.glDrwListSel = gl.GenLists(1)
                gl.NewList(e.glDrwListSel, gl.COMPILE)
                gcd.CCC[e.gender].DrawSelected(e)
                gl.EndList

                If Not gl.islist(e.glDrwListRemark) Then e.glDrwListRemark = gl.GenLists(1)
                gl.NewList(e.glDrwListRemark, gl.COMPILE)
                Gcd.CCC[e.gender].DrawRemark(e)
                gl.EndList

                Translate(e, s.PanBaseRealX, s.PanBaseRealY)

            Next
            ' la regeneracion se hace en el punto central de paneo, por lo tanto ahora el paneo es cero
            's.PanX = 0
            's.PanY = 0
            's.ScaleZoom = 1
            ' lista de todas las entidades
            t = Timer

        Next
        glGenDrawListLAyers
        Debug "GLlista de todas generada en  ", Timer - t
    End If

End

'' Generates a GL list for the selected
'' Mode: 0=Selected version 1=Normal version
Public Sub glGenDrawListSel(Optional mode As Integer = 0, RegenEntity As Boolean = False)

    Dim idDrawing As Integer ' la instancia de dibujo en la que estamos
    Dim i As Integer, e As Entity

    For Each e In gcd.Drawing.Sheet.EntitiesSelected
        If RegenEntity Then glGenDrawList(e)
    Next

    If Not gl.islist(gcd.Drawing.GlListEntitiesSelected) Then gcd.Drawing.GlListEntitiesSelected = gl.GenLists(1)

    gl.NewList(gcd.Drawing.GlListEntitiesSelected, gl.COMPILE)

    For Each e In gcd.Drawing.Sheet.EntitiesSelected
        If mode = 0 Then gl.CallList(e.glDrwListSel)
        If mode = 1 Then gl.CallList(e.glDrwList)

    Next

    gl.EndList

End

'' Generates a GL list for the selected
'' Mode: 0=Selected version 1=Normal version
Public Sub glGenDrawListAll(Optional ExcludeSelected As Boolean = False)

    Dim i As Integer, e As Entity

    gl.NewList(gcd.Drawing.Sheet.GlListAllEntities, gl.COMPILE)

    For Each e In gcd.Drawing.Sheet.Entities
        If Not gcd.Drawing.Sheet.EntitiesSelected.Exist(e.id) Then
            If e.pLayer.Visible Then gl.CallList(e.glDrwList)
        End If

    Next

    gl.EndList

End

'' Generates a GL list for the selected
'' Mode: 0=Selected version 1=Normal version
Public Sub glGenDrawListLAyers(Optional aLayer As Layer)

    Dim i As Integer
    Dim e As Entity, s As Sheet

    If aLayer Then

        If Not gl.islist(aLayer.glList) Then aLayer.glList = gl.GenLists(1)
        gl.NewList(aLayer.glList, gl.COMPILE)
        For Each e In gcd.Drawing.Sheet.Entities

            If e.pLayer = aLayer Then
                If Not e.PaperSpace Then

                    gl.CallList(e.glDrwList)
                Endif
            End If
        Next
        gl.EndList

    Else

        For Each aLayer In gcd.Drawing.Layers
            If Not gl.islist(aLayer.glList) Then aLayer.glList = gl.GenLists(1)
            gl.NewList(aLayer.glList, gl.COMPILE)
            For Each s In gcd.Drawing.Sheets
                If Not (s.name = "Model") Then Continue
                For Each e In s.Entities

                    If e.Gender = "HATCH" And Not gcd.DrawHatch Then Continue
                    If e.PaperSpace Then Continue

                    If e.pLayer = aLayer Then
                        gl.CallList(e.glDrwList)
                        ' If e.Gender = cadInsert.Gender And s.name = "Model" And aLayer.Name = "PIPELINES" Then
                        '     Stop
                        '     'Debug e.pBlock.name
                        '     'If Left(e.pBlock.name, 1) = "A" Then Stop
                        ' End If
                        'If e.id = "253F" Then Stop
                    End If
                    'If e.Gender = cadViewport.Gender Then Stop

                Next
            Next
            gl.EndList

        Next

    Endif

End

'' Generates a GL list for the selected
'' Mode: 0=Selected version 1=Normal version
' Public Sub glGenDrawListLAyers2(Optional aLayer As Layer)
'
'     Dim i As Integer
'     Dim e As Entity
'
'     If aLayer Then
'
'         If Not gl.islist(aLayer.glList) Then aLayer.glList = gl.GenLists(1)
'         gl.NewList(aLayer.glList, gl.COMPILE)
'         For Each e In gcd.Drawing.oEntities
'
'             If e.pLayer = aLayer Then gl.CallList(e.glDrwList)
'
'         Next
'         gl.EndList
'
'     Else
'
'         For Each aLayer In gcd.Drawing.oLayers
'             If Not gl.islist(aLayer.glList) Then aLayer.glList = gl.GenLists(1)
'             gl.NewList(aLayer.glList, gl.COMPILE)
'             For Each e In aLayer.Entities
'                 gl.CallList(e.glDrwList)
'
'             Next
'             gl.EndList
'
'         Next
'
'     Endif
'
' End

' Public Sub DrawPoiSymbolsAll()
'
'     Dim i, total As Integer
'
'     For Each e As Entity In gcd.Drawing.Sheet.EntitiesSelected
'
'         ' If (e.Gender = "INSERT") Then
'         DrawPoiSymbols(e)
'         Inc total
'         ' End If
'         '
'         If total = 100 Then Break                           ' limitamos la cantidad de enganches a un numero sensato
'     Next
'
' End

' Public Sub DrawPoiSymbols(oE As Entity)
'
'     Dim i As Integer
'
'     If IsNull(oe) Then Return
'
'     For i = 0 To oe.PoiPoints.Max Step 2
'         Select Case oe.PoiType[i / 2]
'             Case gcd.poiEndPoint
'                 glx.Rectangle2D(oe.PoiPoints[i] - gcd.Metros(4), oe.PoiPoints[i + 1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Blue,,,, Color.Cyan, 1,, 1)
'
'             Case gcd.poiMidPoint
'                 glx.Rectangle2D(oe.PoiPoints[i] - gcd.Metros(4), oe.PoiPoints[i + 1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Cyan,,,, Color.Blue, 1,, 1)
'
'             Case gcd.poiCenter
'                 glx.Rectangle2D(oe.PoiPoints[i] - gcd.Metros(4), oe.PoiPoints[i + 1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Cyan,,,, Color.Blue, 1,, 1)
'
'             Case gcd.poiQuadrant
'                 glx.Rectangle2D(oe.PoiPoints[i] - gcd.Metros(4), oe.PoiPoints[i + 1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Blue,,,, Color.Cyan, 1,, 1)
'
'             Case gcd.poiBasePoint
'                 glx.Rectangle2D(oe.PoiPoints[i] - gcd.Metros(4), oe.PoiPoints[i + 1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Cyan,,,, Color.Blue, 1,, 1)
'
'         End Select
'
'     Next
'
' End

' Public Sub Finish(Optional selected As Boolean = True)
'
'     ' creo copias de cada elemento seleccionado
'     Dim m As Integer, E As Entity
'
'     For Each E In gcd.Drawing.Sheet.Entities
'         If selected Then                                                    ' apply to only the selected ones
'             If E.Selected Then gcd.CCC[e.gender].Finish(E)
'         Else                                                                ' apply to all
'             gcd.CCC[e.gender].Finish(E)
'         End If
'
'     Next
'
' End

Public Sub ClonEntity(eOrigen As Entity, Optional GetNewid As Boolean = True) As Entity

    Dim e As Entity

    e = gcd.CCC[eOrigen.Gender].ClonEntity(eOrigen, GetNewid)

    If Not GetNewid Then e.id = eOrigen.id

    Return e

End

Public Sub ClonElements(Optional cEntities As Collection, GenerateGlList As Boolean = True) As Collection

    ' creo copias de cada elemento seleccionado
    Dim E, eClon As Entity
    Dim cEntititesToClon As Collection
    Dim cContainer As New Collection

    If cEntities Then cEntititesToClon = cEntities Else cEntititesToClon = gcd.Drawing.Sheet.EntitiesSelected

    For Each E In cEntititesToClon
        eClon = Me.ClonEntity(e, True)
        If GenerateGlList Then glGenDrawList(eClon)
        cContainer.Add(eClon, eClon.id)

    Next
    Return cContainer

End

Public Function CopyBlock(bBase As Block) As Block

    Dim b As New Block
    Dim h As Hatch
    Dim s As SPline
    Dim e As Entity

    b.name = bBase.name
    b.description = bBase.description
    b.Explotability = bBase.Explotability
    b.Flags = bBase.Flags
    ' b.HandleAsociatedLayout = bBase.HandleAsociatedLayout
    ' b.HandleOwner = bBase.HandleOwner
    ' b.HandleOwnerParent = bBase.HandleOwnerParent
    b.InsertionPlace = bBase.InsertionPlace
    b.InsertUnits = bBase.InsertUnits
    b.layer = bBase.layer
    b.Scalability = bBase.Scalability
    b.x0 = bBase.x0
    b.y0 = bBase.y0
    b.z0 = bBase.z0

    b.entities = New Collection

    For Each e In bBase.entities
        b.entities.Add(ClonEntity(e), gcd.Newid())
    Next

    Return b

End

Public Function DeSelection(Optional elementos As String = "todo", Accion As String = "deseleccionar") As Integer
    ' Esta rutina analiza si los elemento seleccionados para alguna accion pueden realizarla, caso contrario los deselecciona
    ' se basa en los puntos que tengan la propiedad .Selected = True
    ' tambien puede deseleccionar todo
    ' Devuelve la cantidad de elementos que quedaron seleccionados despues de filtrar

    Dim i As Integer, c As Integer, Clase As String, iii As Integer

    ' por las dudas vengan alguna letra mayuscula
    If Accion = "" Then accion = "deseleccionar"
    accion = LCase(accion)
    elementos = LCase(elementos)

    '   primero vacio la seleccion anterior
    gcd.Drawing.Sheet.EntitiesSelected.Clear
    gcd.Drawing.Sheet.Grips.Clear
    ' For Each eTesting As Entity In gcd.Drawing.Sheet.Entities
    '
    '     clase = eTesting.Gender
    '
    '     Select Case accion
    '
    '         Case "mover", "copiar", "borrar", "escalar" ' necesito que todos los puntos esten seleccionados
    '
    '             If SelFull() And (elementos = "todo" Or elementos = clase) Then
    '
    '                 gcd.Drawing.Sheet.EntitiesSelected.Add(eTesting, eTesting.id)
    '                 SelectElem(eTesting)
    '                 Inc i
    '
    '             Else
    '
    '                 DeSelectElem(eTesting)
    '
    '             End If
    '
    '         Case "estirar" ' necesito que dos puntos contiguos esten seleccionados
    '
    '             If SelPArtial() And (elementos = "todo" Or elementos = clase) Then
    '                 gcd.Drawing.Sheet.EntitiesSelected.Add(eTesting, eTesting.id)
    '                 SelectElem(eTesting, False) ' dont touch the points
    '                 Inc i
    '
    '             Else
    '
    '                 DeSelectElem(eTesting)
    '
    '             End If
    '
    '         Case "deseleccionar" ' todas las acciones
    '
    '             If (elementos = "todo" Or elementos = clase) Then
    '
    '                 Inc i
    '                 DeSelectElem(eTesting)
    '
    '             End If
    '
    '     End Select
    '
    ' Next

    Return i

End

' Public Function GetSelectionCount() As Integer
'
'     Dim e As Entity
'
'     gcd.Drawing.oSelected.Clear
'     For Each e In gcd.Drawing.oEntities
'         If e.Selected Then
'
'             gcd.Drawing.oSelected.Add(e, e.handle)
'         End If
'     Next
'     Return gcd.Drawing.oSelected.Count
'
' End Function

Public Function DeleteSelected() As Integer

    Dim E As Entity, c As Integer
    Dim lay As Layer

    Dim t As Float = Timer

    '  Purgue will also delete those with .ForDeletion = true

    gcd.debugInfo("Borrando entidades",, True)
    Debug "Borrando", Now
    gcd.Drawing.uUndo.OpenUndoStage(("Delete entities"), Undo.TypeDelete)
    c = gcd.Drawing.Sheet.EntitiesSelected.Count
    If c = 0 Then Return 0
    For Each E In gcd.Drawing.Sheet.EntitiesSelected

        gcd.Drawing.uUndo.AddUndoItem(e)
        gcd.Drawing.Sheet.Entities.Remove(gcd.Drawing.Sheet.EntitiesSelected.Key)
        gcd.Drawing.Sheet.EntitiesVisibles.Remove(gcd.Drawing.Sheet.EntitiesSelected.Key)

        e.pLayer.flgForRegen = True
    Next

    gcd.Drawing.uUndo.CloseUndoStage()
    Debug Timer - t
    t = Timer
    gcd.debugInfo("Regenerando graficos",, True)
    Debug "Regenrando", Now
    '   we also need to regenerate the drawing list
    For Each lay In gcd.Drawing.Layers
        If lay.Visible And lay.flgForRegen Then
            glGenDrawListLayers(lay)
            lay.flgForRegen = False
        End If

    Next
    Debug Timer - t

    gcd.debugInfo("Listo",, True)
    Debug "Listo", Now

    ' we also need too recalculate visible items
    Me.CollectVisibleEntities()

    ' TODO: put something in UNDO collection

    Return c

End Function

' Public Function SelectFromPoint(Xr As Float, Zr As Float, Optional Autoselect As Boolean = True) As Entity
'
'     Dim i As Integer
'
'     For i = gcd.Drawing.Sheet.Entities To 0 Step -1
'         ' last elements are drawn last so the click belongs to them
'         If gcd.Drawing.Sheet.Entities[i].pointClick(Xr, Zr) Then
'             If Autoselect Then
'                 If Not gcd.Drawing.Sheet.Entities[i].Selected Then
'                     SelectElem(gcd.Drawing.Sheet.Entities[i])
'                 Else
'                     DeSelectElem(gcd.Drawing.Sheet.Entities[i])
'                 End If
'             End If
'             Return gcd.Drawing.Sheet.Entities[i]
'         End If
'
'     Next
'
' End

Public Sub DrawPoint(x As Float, y As Float, Optional colour As Integer = -1, Optional LargoReal As Float = 0.4)

    If colour <> -1 Then
        paint.brush = Paint.Color(colour)
    Else
        paint.brush = Paint.Color(Color.Blue)
    End If
    paint.LineWidth = 1
    paint.MoveTo(x - LargoReal / 2, y)
    paint.RelLineTo(LargoReal, 0)

    paint.MoveTo(x, y - LargoReal / 2)
    paint.RelLineTo(0, -LargoReal)
    paint.Stroke

End

Public Sub SelectElem(eEntity As Entity, Optional AndItsPoints As Boolean = True)

    Dim i, ii As Integer

    If AndItsPoints Then
        For i = 0 To eEntity.Psel.Max
            eEntity.Psel[i] = True
        Next

    End If
    gcd.Drawing.Sheet.EntitiesSelected.Add(eEntity, eEntity.id)

End

Public Sub DeSelectElem(eEntity As Entity, Optional AndItsPoints As Boolean = True)

    ' deselect all points and myself

    Dim i, ii As Integer

    If AndItsPoints Then
        For i = 0 To eEntity.Psel.Max
            eEntity.Psel[i] = False
        Next

    End If
    gcd.Drawing.Sheet.EntitiesSelected.Remove(eEntity.id)

End

Public Sub Move(dX As Float, dY As Float, Optional cEntitiesToMove As Collection, OnlyPointSelected As Boolean = False, DoUndo As Boolean = False)

    ' crea un backup de todos los puntos
    Dim e As Entity, i As Integer

    If Not cEntitiesToMove Then cEntitiesToMove = gcd.Drawing.Sheet.EntitiesSelected

    For Each e In cEntitiesToMove
        If DoUndo Then
            gcd.Drawing.uUndo.AddUndoItem(Me.ClonEntity(E, False))
        Endif

        gcd.CCC[e.gender].Translate(e, dX, dY, OnlyPointSelected)

    Next

End

Public Sub Rotate(e As Entity, degAngle As Float)

    gcd.CCC[e.gender].Rotate(e, degAngle)

End

Public Sub Draw(e As Entity, Optional s As Sheet = gcd.drawing.Sheet)

    'gcd.CCC[e.gender].Translate(e, -s.PanBaseRealX, -s.PanBaseRealY)

    gcd.CCC[e.gender].Draw(e)

    'gcd.CCC[e.gender].Translate(e, s.PanBaseRealX, s.PanBaseRealY)

End

Public Sub Draw2(e As Entity, Optional s As Sheet = gcd.drawing.Sheet)

    'gcd.CCC[e.gender].Translate(e, -s.PanBaseRealX, -s.PanBaseRealY)
    gcd.CCC[e.gender].Draw2(e)
    'gcd.CCC[e.gender].Translate(e, s.PanBaseRealX, s.PanBaseRealY)

End

Public Sub DrawSelected(e As Entity, Optional s As Sheet = gcd.drawing.Sheet)

    'gcd.CCC[e.gender].Translate(e, -s.PanBaseRealX, -s.PanBaseRealY)

    gcd.CCC[e.gender].DrawSelected(e)
    'gcd.CCC[e.gender].Translate(e, s.PanBaseRealX, s.PanBaseRealY)

End

Public Sub DrawRemark(e As Entity, Optional s As Sheet = gcd.drawing.Sheet)

    'gcd.CCC[e.gender].Translate(e, -s.PanBaseRealX, -s.PanBaseRealY)
    gcd.CCC[e.gender].DrawRemark(e)
    'gcd.CCC[e.gender].Translate(e, s.PanBaseRealX, s.PanBaseRealY)

End

Public Sub Translate(e As Entity, dX As Float, dY As Float)

    gcd.CCC[e.gender].Translate(e, dX, dY)

End

Public Sub Scale(e As Entity, sX As Float, sY As Float)

    gcd.CCC[e.gender].Scale(e, sX, sY)

End

Public Function SelectionSquare(X1real As Float, Y1real As Float, X2real As Float, Y2real As Float, Optional crossing As Boolean = False) As Collection

    ' Veo que accion estoy tomando
    Dim e As Entity, i, i2, TotalSeleccionados As Integer
    Dim c As New Collection

    ' NuevaSumaResta = LCase$(NuevaSumaResta)
    '
    ' If NuevaSumaResta = "nueva" Then ' nueva seleccion
    '     For Each e In gcd.Drawing.Sheet.EntitiesSelected
    '         For i2 = 0 To e.Psel.max
    '             e.Psel[i2] = False
    '         Next
    '     Next
    '     gcd.Drawing.Sheet.EntitiesSelected.Clear
    '     TotalSeleccionados = 0
    ' End If

    For Each e In gcd.Drawing.Sheet.Entities ' TODO: podria ser solo las visibles
        ' cada entidad debe decidir si esta seleccionada o no
        If crossing Then
            If SelPArtial(e, X1real, Y1real, X2real, Y2real) Then c.Add(e, e.id)
            '     ' el punto esta en el recuadro
            '     If NuevaSumaResta <> "resta" Then
            '         Inc TotalSeleccionados
            '         Me.SelectElem(e, False)
            '
            '     Else If NuevaSumaResta = "resta" Then
            '         Dec TotalSeleccionados
            '         Me.DeSelectElem(e, False)
            '
            '     End If
            '
            ' Endif
        Else
            If SelFull(e, X1real, Y1real, X2real, Y2real) Then c.Add(e, e.id)
            ' el punto esta en el recuadro
            '     If NuevaSumaResta <> "resta" Then
            '         Inc TotalSeleccionados
            '         Me.SelectElem(e, False)
            '
            '     Else If NuevaSumaResta = "resta" Then
            '         Dec TotalSeleccionados
            '         Me.DeSelectElem(e, False)
            '
            '     End If
            '
            ' Endif

        End If
    Next
    ' GetSelectionCount()

    Return c

End

Public Function SelectionPoly(Poly As Float[], Optional crossing As Boolean = False) As Collection

    ' Veo que accion estoy tomando
    Dim e As Entity
    Dim c As New Collection

    For Each e In gcd.Drawing.Sheet.Entities ' TODO: podria ser solo las visibles
        ' cada entidad debe decidir si esta seleccionada o no
        If crossing Then
            If gcd.CCC[e.Gender].SelPartialPoly(e, Poly) Then c.Add(e, e.id)

        Else
            If gcd.CCC[e.Gender].SelFullPoly(e, Poly) Then c.Add(e, e.id)

        End If
    Next

    Return c

End

'' Put all visible entity refs in arrVisibleEntities[]
Public Function CollectVisibleEntities(Optional sSheet As Sheet)

    Dim x0, y0, x1, y1 As Float
    Dim lay As Layer
    Dim e As Entity
    Dim i, tot As Integer
    Dim s As Sheet
    Dim ho As String

    gcd.flgsearchingallowed = False

    x0 = gcd.Xreal(0)
    y1 = gcd.Yreal(0)                     ' el eje Y esta invertido en OpenGL
    x1 = gcd.Xreal(gcd.ScreenWidth())
    y0 = gcd.Yreal(gcd.ScreenHeight())

    If Not sSheet Then sSheet = gcd.Drawing.Sheet

    'If gcd.Drawing.oEntities > gcd.Drawing.arrVisibleEntities.Max Then gcd.Drawing.arrVisibleEntities.Resize(gcd.Drawing.oEntities.Count)
    gcd.Drawing.Sheet.EntitiesVisibles.Clear
    For Each e In sSheet.Entities 'gcd.Drawing.Entities
        If e.pLayer.Visible Then

            'If e.HandleOwner = ho Then

            If SelPArtial(e, x0, y0, x1, y1) Then

                gcd.Drawing.Sheet.EntitiesVisibles.Add(e, e.id)

            End If
            'End If
        End If
    Next

    ' depre porque todas son detectables ahora CollectDetectableEntities
    'gcd.debugInfo("Recolectadas las entidades visibles",,, True)
    gcd.flgSearchingAllowed = True

End

Public Sub BuildGeometry(Optional e As Entity = Null, s As Sheet = gcd.drawing.Sheet)

    Dim b As Block

    If e Then
        gcd.CCC[e.gender].Buildgeometry(e)
    Else
        For Each b In gcd.Drawing.Blocks
            For Each e In b.entities
                gcd.CCC[e.gender].Buildgeometry(e)
            Next
        Next
        ' For Each s In gcd.Drawing.Sheets
        '     For Each e In s.Entities
        '         gcd.CCC[e.gender].Buildgeometry(e)
        '     Next
        ' Next
    End If

End

'Return bound limits for all verices in the array of entities

Public Function ComputeLimits(Optional entities As Collection, OnlyVisibles As Boolean = True, IgnorePoints As Boolean = True, OnlyModel As Boolean = True) As Float[]

    Dim e As Entity, i As Integer
    Dim entGroup As Collection

    Dim newLimits As New Float[]
    Dim IsVisible As Boolean
    ' Dim a As Integer

    newLimits = [1e100, 1e100, -1e100, -1e100]

    If Not entities Then entGroup = gcd.Drawing.Sheet.Entities Else entGroup = Entities

    If entGroup.Count = 0 Then Return [0, 0, 0, 0]

    For Each e In entGroup

        If OnlyVisibles Then
            If IsNull(e.pLayer) Then
                IsVisible = True
            Else
                IsVisible = e.pLayer.Visible And e.Visible And (Not e.pLayer.Frozen)
            End If

        Endif

        If IsVisible Then

            puntos.LimitsMax(newLimits, gcd.CCC[e.Gender].limits(e))

            'If newLimits[0] < -1e10 Then Stop

        Endif

    Next

    Return newLimits

End

'' Determines if the entity was selected by a rectanle surrounding al points
'' by default, if ALL points are selected, it can.
Public Function SelFull(eTesting As Entity, X1real As Float, Y1real As Float, X2real As Float, Y2real As Float) As Boolean

    Return gcd.CCC[eTesting.Gender].SelFull(eTesting, X1real, Y1real, X2real, Y2real)

End

'' Determines if the entity
'' by default, if ANY point is selected, it can.
Public Function SelPartial(eTesting As Entity, X1real As Float, Y1real As Float, X2real As Float, Y2real As Float) As Boolean

    Return gcd.CCC[eTesting.Gender].SelPArtial(eTesting, X1real, Y1real, X2real, Y2real)

End

' Public Function GetParentBlock(iEntity As Integer) As Integer
'
'     Dim iParent As Integer
'
'     iParent = iEntity
'     Do
'
'         If gcd.CurrDrawing.arrEntities[iParent].iInsert >= 0 Then
'             If iParent = gcd.CurrDrawing.arrEntities[iParent].iInsert Then Break
'             iParent = gcd.CurrDrawing.arrEntities[iParent].iInsert
'         Else
'             Break
'         End If
'
'     Loop
'
'     Return iParent
'
' End

'' Imports data from a collection to an entity. True if the entity is handled by GambasCAD at this version,
'' False if entity couldn't be created for some reason.
Public Function DXFImportToEntity(drw As Drawing, c As Collection, Optional IsDummy As Boolean = False) As Entity

    Dim clsidr As Object
    Dim sClass As Class
    Dim sClave As New String[]
    Dim sValue As New String[]
    Dim lpValue, lpclave As String
    Dim i As Integer
    Dim GotEntity As Boolean
    Dim e As Entity
    Dim LT As LineType

    dxf.DigestColeccion(c, ByRef sClave, ByRef sValue)

    e = gcd.CCC[c[dxf.codEntity]].newEntity()
    ' llenamos Common data:
    Try e.pLayer = GetLayerByName(c[dxf.codLayer])
    If e.pLayer = Null Then e.pLayer = gcd.Drawing.CommonLayer

    e.id = c[dxf.codid]

    ' for testing FIXME: ojo con esto!!!
    '    If e.handle = "129D" Then Stop

    'Try e.idContainer = dxf.ReadCodeFromCol(c, dxf.codidContainer)
    Try e.Container = dxf.hContainers[dxf.ReadCodeFromCol(c, dxf.codidContainer)]
    Try e.colour = c[dxf.codColor]            ' no es obligatorio
    If c.Exist("370") Then
        e.LineWidth = c["370"] ' 1/100 mm
    Else
        e.LineWidth = -3
    End If

    ' 67 Absent or zero indicates entity is in model space. 1 indicates entity is in paper space (optional).
    If c.Exist("67") Then ' no es obligatorio

        If c["67"] = "1" Then e.PaperSpace = True
    End If

    If c.Exist(dxf.codLType) Then
        LT = GetLTypeByName(c[dxf.codLType])
        If LT Then
            e.LineType = LT
        Else
            e.LineType = Drw.LineTypes[drw.LineTypes.First]
        End If
    Else
        e.LineType = drw.LineTypes[drw.LineTypes.First]

    End If

    If gcd.CCC[e.gender].ImportDXF(e, sClave, sValue) Then

        'If gcd.CCC[e.gender].gender <> "Hatch" Then gcd.CCC[e.gender].Finish(e)
        gcd.CCC[e.gender].Finish(e)

        Return e

    Else

        Return Null

    End If

    ' Catch
    'gcd.CCC[e.gender] = cadDummy
    Return Null

End

Public Function GetEntityIndex(dDrawing As Drawing, sid As String, Optional iStart As Integer = 0) As Integer

    Dim i As Integer

    For i = iStart To dDrawing.Sheet.Entities

        If dDrawing.Sheet.Entities[i].id = sid Then Return i

    Next

    Return -1           ' no hay handle asociada a esa entidad

End

Public Sub DXFExportCommonCol(e As Entity, ByRef cExported As String[])

    Dim idc As String

    cExported.Add(e.Gender)
    cExported.Add(dxf.codEntity)
    cExported.add(e.id)
    cExported.Add(dxf.codid)
    Try idc = e.Container.idContainer
    cExported.add(idc)     ' FIXME: esto no deberia ser asi
    cExported.Add(dxf.codidContainer)
    cExported.Add("AcDbEntity")
    cExported.Add("100")
    If e.pLayer = Null Then cExported.Add("0") Else cExported.Add(e.pLayer.Name)
    cExported.Add(dxf.codLayer)
    cExported.Add(e.LineType.Name)
    cExported.Add(dxf.codLType)
    cExported.Add(e.colour)
    cExported.Add(dxf.codColor)
    cExported.Add(CStr(e.LineWidth))
    cExported.Add(dxf.codLWht)

End

' '' Imports data from a collection to an entity. True if the entity is handled by GambasCAD at this version,
' '' False if entity couldn't be created for some reason.
' Public Function ImportJsonToEntity(c As JSONCollection, Optional IsDummy As Boolean = False) As Entity
'
'     Dim clsHandler As Object
'     Dim e As Entity
'
'     ' If Not c.Exist("entity") Then Return False
'     ' If Not c "entity") Then Return False
'     If IsDummy Then
'         clsHandler = cadDummy
'     Else
'         clsHandler = Object.New("cad" & c["entity"])  ' obtenemos el tipo de entidad y buscamos su clase. Si no manjemos esa entidad, esto de error.
'
'     End If
'
'     e = clsHandler.newEntity() ' le pedimos a la clase que arme un objeto Entity para agregar al Drawing actual
'     If clsHandler.ImportJSONCol(c, e) Then
'         ' llenamos Common data:
'         e.player = GetLayerByHandle(c["layer"][3])  ' busco el layer por nombre
'         e.Handle = c["handle"][1]
'         If e.pLayer = Null Then Stop
'         If TypeOf(c["color"]) = gb.Object Then
'             Try e.colour = c["color"]["index"]    ' FIXME: esto sigue dando error
'         Else
'             Try e.colour = c["color"]
'         Endif
'         e.LineWidth = c["linewt"] / 100
'         If e.LineWidth < 1 Then e.LineWidth = 1
'         e.LineType = GetLTypeByIndex(c["ltype_flags"])
'         If Not e.LineType Then
'             e.LineType = gcd.Drawing.oLTypes[gcd.Drawing.oLTypes.First]
'         End If
'
'         clsHandler.Finish(e)
'
'         Return e
'
'     Else
'
'         Return Null
'
'     End If
'
'     'Catch
'     'gcd.CCC[e.gender] = cadDummy
'     Return False
'
' End

Public Function GetLTypeByName(sName As String) As LineType

    Dim LT As LineType

    For Each LT In gcd.Drawing.LineTypes

        If LCase(LT.Name) = LCase(sname) Then Return LT

    Next

    Return Null

End

Public Function GetLTypeByIndex(sName As String) As LineType

    Dim lt As LineType

    For Each lt In gcd.Drawing.LineTypes

        If LCase(lt.Name) = LCase(sname) Then Return lt

    Next

    Return Null

End

Public Function GetLayerByid(sid As String) As Layer

    Dim Lay As Layer

    For Each Lay In gcd.Drawing.Layers

        If Lay.id = sid Then Return Lay
    Next
    Return Null

End

Public Function GetLayerByName(LayerName As String) As Layer

    Dim Lay As Layer

    For Each Lay In gcd.Drawing.Layers

        If Lay.Name = LayerName Then Return Lay
    Next
    Return Null

End

'' Reads entities and fill arrLayers
' Public Sub FillLayersWithEntities(oDrawing As Drawing)
'
'     Dim hLay As Layer
'     Dim e As Entity
'
'     ' primero eliminamos lo q haya
'     For Each hLay In oDrawing.Layers
'         hLay.Entities.Clear
'     Next
'
'     If oDrawing.Entities Then
'         For Each e In oDrawing.Entities
'             'e.pLayer = CurrDrawing.arrLayers[gcd.FindLaIndex(e.pLayer)]
'             e.pLayer.Entities.Add(e)
'         Next
'     End If
'     ' Esto ya no es posible con Colecciones
'     'Drawing.oVisibleEntities.Resize(Drawing.oEntities.Count)
'     gcd.debugInfo("Llenados los Layers con las entidades",,, True)
'
' End

'' Devuelve una entidad recortada de la original que esta dentro del recuadro provisto
'' o null si la enidad base queda afuera del recuadro
Public Function TrimmedEntity(eBase As Entity, x0 As Float, y0 As Float, X1 As Float, Y1 As Float) As Entity
    ' vamos a considerar que x0,y0 son coordenadas inferior-izquierda (como openGL, no como Paint)

    If Me.SelFull(eBase, x0, y0, x1, y1) Then Return eBase

    If Me.SelPartial(eBase, x0, y0, x1, y1) Then
        Return eBase

    Else ' la entidad esta completamente fuera del recuadro

        Return Null
    Endif

End

'' Convierte una Entity a JSON a efectos de ser usada con el Clipboard
'' No se incluye informacion propia del Drawing, solo de las entidades.
Public Sub EntityToJsonString(e As Entity) As String

    Dim j As New JSONCollection
    Dim s As String

    j.Add(e.Gender, "Entity")
    j.Add(e.p, "Points")                    '' X,Y pairs
    j.Add(e.sParam, "ParamString")      '' Array of Strings
    j.Add(e.fparam, "ParamFloat")           '' Array of floats
    j.Add(e.iParam, "ParamInt")             '' Array of integers
    j.Add(e.Colour, "Color")                '' CAD color code
    j.Add(e.LineWidth, "LineWidth")
    Try j.Add(e.LineType.Name, "LineType")
    Try j.Add(e.pStyle.name, "Style")
    Try j.Add(e.pDimStyle.name, "DimStyle")

    s = JSON.encode2(j)
    Return s

End

Public Function SelectionCombine(cBase As Collection, cNew As Collection, sMode As String) As Collection

    Dim cCombined As New Collection, e As Entity

    If sMode = "new" Then
        For Each e In cNew
            cCombined.Add(e, e.id)
        Next
    Else If sMode = "add" Then
        For Each e In cBase
            cCombined.Add(e, e.id)
        Next
        For Each e In cNew
            cCombined.Add(e, e.id)
        Next

    Else If sMode = "rem" Then

        For Each e In cBase
            cCombined.Add(e, e.id)
        Next

        For Each e In cNew
            If cCombined.Exist(e.id) Then cCombined.Remove(e.id)
        Next
    End If

    Return cCombined

End

Public Sub RebuildDimensions(Optional cDims As Collection)

    Dim c As Collection, e As Entity, sBlockName As String

    If cDims Then c = cDims Else c = gcd.Drawing.Sheet.Entities

    For Each e In c
        If e.Gender Like "DIM*" Then
            sBlockName = e.pBlock.name
            Try e.pBlock = gcd.CCC[e.Gender].RebuildBlock(e)
            e.pBlock.name = sBlockName
        Endif
    Next

End

Public Function FindInsertByName(cEntities As Collection, sName As String) As Entity

    Dim e As Entity
    Dim b As Block

    For Each e In cEntities
        If e.pBlock Then
            If e.pBlock.name = sName Then
                Return e
            Endif
        Endif
    Next
    Return Null

End
