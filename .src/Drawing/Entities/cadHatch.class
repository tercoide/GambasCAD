' Gambas class file

' GambasCAD
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
Create Static
' Fast
Inherits EntityBase
Public Const Gender As String = "HATCH"
Public Const PointsToDraw As Integer = 0             ' minimal point requered for drawing something usefull
Public Const CmdLineHelper As String = ("Hatch")
Public Const ParamType As String = "PTF"                             ' that is Point, Point, Float; could be Color Text, etc
Public Const ParamHelper As String = "Point;Texture;Scale"      ' a little text that is shown at the prompt waiting for user input during build
Public Const ParamDefault As String = " ;Concrete;1"
Public Const USEWITH As String = "HATCHBUILDER"

' fParam helpers
Public Const TotalParams As Integer = 10
Public Const ipaSolId As Integer = 0
Public Const ipaAsociativity As Integer = 1
Public Const ipaTotalLoops As Integer = 2
Public Const ipaRotation As Integer = 3
Public Const ipaScale As Integer = 4
Public Const ipaParity As Integer = 5
Public Const ipaPatternType As Integer = 6
Public Const ipaBoundaryType As Integer = 7 ' 0=lwpolyine, 1=lines, 2=circular arc, 3=ellipse arc, 4=spline

' stringdata helpers
Public Const sdaTotalParams As Integer = 2
Public Const sdaPattern As Integer = 0
Public Const sdaPaternFile As Integer = 1           ' depre

Public Xmenor As Float = 1e10
Public Ymenor As Float = 1e10
Public Xmayor As Float = -1e10
Public Ymayor As Float = -1e10

Public h As Hatch

' Parametros de la entidad:

' P[]:        son los puntos de la polilinea que define el contorno del sombreado
' fParam[0]:  escala del sombreado
' fParam[1]:  angulo
' StringData[0]: nombre del patron del sombreado
Public Sub ClonEntity(eOrigen As Entity, Optional GetNewid As Boolean = True) As Entity

    Dim e, eSegment, eSegmentNew As Entity, bBase As Hatch, flxPoly, flxPoly2 As Float[], eSegments, eSegmentsNew As Entity[]

    e = Super.ClonEntity(eOrigen)

    h = New Hatch
    e.pBlock = h
    bBase = eOrigen.pBlock
    h.SeedPoints.Insert(bBase.SeedPoints.copy())
    h.Levels.Insert(bBase.Levels.Copy())
    h.Flag = bBase.Flag
    h.eSegments = New Entity[][]
    For Each eSegments In bBase.eSegments
        eSegmentsNew = New Entity[]
        For Each eSegment In eSegments
            eSegmentNew = gcd.CCC[eSegment.gender].ClonEntity(eSegment)
            eSegmentsNew.Add(eSegmentNew)
        Next
        h.eSegments.Add(eSegmentsNew)
    Next

    For Each flxPoly In bBase.Polylines
        flxPoly2 = New Float[]
        flxPoly2.Insert(flxPoly.Copy())
        h.Polylines.add(flxPoly2)
    Next

    Dim p, p2 As Pattern
    Dim f As Float
    For Each p In bBase.patterns
        p2 = New Pattern
        p2.AngleDeg = p.AngleDeg
        p2.BaseX = p.BaseX
        p2.BaseY = p.BaseY
        p2.OffsetX = p.OffsetX
        p2.OffsetY = p.OffsetY
        p2.DashLength = New Float[]
        For Each f In p.DashLength
            p2.DashLength.Add(f)
        Next
        h.Patterns.add(p2)
    Next

    Return e

End

'' Builds the geometry of the entity wthout drwing it
Public Function BuildGeometry(E As Entity, Optional density As Float)

    Dim flxContorno As Float[]
    Dim h As Hatch = e.pBlock

    If (h.PolyLines.Count = 0) And (e.Polygon.Count = 0) Then

        e.PolyLine.Clear
        e.Polygon.Clear

        MakeBorder2(h)

    End If

    If LCase(e.sParam[Me.sdaPattern]) <> "solid" Then

        FillEntityWithHatch4(e)

    Else

        ' para solidos, tengo que hacer una llamada para cada loop de borde
        ' tengo q ver cuantos puntos tiene cada loop
        ' Ojo con LibreCAD
        'For Each e.pBlock In hData

        For Each flxContorno In h.PolyLines
            h.Triangles.Add(puntos.PolygonTriangulation(flxContorno))
        Next

    End If
    Me.Limits(e)

End

Public Sub Draw(oE As Entity)

    Dim i, iLoop, iStart, iColour As Integer
    Dim fBorder As New Float[]
    Dim h As Hatch = oe.pBlock
    Dim E2 As Entity

    If Not oE.Visible Then Return

    'BuildGeometry(oe)

    If LCase(oe.sParam[Me.sdaPattern]) <> "solid" Then
        iColour = gcd.GetGBColor(oE.Colour, oe.pLayer)
        glx.DrawLines(oE.PolyLine, iColour, gcd.GetLineWt(oE.LineWIdth, oe.pLayer), oE.LineType.TrameLength)

        ' Dim oBound As Float[]
        '
        ' For Each oBound In oe.pBlock.Polylines
        '
        '     glx.PolyLines(obound, iColour, gcd.GetLineWt(oE.LineWIdth, oe.pLayer), oE.LineType.TrameLength)
        ' Next

        gl.Begin(gl.POINTS)

        For i = 0 To oE.PolyLine.Max - 3 Step 4
            If (oE.PolyLine[i] = oE.PolyLine[i + 2]) And (oE.PolyLine[i + 1] = oE.PolyLine[i + 3]) Then
                glx.glColorRGB(iColour)
                gl.Vertex2f(oE.PolyLine[i], oE.PolyLine[i + 1])
            End If

        Next
        gl.end

    Else

        ' para solidos, tengo que hacer una llamada para cada loop de borde
        ' tengo q ver cuantos puntos tiene cada loop
        ' Ojo con LibreCAD
        'For Each oLoop In ohData

        ' obtengo el poligono de bordes
        ' fBorder.Clear
        ' fBorder.Insert(oLoop.e.PolyLine.Copy(iStart, oe.iParam[iLoop]))
        ' iStart += fBorder.Count

        'glx.Polygon(oLoop.Polyline, Color.Yellow, 2)
        ' If oloop.Polylines.Count = 0 Then Return
        '
        ' If puntos.IsPoligonSelfIntersecting(oLoop.Polylines[0]) Then
        '
        '     Debug "A polygon in HATCH is self intersecting"
        ' Endif
        For i = 0 To h.Triangles.max
            glx.zLevel = 0.1 - Abs(h.Levels[i] / 100)
            If h.Levels[i] > 0 Then
                iColour = gcd.GetGBColor(oE.Colour, oe.pLayer)
            Else
                iColour = Config.ModelBackgroundColor
            Endif
            glx.DrawTriangles(h.Triangles[i], iColour, iColour)

        Next

        glx.zLevel = 0

    End If

End

'' A fat version of the line
Public Sub DrawSelected(oE As Entity)

    Dim oBound As Float[]

    For Each oBound In oe.pBlock.Polylines

        glx.DrawLines(obound, Color.Gradient(gcd.GetGBColor(oE.Colour, oe.pLayer), Config.ModelBackgroundColor), gcd.GetLineWt(oE.LineWIdth, oe.pLayer), oE.LineType.TrameLength)
    Next

    glx.DrawLines(oE.PolyLine, Color.Gradient(gcd.GetGBColor(oE.Colour, oe.pLayer), Config.ModelBackgroundColor))

End

'' A fat version of the line
Public Sub DrawRemark(oE As Entity)

    Dim oBound As Float[]

    For Each oBound In oe.pBlock.Polylines

        glx.PolyLines(obound, Color.Gradient(gcd.GetGBColor(oE.Colour, oe.pLayer), Config.WhiteAndBlack), gcd.GetLineWt(oE.LineWIdth, oe.pLayer) + 1, oE.LineType.TrameLength)
    Next

    glx.DrawLines(oE.PolyLine, Color.Gradient(gcd.GetGBColor(oE.Colour, oe.pLayer), Config.WhiteAndBlack), gcd.GetLineWt(oE.LineWIdth, oe.pLayer) + 1)

End

Public Function Draw2(oE As Entity)

    Dim iLoop, iStart As Integer
    Dim fBorder As New Float[]

    If oe.sParam[1] <> "SolId" Then

        paintPlus.Lines(oE.PolyLine)
    Else
        Paint.Polygon(oe.PolyLine)

    End If

End

' '' Creo los puntos de interes
' '' Build point of interest
'
' Public Function BuildPOI(oE As Entity) As Integer
'
'     ' si este valor no es provisto , estos POI son de la ultima entidad
'     Dim i As Integer
'
'     Return
'     oe.PoiPoints.Clear
'     oe.poiPoints.insert([oE.P[0], oE.P[1]])
'     oe.poiType.Add(gcd.poiEndPoint)
'     'oe.poiEntities.Add(arrIndex)
'
'     For i = 0 To oE.P.count - 4 Step 2
'
'         oe.poiPoints.insert([(oE.P[i + 0] + oE.P[i + 2]) / 2, (oE.P[i + 1] + oE.P[i + 3]) / 2])   ' mid
'         oe.poiType.Add(gcd.poiMIdPoint)
'         'oe.poiEntities.Add(arrIndex)
'
'         oe.poiPoints.insert([oE.P[i + 2], oE.P[i + 3]])
'         oe.poiType.Add(gcd.poiEndPoint)
'         'oe.poiEntities.Add(arrIndex)
'
'         ' line
'         'gcd.CurrDrawing.poiLines.insert([oE.p[i], oE.p[i + 1], oE.p[i + 2], oE.p[i + 3]])
'         'gcd.CurrDrawing.poiLinesEntities.Add(arrIndex)
'         ' gcd.CurrDrawing.poiLinesRelPoint.Insert([i / 2, i / 2 + 1])
'
'     Next
'
' End

Public Sub Translate(e As Entity, dX As Float, dY As Float, Optional OnlySelected As Boolean = False)

    Dim p As Float[], eBorder As Entity, eBorders As Entity[], pater As Pattern

    h = e.pBlock

    ' muevo las entidades que definen el contorno
    For Each eBorders In h.eSegments
        For Each eborder In eBorders
            gcd.CCC[eborder.Gender].Translate(eborder, dx, dy)
        Next
    Next

    ' muevo el patron
    For Each pater In h.Patterns
        pater.BaseX += dx
        pater.BaseY += dy

    Next

    puntos.Translate(h.SeedPoints, dx, dy)

    'Me.BuildGeometry(e)
    puntos.Translate(e.PolyLine, dx, dy)
    puntos.Translate(e.Polygon, dx, dy)

    Dim oBound As Float[]

    For Each oBound In h.Polylines

        puntos.Translate(oBound, dx, dy)
    Next

End

Public Sub Rotate(e As Entity, radians As Float)

    Dim p As New Float[], eBorder As Entity, eBorders As Entity[], pater As Pattern

    h = e.pBlock

    ' muevo las entidades que definen el contorno
    For Each eBorders In h.eSegments
        For Each eborder In eBorders
            gcd.CCC[eborder.Gender].rotate(eborder, radians)
        Next
    Next

    ' muevo el patron
    For Each pater In h.Patterns

        p.Clear
        p.Insert([pater.BaseX, pater.BaseY, pater.OffsetX, pater.OffsetY])
        puntos.Rotate(p, radians)
        pater.BaseX = p[0]
        pater.BaseY = p[1]
        pater.OffsetX = p[2]
        pater.OffsetY = p[3]
        pater.AngleDeg += Deg(radians)
    Next

    puntos.Rotate(h.SeedPoints, radians)

    puntos.Rotate(e.PolyLine, radians)
    puntos.Rotate(e.Polygon, radians)

    Dim oBound As Float[]

    For Each oBound In h.Polylines

        puntos.Rotate(oBound, radians)
    Next
    'Me.BuildGeometry(e)

End

Public Sub Scale(e As Entity, sX As Float, sY As Float)

    Dim p As Float[], eBorder As Entity, eBorders As Entity[], pater As Pattern, l As Float
    Dim i As Integer

    h = e.pBlock

    ' muevo las entidades que definen el contorno
    For Each eBorders In h.eSegments
        For Each eborder In eBorders
            gcd.CCC[eborder.Gender].scale(eborder, sx, sy)
        Next
    Next

    ' muevo el patron
    For Each pater In h.Patterns
        pater.BaseX *= sx
        pater.BaseY *= sy
        pater.OffsetX *= sx
        pater.OffsetY *= sy
        For i = 0 To pater.DashLength.Max
            pater.DashLength[i] *= (sx + sy) / 2
        Next

    Next

    puntos.Scale(h.SeedPoints, sx, sy)

    puntos.Scale(e.PolyLine, sx, sy)
    puntos.Scale(e.Polygon, sx, sy)

    Dim oBound As Float[]

    For Each oBound In h.Polylines

        puntos.Scale(oBound, sx, sy)
    Next
    'Me.BuildGeometry(e)

End

Public Function ImportDXF(e As Entity, sClaves As String[], sValues As String[]) As Boolean

    Dim i, i2, ip, iPattern, iLoop, iPoints, iBorderObjects, iBoundaryObject As Integer
    Dim LoopToRead As Integer
    Dim LoopType As Integer
    Dim EdgesToRead As Integer
    Dim EdgeType As Integer
    Dim eContour As Entity
    Dim edge As Integer
    Dim NewPath As Hatch
    Dim oPattern As Pattern
    ' Dim jscPath, vSeg As JSONCollection
    Dim RefObjId As String
    Dim DashLength, fVar As Float
    Dim hData As Hatch
    Dim Dashes As Integer
    Dim sp As SPline
    Dim r As String
    Dim nPattern As Integer
    Dim mySegments As Entity[]

    ' vamos a agrupar las entidades que forman el contorno en un bloque
    e.pBlock = New Hatch
    NewPath = e.pBlock

    'If e.id = "353E1BE4" Then Stop
    i = dxf.ReadCodePlus(2, sClaves, sValues, ByRef e.sParam[Me.sdaPattern], 0, 70)
    i = dxf.ReadCodePlus(70, sClaves, sValues, ByRef e.fParam[Me.ipaSolId], i, 71)
    i = dxf.ReadCodePlus(71, sClaves, sValues, ByRef e.fParam[Me.ipaAsociativity], i, 91)

    i = dxf.ReadCodePlus(91, sClaves, sValues, ByRef LoopToRead, i)
    'If e.id = "59B" Then Stop
    For iLoop = 0 To LoopToRead - 1 'descubri que un Loop puede o no ser un area a rellenar distinta, a veces un Loop es un agujero de otro Loop
        mySegments = New Entity[]
        NewPath.eSegments.Add(mySegments)
        i = dxf.ReadCodePlus(92, sClaves, sValues, ByRef LoopType, i, 93)

        NewPath.Flag = LoopType

        ' If i = True Then Stop
        If (LoopType And 2) <> 2 Then ' otherwise is a polyline

            i = Abs(i)
            i = dxf.ReadCode(93, sClaves, sValues, ByRef EdgesToRead, i)

            For edge = 0 To EdgesToRead - 1

                i = dxf.ReadCode(72, sClaves, sValues, ByRef EdgeType, i)

                ' segun el tipo de edge, agrego una entidad al bloque que
                ' forma el contorno
                ' a esta entidad que es un borde le etiquetamos el loop al que pertenece

                Select Case EdgeType
                    Case 0  ' invalido

                        gcd.debugInfo("HATCH: Borde invalido")

                    Case 1 ' lines

                        eContour = cadLine.NewEntity()
                        eContour.P.Clear
                        ' leo los dos puntos
                        i = dxf.ReadCode(10, sClaves, sValues, ByRef r, i)
                        eContour.P.Add(CFloat(r))
                        i = dxf.ReadCode(20, sClaves, sValues, ByRef r, i)
                        eContour.P.Add(CFloat(r))
                        i = dxf.ReadCode(11, sClaves, sValues, ByRef r, i)
                        eContour.P.Add(CFloat(r))
                        i = dxf.ReadCode(21, sClaves, sValues, ByRef r, i)
                        eContour.P.Add(CFloat(r))

                    Case 2 ' arc o circle

                        eContour = cadArc.NewEntity()
                        eContour.P.Clear
                        eContour.fParam.Clear
                        eContour.iParam.Clear
                        i = dxf.ReadCode(10, sClaves, sValues, ByRef r, i)
                        eContour.P.Add(CFloat(r))
                        i = dxf.ReadCode(20, sClaves, sValues, ByRef r, i)
                        eContour.P.Add(CFloat(r))
                        i = dxf.ReadCode(40, sClaves, sValues, ByRef r, i)
                        eContour.fParam.Add(CFloat(r))
                        i = dxf.ReadCode(50, sClaves, sValues, ByRef r, i)
                        eContour.fParam.Add(CFloat(r))
                        i = dxf.ReadCode(51, sClaves, sValues, ByRef r, i)
                        eContour.fParam.Add(CFloat(r))
                        i = dxf.ReadCode(73, sClaves, sValues, ByRef r, i)
                        If CInt(r) = 0 Then eContour.iParam.Add(1) Else eContour.iParam.Add(0)

                    Case 3 ' ellipse

                        eContour = cadEllipse.NewEntity()
                        eContour.P.Clear
                        eContour.fParam.Clear
                        i = dxf.ReadCode(10, sClaves, sValues, ByRef r, i)
                        eContour.P.Add(CFloat(r))
                        i = dxf.ReadCode(20, sClaves, sValues, ByRef r, i)
                        eContour.P.Add(CFloat(r))
                        i = dxf.ReadCode(11, sClaves, sValues, ByRef r, i)
                        eContour.P.Add(CFloat(r) + eContour.P[0])
                        i = dxf.ReadCode(21, sClaves, sValues, ByRef r, i)
                        eContour.P.Add(CFloat(r) + eContour.P[1])
                        i = dxf.ReadCode(40, sClaves, sValues, ByRef r, i)
                        eContour.fParam.Add(CFloat(r))
                        i = dxf.ReadCode(50, sClaves, sValues, ByRef r, i)
                        eContour.fParam.Add(CFloat(r))

                        ' esto soluciona un proble de unidades de LibreCAD
                        If eContour.fParam[eContour.fParam.Max] > 2 * Pi Then
                            eContour.fParam[eContour.fParam.Max] /= (360 / 2 / Pi)
                        Endif

                        i = dxf.ReadCode(50, sClaves, sValues, ByRef r, i)
                        eContour.fParam.Add(CFloat(r))

                        ' esto soluciona un proble de unidades de LibreCAD
                        If eContour.fParam[eContour.fParam.Max] > 2 * Pi Then
                            eContour.fParam[eContour.fParam.Max] /= (360 / 2 / Pi)
                        Endif

                    Case 4 ' spline
                        ' 94 Degree
                        ' 73 Rational
                        ' 74 Periodic
                        ' 95 Number of knots
                        ' 96 Number of control points
                        ' 40 Knot values (multiple entries)
                        ' 10 Control point (in OCS) 20 Y value of control point (in OCS)
                        ' 42 Weights (optional, default = 1)
                        ' 97 Number of fit data
                        ' 11 Fit datum (in OCS) 21
                        ' 12 Start tangent 22
                        ' 13 End tangent 23
                        eContour = cadSPLine.NewEntity()
                        eContour.P.Clear
                        eContour.fParam.Clear
                        sp = eContour.pBlock

                        '                             ' COPIO Y PEGO DE CADSPLINE, CAMBIANDO LAS CLAVES
                        '
                        Inc i
                        i = dxf.ReadCodePlus(94, sClaves, sValues, ByRef sp.Degree, i)

                        i = dxf.ReadCodePlus(73, sClaves, sValues, ByRef sp.Periodic, i)
                        i = dxf.ReadCodePlus(74, sClaves, sValues, ByRef r, i)
                        If i > 0 Then sp.Periodic += CInt(r)

                        ' ignoro estos dos
                        i = dxf.ReadCodePlus(95, sClaves, sValues, ByRef r, i) 'numero de knots
                        sp.KnotValues.Resize(CInt(r))
                        i = dxf.ReadCodePlus(96, sClaves, sValues, ByRef r, i) ' numero de control points
                        sp.ControlPoints.Resize(CInt(r) * 2)
                        For i2 = 0 To sp.KnotValues.Max
                            i = dxf.ReadCodePlus(40, sClaves, sValues, ByRef r, i)
                            If i > 0 Then sp.KnotValues[i2] = CFloat(r)
                        Next
                        i = Abs(i)

                        ' por lo general hay fit points o controls points, pero no ambos, cargo lo que sea en P
                        ' Control points
                        For i2 = 0 To sp.ControlPoints.Count / 2 - 1
                            i = dxf.ReadCodePlus(10, sClaves, sValues, ByRef r, i)
                            sp.ControlPoints[i2 * 2] = CFloat(r)

                            i = dxf.ReadCodePlus(20, sClaves, sValues, ByRef r, i)
                            sp.ControlPoints[i2 * 2 + 1] = CFloat(r)

                        Next

                        Do
                            ip = i
                            i = dxf.ReadCodePlus(42, sClaves, sValues, ByRef r, i)
                            If i > 0 Then sp.Weigths.Add(CFloat(r))
                        Loop Until i <= 0
                        If i <= 0 Then i = ip

                        ' numero de Fit Points
                        ip = i
                        i = dxf.ReadCodePlus(97, sClaves, sValues, ByRef r, i)
                        If i <= 0 Then i = ip
                        If CInt(r) > 0 Then
                            Do
                                i = dxf.ReadCodePlus(11, sClaves, sValues, ByRef r, i)
                                If i > 0 Then sp.FitPoints.Add(CFloat(r))

                                i = dxf.ReadCodePlus(21, sClaves, sValues, ByRef r, i)
                                If i > 0 Then
                                    sp.FitPoints.Add(CFloat(r))
                                Else
                                    i = Abs(i)
                                    Break
                                End If
                            Loop
                        End If

                        ' tangentes, no se usan DXF
                        ip = i
                        i = dxf.ReadCodePlus(12, sClaves, sValues, ByRef r, i)
                        If i > 0 Then
                            sp.TangentInitial.Add(CFloat(r))
                            i = dxf.ReadCodePlus(22, sClaves, sValues, ByRef r, i)
                            sp.TangentInitial.Add(CFloat(r))
                        Else
                            If i <= 0 Then i = ip
                        End If

                        ip = i
                        i = dxf.ReadCodePlus(13, sClaves, sValues, ByRef r, i)
                        If i > 0 Then
                            sp.TangentFinal.Add(CFloat(r))
                            i = dxf.ReadCodePlus(23, sClaves, sValues, ByRef r, i)
                            sp.TangentFinal.Add(CFloat(r))
                        Else
                            If i <= 0 Then i = ip

                        End If

                End Select

                mySegments.Add(eContour, CStr(i))
            Next

        Else 'poly

            ' forma el contorno
            eContour = cadLWPolyline.NewEntity()
            eContour.P.Clear
            ' a esta entidad que es un borde le etiquetamos el loop al que pertenece

            ' Debug "PolyLine loop en un hatch"
            mySegments.Add(eContour)

            ' leo si tiene bulges
            i = dxf.ReadCodePlus(72, sClaves, sValues, ByRef r, i)

            If r = "1" Then ' tiene bulges
                eContour.iParam[cadLWPolyline.iiiBulged] = 1
            End If

            ' leo si es abierta o cerrada
            i = dxf.ReadCodePlus(73, sClaves, sValues, ByRef r, i)
            If r = "1" Then ' tiene bulges
                eContour.iParam[cadLWPolyline.iiiPolylineClosed] = 1
            End If

            ' numero de vertice
            i = dxf.ReadCodePlus(93, sClaves, sValues, ByRef r, i)
            eContour.P.Resize(CInt(r * 2))

            For iPoints = 0 To eContour.P.Count / 2 - 1

                i = dxf.ReadCodePlus(10, sClaves, sValues, ByRef r, i)
                eContour.P[iPoints * 2] = CFloat(r)

                i = dxf.ReadCodePlus(20, sClaves, sValues, ByRef r, i)
                eContour.P[iPoints * 2 + 1] = CFloat(r)

                ' ahora chequeo el bulge, que es opcional
                If sClaves[i] = "42" Then
                    eContour.fParam.Add(CFloat(sValues[i]))
                    i += 1
                Endif

            Next
            i = Abs(i)

        Endif
        '
        ' ' cuando termino de leer los datos del Edge, puede venir REference Boundary Object
        ' ' estas son las entidades de donde se obtuvo el contorno, puede ignrarse
        '
        ' If sClaves[i] = "97" Then
        '     For iBoundaryObject = 1 To CInt(sValues[i])
        '         Inc i
        '
        '         ' a esta entidad que es un borde le etiquetamos el loop al que pertenece
        '
        '         i = dxf.ReadCode(330, sClaves, sValues, ByRef RefObjHandle, i)
        '
        '         ' Podria guardar esta Handle, pero es totalmente redundante
        '         ' NewPath.sHandles.Add(RefObjHandle)
        '     Next
        ' End If
        '
        ' Continue
        '
        ' ' despues del loop hay un 97
        ' Inc i
        ' ' Objetos ecternos de borde
        ' If sClaves[i] = "97" Then
        '     For iBorderObjects = 0 To CInt(sValues[i]) - 1 ' los leo
        '         ' aca viene un Handle a un objeto que tambien es contorno pero no esta definido directamette en la entidad Hatch
        '         ' pero puede ocurrir que este objeto no este cargado aun en ningun lado porque su lectura no ocurrio
        '         ' TODO: verificar esto
        '
        '         Inc i
        '     Next
        ' Else
        '     'error de DXF
        '
        ' Endif
        ' 'Inc i

    Next

    i = dxf.ReadCodePlus(75, sClaves, sValues, ByRef e.fParam[Me.ipaParity], i, 76)
    i = dxf.ReadCodePlus(76, sClaves, sValues, ByRef e.fParam[Me.ipaPatternType], i, 98)

    If e.fParam[Me.ipaSolId] = 0 Then
        i = dxf.ReadCodePlus(52, sClaves, sValues, ByRef e.fParam[Me.ipaRotation], i, 98)
        i = dxf.ReadCodePlus(41, sClaves, sValues, ByRef e.fParam[Me.ipaScale], i, 98)

        i = dxf.ReadCodePlus(77, sClaves, sValues, ByRef nPattern, i, 78)

        i = dxf.ReadCodePlus(78, sClaves, sValues, ByRef nPattern, i, 98)

        For iPattern = 1 To nPattern
            oPattern = New Pattern
            e.pBlock.Patterns.Add(oPattern)
            i = dxf.ReadCode(53, sClaves, sValues, ByRef oPattern.AngleDeg, i)
            i = dxf.ReadCode(43, sClaves, sValues, ByRef oPattern.BaseX, i)
            i = dxf.ReadCode(44, sClaves, sValues, ByRef oPattern.BaseY, i)
            i = dxf.ReadCode(45, sClaves, sValues, ByRef oPattern.OffsetX, i)
            i = dxf.ReadCode(46, sClaves, sValues, ByRef oPattern.OffsetY, i)
            i = dxf.ReadCode(79, sClaves, sValues, ByRef Dashes, i)

            For iBorderObjects = 1 To Dashes

                i = dxf.ReadCode(49, sClaves, sValues, ByRef DashLength, i + 1)
                oPattern.DashLength.Add(DashLength)
            Next

        Next
    End If

    ' ahora viene el seed points
    i = dxf.ReadCodePlus(98, sClaves, sValues, ByRef nPattern, i)

    For iPattern = 1 To nPattern

        i = dxf.ReadCode(10, sClaves, sValues, ByRef fVar, i)
        e.pBlock.SeedPoints.Add(fVar)
        i = dxf.ReadCode(20, sClaves, sValues, ByRef fVar, i)
        e.pBlock.SeedPoints.Add(fVar)
    Next

    Return True

    ' catch

    Return False

LoopImport:

End

' Public Function ImportDXF2(e As Entity, sClaves As String[], sValues As String[]) As Boolean
'
'     Dim i, iPattern, iLoop, iPoints, iBorderObjects, iBoundaryObject As Integer
'     Dim LoopToRead As Integer
'     Dim LoopType As Integer
'     Dim EdgesToRead As Integer
'     Dim EdgeType As Integer
'     Dim eContour As Entity
'     Dim edge As Integer
'     Dim NewPath As Hatch
'     Dim oPattern As Pattern
'     ' Dim jscPath, vSeg As JSONCollection
'     Dim RefObjHandle As String
'     Dim DashLength, fVar As Float
'     Dim hData As Hatch
'     Dim Dashes As Integer
'     Dim sp As SPline
'     Dim r As String
'
'     ' vamos a agrupar las entidades que forman el contorno en un bloque
'     e.pBlock = New Hatch
'     NewPath = e.pBlock
'
'     NewPath.eSegments = New Entity[]
'     'NewPath.sHandles = New String[]
'
'     'If e.Handle = "567A1" Then Stop
'
'     'For i = 0 To sClaves.Max
'     i = -1
'     Do While i < sClaves.max    ' en este importador usare un do-loop en vez de un for-next por la complejidad del hatch
'         Inc i
'
'         If sClaves[i] = "91" Then
'             e.fParam[Me.ipaTotalLoops] = CFloat(sValues[i])
'             LoopToRead = e.fParam[Me.ipaTotalLoops]
'         End If
'
'         If LoopToRead > 0 Then
'
'             Inc i
'
'             ' para Debug
'             ' If LoopToRead = 21 Then Stop
'
'             For iLoop = 0 To LoopToRead - 1 'descubri que un Loop puede o no ser un area a rellenar distinta, a veces un Loop es un agujero de otro Loop
'
'                 ' NewPath = hData
'                 ' 'hData.Add(NewPath)
'                 '
'                 ' NewPath.eSegments = New Entity[]
'                 ' NewPath.sHandles = New String[]
'                 Dec LoopToRead
'                 ' estas claves definen el borde
'
'                 i = dxf.ReadCode(92, sClaves, sValues, ByRef LoopType, i)
'
'                 NewPath.Flag = LoopType
'                 ' If i = True Then Stop
'                 If (LoopType And 2) <> 2 Then ' otherwise is a polyline
'                     Inc i
'
'                     i = dxf.ReadCode(93, sClaves, sValues, ByRef EdgesToRead, i)
'                     If i = True Then Stop
'                     For edge = 0 To EdgesToRead - 1
'
'                         i = dxf.ReadCode(72, sClaves, sValues, ByRef EdgeType, i)
'                         If i = True Then Stop
'
'                         ' segun el tipo de edge, agrego una entidad al bloque que
'                         ' forma el contorno
'                         eContour = New Entity
'                         ' a esta entidad que es un borde le etiquetamos el loop al que pertenece
'
'                         NewPath.eSegments.Add(eContour, CStr(i))
'                         Select Case EdgeType
'                             Case 0  ' invalido
'
'                                 Stop
'
'                             Case 1 ' lines
'
'                                 eContour.Gender = cadLine.Gender
'                                 ' leo los dos puntos
'                                 Inc i
'                                 If sClaves[i] = "10" Then eContour.P.Add(CFloat(sValues[i]))
'                                 Inc i
'                                 If sClaves[i] = "20" Then eContour.P.Add(CFloat(sValues[i]))
'                                 Inc i
'                                 If sClaves[i] = "11" Then eContour.P.Add(CFloat(sValues[i]))
'                                 Inc i
'                                 If sClaves[i] = "21" Then eContour.P.Add(CFloat(sValues[i]))
'                             Case 2 ' arc o circle
'
'                                 eContour.Gender = cadArc.Gender
'                                 Inc i
'                                 If sClaves[i] = "10" Then eContour.P.Add(CFloat(sValues[i]))
'                                 Inc i
'                                 If sClaves[i] = "20" Then eContour.P.Add(CFloat(sValues[i]))
'                                 Inc i
'                                 If sClaves[i] = "40" Then eContour.fParam.Add(CFloat(sValues[i]))
'                                 Inc i
'                                 If sClaves[i] = "50" Then eContour.fParam.Add(CFloat(sValues[i]))
'                                 Inc i
'                                 If sClaves[i] = "51" Then eContour.fParam.Add(CFloat(sValues[i]))
'                                 Inc i
'                                 If sClaves[i] = "73" Then eContour.fParam.Add(CFloat(sValues[i]))
'                             Case 3 ' ellipse
'
'                                 eContour.Gender = cadEllipse.Gender
'                                 Inc i
'                                 If sClaves[i] = "10" Then eContour.P.Add(CFloat(sValues[i]))     ' centro
'                                 Inc i
'                                 If sClaves[i] = "20" Then eContour.P.Add(CFloat(sValues[i]))
'                                 Inc i
'                                 If sClaves[i] = "11" Then eContour.P.Add(CFloat(sValues[i]) + eContour.P[0])     ' eje mayor, relativo al centro
'                                 Inc i
'                                 If sClaves[i] = "21" Then eContour.P.Add(CFloat(sValues[i]) + eContour.P[1])
'                                 Inc i
'                                 If sClaves[i] = "40" Then eContour.fParam.Add(CFloat(sValues[i]))
'                                 Inc i
'                                 If sClaves[i] = "50" Then eContour.fParam.Add(Deg(CFloat(sValues[i])))
'
'                                 ' esto soluciona un proble de unidades de LibreCAD
'                                 If eContour.fParam[eContour.fParam.Max] > 2 * Pi Then
'                                     eContour.fParam[eContour.fParam.Max] /= (360 / 2 / Pi)
'                                 Endif
'                                 Inc i
'                                 If sClaves[i] = "51" Then eContour.fParam.Add(Deg(CFloat(sValues[i])))
'
'                                 ' esto soluciona un proble de unidades de LibreCAD
'                                 If eContour.fParam[eContour.fParam.Max] > 2 * Pi Then
'                                     eContour.fParam[eContour.fParam.Max] /= (360 / 2 / Pi)
'                                 Endif
'                             Case 4 ' spline
'                                 ' 94 Degree
'                                 ' 73 Rational
'                                 ' 74 Periodic
'                                 ' 95 Number of knots
'                                 ' 96 Number of control points
'                                 ' 40 Knot values (multiple entries)
'                                 ' 10 Control point (in OCS) 20 Y value of control point (in OCS)
'                                 ' 42 Weights (optional, default = 1)
'                                 ' 97 Number of fit data
'                                 ' 11 Fit datum (in OCS) 21
'                                 ' 12 Start tangent 22
'                                 ' 13 End tangent 23
'                                 eContour = cadSPLine.NewEntity()
'                                 sp = eContour.pBlock
'
'                                 '                             ' COPIO Y PEGO DE CADSPLINE, CAMBIANDO LAS CLAVES
'                                 '
'                                 Inc i
'                                 i = dxf.ReadCodePlus(94, sClaves, sValues, ByRef r, i)
'                                 If i > 0 Then sp.Degree = CInt(r)
'
'                                 i = dxf.ReadCodePlus(73, sClaves, sValues, ByRef r, i)
'                                 If i > 0 Then sp.Periodic = CInt(r)
'
'                                 i = dxf.ReadCodePlus(74, sClaves, sValues, ByRef r, i)
'                                 If i > 0 Then sp.Periodic += CInt(r)
'
'                                 ' ignoro estos dos
'                                 i = dxf.ReadCodePlus(95, sClaves, sValues, ByRef r, i)
'                                 i = dxf.ReadCodePlus(96, sClaves, sValues, ByRef r, i)
'
'                                 Do
'                                     i = dxf.ReadCodePlus(40, sClaves, sValues, ByRef r, i)
'                                     If i > 0 Then sp.KnotValues.Add(CFloat(r))
'                                 Loop Until i < 0
'                                 i = Abs(i)
'
'
'                                 ' por lo general hay fit points o controls points, pero no ambos, cargo lo que sea en P
'                                 ' Control points
'                                 Do
'                                     i = dxf.ReadCodePlus(10, sClaves, sValues, ByRef r, i)
'                                     If i > 0 Then
'                                         sp.ControlPoints.Add(CFloat(r))
'                                     Else
'                                         i = Abs(i)
'                                         Break
'                                     End If
'
'                                     i = dxf.ReadCodePlus(20, sClaves, sValues, ByRef r, i)
'                                     sp.ControlPoints.Add(CFloat(r))
'
'                                 Loop
'
'                                 Do
'                                     i = dxf.ReadCodePlus(42, sClaves, sValues, ByRef r, i)
'                                     If i > 0 Then sp.Weigths.Add(CFloat(r))
'                                 Loop Until i < 0
'                                 i = Abs(i)
'
'                                 ' numero de Fit Points
'                                 i = dxf.ReadCodePlus(97, sClaves, sValues, ByRef r, i)
'
'                                 If CInt(r) > 0 Then
'                                     Do
'                                         i = dxf.ReadCodePlus(11, sClaves, sValues, ByRef r, i)
'                                         If i > 0 Then sp.FitPoints.Add(CFloat(r))
'
'                                         i = dxf.ReadCodePlus(21, sClaves, sValues, ByRef r, i)
'                                         If i > 0 Then
'                                             sp.FitPoints.Add(CFloat(r))
'                                         Else
'                                             i = Abs(i)
'                                             Break
'                                         End If
'                                     Loop
'                                 End If
'
'
'                                 ' tangentes, no se usan DXF
'                                 i = dxf.ReadCodePlus(12, sClaves, sValues, ByRef r, i)
'                                 If i > 0 Then
'                                     sp.TangentInitial.Add(CFloat(r))
'                                     i = dxf.ReadCodePlus(12, sClaves, sValues, ByRef r, i)
'                                     sp.TangentInitial.Add(CFloat(r))
'                                 Else
'                                     i = Abs(i)
'                                 End If
'
'                                 i = dxf.ReadCodePlus(13, sClaves, sValues, ByRef r, i)
'                                 If i > 0 Then
'                                     sp.TangentFinal.Add(CFloat(r))
'                                     i = dxf.ReadCodePlus(13, sClaves, sValues, ByRef r, i)
'                                     sp.TangentFinal.Add(CFloat(r))
'                                 Else
'                                     i = Abs(i)
'
'                                 End If
'
'
'
'                         End Select
'                     Next
'
'                     ' cuando termino de leer los datos del Edge, puede venir REference Boundary Object
'                     ' estas son las entidades de donde se obtuvo el contorno, puede ignrarse
'                     Inc i
'                     If sClaves[i] = "97" Then
'                         For iBoundaryObject = 1 To CInt(sValues[i])
'                             Inc i
'
'                             ' a esta entidad que es un borde le etiquetamos el loop al que pertenece
'
'                             i = dxf.ReadCode(330, sClaves, sValues, ByRef RefObjHandle, i)
'
'                             ' Podria guardar esta Handle, pero es totalmente redundante
'                             ' NewPath.sHandles.Add(RefObjHandle)
'                         Next
'                     End If
'
'                     Continue
'
'                 Else ' read the polyline loop
'                     ' forma el contorno
'                     eContour = cadLWPolyline.NewEntity()
'                     ' a esta entidad que es un borde le etiquetamos el loop al que pertenece
'
'                     ' Debug "PolyLine loop en un hatch"
'                     NewPath.eSegments.Add(eContour)
'
'                     Inc i
'                     ' leo si tiene bulges
'                     If sClaves[i] = "72" Then
'                         If sValues[i] = "1" Then ' tiene bulges
'                             eContour.iParam[cadLWPolyline.iiiBulged] = 1
'                         End If
'                     Else
'                         'error de DXF
'                         Stop
'                     Endif
'
'                     Inc i
'                     ' leo si es abierta o cerrada
'                     If sClaves[i] = "73" Then
'                         If sValues[i] = "1" Then ' cerrada
'                             eContour.iParam[cadLWPolyline.iiiPolylineClosed] = 1
'                         End If
'                     Else
'                         'error de DXF
'                         Stop
'                     Endif
'
'                     Inc i
'                     ' numero de vertice
'                     If sClaves[i] = "93" Then
'                         eContour.P.Resize(CInt(sValues[i] * 2))
'                     Else
'                         'error de DXF
'
'                     Endif
'
'                     For iPoints = 0 To eContour.P.Count / 2 - 1
'                         Inc i
'                         eContour.P[iPoints * 2] = CFloat(sValues[i])
'                         Inc i
'                         eContour.P[iPoints * 2 + 1] = CFloat(sValues[i])
'                         If eContour.iParam[cadLWPolyline.iiiBulged] Then
'                             Inc i ' ignoro el bulge
'                         Endif
'                     Next
'
'                     ' If eContour.iParam[cadLWPolyline.iiiPolylineClosed] = 1 Then
'                     '   eContour.P.Add(eContour.P[0])
'                     '   eContour.P.Add(eContour.P[1])
'                     '
'                     ' Endif
'
'                 Endif
'                 ' despues del loop hay un 97
'                 Inc i
'                 ' Objetos ecternos de borde
'                 If sClaves[i] = "97" Then
'                     For iBorderObjects = 0 To CInt(sValues[i]) - 1 ' los leo
'                         ' aca viene un Handle a un objeto que tambien es contorno pero no esta definido directamette en la entidad Hatch
'                         ' pero puede ocurrir que este objeto no este cargado aun en ningun lado porque su lectura no ocurrio
'                         ' TODO: verificar esto
'
'                         Inc i
'                     Next
'                 Else
'                     'error de DXF
'
'                 Endif
'                 'Inc i
'
'             Next
'
'         End If
'         If sClaves[i] = "2" Then e.sParam[Me.sdaPattern] = sValues[i] ' hach file
'
'         If sClaves[i] = "70" Then e.fParam[Me.ipaSolid] = CFloat(sValues[i])
'         If sClaves[i] = "71" Then e.fParam[Me.ipaAsociativity] = CFloat(sValues[i])
'         If sClaves[i] = "72" Then e.fParam[Me.ipaBoundaryType] = CFloat(sValues[i])
'
'         If sClaves[i] = "52" Then e.fParam[Me.ipaRotation] = CFloat(sValues[i])
'         If sClaves[i] = "41" Then
'             e.fParam[Me.ipaScale] = CFloat(sValues[i])
'
'         End If
'         If sClaves[i] = "75" Then e.fParam[Me.ipaParity] = CFloat(sValues[i])
'         If sClaves[i] = "76" Then e.fParam[Me.ipaPatternType] = CFloat(sValues[i])
'
'         ' ahora viene el pattern data
'         If sClaves[i] = "78" Then
'             For iPattern = 1 To sValues[i]
'                 oPattern = New Pattern
'                 e.pBlock.Patterns.Add(oPattern)
'                 i = dxf.ReadCode(53, sClaves, sValues, ByRef oPattern.AngleDeg, i)
'                 i = dxf.ReadCode(43, sClaves, sValues, ByRef oPattern.BaseX, i)
'                 i = dxf.ReadCode(44, sClaves, sValues, ByRef oPattern.BaseY, i)
'                 i = dxf.ReadCode(45, sClaves, sValues, ByRef oPattern.OffsetX, i)
'                 i = dxf.ReadCode(46, sClaves, sValues, ByRef oPattern.OffsetY, i)
'                 i = dxf.ReadCode(79, sClaves, sValues, ByRef Dashes, i)
'
'                 For iBorderObjects = 1 To Dashes
'
'                     i = dxf.ReadCode(49, sClaves, sValues, ByRef DashLength, i + 1)
'                     oPattern.DashLength.Add(DashLength)
'                 Next
'
'             Next
'         End If
'
'         ' ahora viene el seed points
'         If sClaves[i] = "98" Then
'             For iPattern = 1 To sValues[i]
'
'                 i = dxf.ReadCode(10, sClaves, sValues, ByRef fVar, i)
'                 e.pBlock.SeedPoints.Add(fVar)
'                 i = dxf.ReadCode(20, sClaves, sValues, ByRef fVar, i)
'                 e.pBlock.SeedPoints.Add(fVar)
'             Next
'
'         End If
'     Loop
'
'
'     Return True
'
'     ' catch
'
'     Return False
'
' LoopImport:
'
' End
'

Public Sub ExportDXFCol(e As Entity, ByRef stxExport As String[]) As Boolean

    Dim h As Hatch
    Dim t As Float

    h = e.pBlock

    ' stxExport.insert(["INSERT", dxf.codEntity])
    ' Los datos comunes a todas las entidades son guardados por la rutina que llama a esta
    stxExport.insert(["AcDbHatch", "100"])                          'sub class

    stxExport.insert([CStr(e.p[0]), dxf.codX0])                     ' elevation point
    stxExport.insert([CStr(e.p[1]), dxf.codY0])
    stxExport.insert(["0", dxf.codZ0])

    stxExport.insert(["0", "210"])                                   ' plano de extrusion
    stxExport.insert(["0", "220"])
    stxExport.insert(["1", "230"])

    stxExport.insert([e.sParam[0], "2"])                              ' nombre del hatch

    ' Indicador de relleno s ólido (relleno sólido = 1; relleno de patrón = 0); para polígonoM, la versión de polígonoM
    If UCase(e.sParam[0]) = "SOLID" Then
        stxExport.insert(["1", "70"])
    Else
        stxExport.insert(["0", "70"])
    End If

    ' 63 Para pol ígonoM, color de relleno de patrón como ACI

    stxExport.insert(["1", "71"])                                    'indicador de asociatividad(asociativo = 1; no asociativo = 0); para pol ígonoM, indicador de relleno sólido (con relleno sólido = 1; sin relleno sólido = 0)

    '-------------------CONTORNO-----------------------------------------------------------------------------------
    stxExport.insert([e.pBlock.PolyLines.count, "91"])                  'Número de rutas de contorno (bucles)

    ' Indicador de tipo de ruta de contorno(codificado en bits): 0 = Valor por defecto; 1 = Externo; 2 = Polilínea 4 = Derivado; 8 = Cuadro de texto; 16 = Exterior
    Dim poly As Float[]
    Dim i As Integer
    For Each poly In h.Polylines
        stxExport.insert([2, "92"])                                     ' de momento solo vamos a generar contornos de polys
        stxExport.insert(["0", "72"])                                   ' Indicador de curvatura

        stxExport.insert(["1", "73"])                                   ' Indicador de cerrada (en gcad son todas cerradas)
        stxExport.insert([poly.Count / 2, "93"])                        ' Número de vértices de la polilínea, /2 porque es 2D

        For i = 0 To poly.Max Step 2
            stxExport.insert([poly[i], "10"])
            stxExport.insert([poly[i + 1], "20"])
        Next
    Next

    '--------------------SOMBREADO--------------------------------------------------------------------------

    stxExport.insert(["0", "75"])   ' Estilo de sombreado:
    '   0 = Sombrear el área de “paridad impar” (estilo Normal)
    '   1 = Sombrear s ólo las áreas más externas estilo Exterior)
    '   2 = Sombrear el área completa (estilo Ignorar)

    stxExport.insert(["1", "76"])   ' Tipo de patrón de sombreado: 0 = Definido por el usuario; 1 = Predefinido; 2 = Personalizado

    stxExport.insert([E.fParam[cadHatch.ipaRotation], "52"])   ' Ángulo de patrón de sombreado (sólo relleno de patrón)
    stxExport.insert([E.fParam[cadHatch.ipaRotation], "41"])   ' Escala o intervalo de patr ón de sombreado (sólo relleno de patrón)

    stxExport.insert(["0", "77"]) ' Indicador de patrón de sombreado doble (sólo relleno de patrón): 0 = no es doble; 1 = es doble

    stxExport.insert([h.Patterns.Count, "78"])   'El número de líneas de definición de patrón

    Dim pat As Pattern
    If h.Patterns.Count > 0 Then
        For Each pat In h.Patterns
            stxExport.insert([pat.AngleDeg, "53"])              ' Ángulo de línea de patrón
            stxExport.insert([pat.BaseX, "43"])                 ' Punto base de línea de patrón, componente X
            stxExport.insert([pat.BaseY, "44"])                 ' Punto base de línea de patrón, componente Y
            stxExport.insert([pat.OffsetX, "45"])               ' Offset, componente X
            stxExport.insert([pat.OffsetY, "46"])               ' Offset, componente Y
            stxExport.insert([pat.DashLength.Count, "79"])      ' Nro de trazos
            For Each t In pat.DashLength
                stxExport.insert([t, "49"])
            Next
        Next

        ' -----------seed----------------------------------------
        stxExport.insert([1, "98"])   'El número de puntos base
        stxExport.insert([pat.BaseX, "10"])   'X
        stxExport.insert([pat.BaseY, "20"])   'Y
    End If

End

'' Return if that position is over the entity within the tolerance
Public Function OverMe(e As Entity, Xr As Float, Yr As Float, tolerance As Float) As Boolean

    Dim oBound As Float[]

    For Each oBound In e.pBlock.Polylines

        If puntos.PointOverPolyLine([xr, yr], oBound, tolerance) Then Return True

    Next

    Return False

End

'' Procesa las entidades de borde y las trnasforma en polilineas cerradas, que pueden estar una dentro de otra
'Fast Unsafe
Public Sub MakeBorder2(oPath As Hatch)

    Dim eBorder, eFind As Entity
    Dim borders As Entity[]
    Dim drwPath As New Float[]
    Dim i As Integer
    Dim FirstX, FirstY As Single
    Dim FirstPointSet As Boolean = False
    Dim BoundaryGotClosed As Boolean = False

    oPath.Polylines.Clear
    oPath.Levels.Clear

    ' armo ese contorno
    For Each borders In oPath.eSegments

        ' todas estas entidades forman parte del mismo contorno
        For Each eBorder In borders

            If Not eBorder Then Continue 'por si es Null

            If eBorder.Gender = "" Then
                ' eFind = gcd.FindEntity(eborder.Handle, True)
                ' If IsNull(eFind) Then
                '
                Debug "Borde de hatch no encntrado", eborder.Id
                Continue
                Stop
                '
                ' Else
                '   eborder = eFind
                ' End If
            End If
            Select Case eBorder.gender

                Case cadLWPolyline.Gender
                    drwPath.Insert(eborder.P.Copy())

                    FirstX = drwPath[0]
                    FirstY = drwPath[1]

                Case "ARC", "CIRCLE", "ELLIPSE", "SPLINE" 'TODO: separar esto
                    ' If eborder.iParam[0] = 0 Then ' el arco es contrareloj, pero asi armo la poly asi que no hago nada
                    '     Swap eborder.fParam[1], eborder.fParam[2]
                    ' End If
                    Gcd.CCC[eBorder.gender].MakePolyline(eborder)

                    drwPath.Insert(eborder.PolyLine.Copy())

                    FirstX = drwPath[0]
                    FirstY = drwPath[1]

                Case "TEXT", "MTEXT"

                    drwPath.Insert(eborder.Polygon.Copy())

                    FirstX = drwPath[0]
                    FirstY = drwPath[1]

                Case "LINE"

                    If Not FirstPointSet Then
                        drwPath.Insert(eborder.P.Copy())

                        FirstX = eborder.P[0]
                        FirstY = eborder.P[1]
                        FirstPointSet = True

                    Else
                        drwPath.Insert(eborder.P.Copy(2, 2))
                    End If

            End Select

        Next

        If drwPath.Count > 0 Then
            ' verifico que este cerrado
            If (drwPath[0] <> drwPath[drwPath.Max - 1]) Or (drwPath[1] <> drwPath[drwPath.Max]) Then ' le agrego

                drwPath.Add(drwPath[0])
                drwPath.Add(drwPath[1])
            End If

            oPath.Polylines.add(drwPath)
        End If
        drwPath = New Float[]
        FirstPointSet = False

    Next

    '========================NEW===========================
    ' ahora ordeno los contornos

    Dim Changes As Boolean = False
    Dim i2 As Integer

    ' incializo los indices
    For i = 0 To oPath.Polylines.Max
        oPath.Levels.add(1)
    Next

    Do
        Changes = False
        For i = 0 To oPath.Polylines.Max
            For i2 = 0 To oPath.Polylines.Max
                If i = i2 Then Continue
                If puntos.isInsIdePolygons(oPath.Polylines[i], oPath.Polylines[i2]) Then
                    If Abs(oPath.Levels[i]) <= oPath.Levels[i2] Then
                        Changes = True
                        oPath.Levels[i] = (Abs(oPath.Levels[i2]) + 1) * -1 * Sgn(oPath.Levels[i2])
                    Endif
                Endif
            Next
        Next
    Loop Until Not Changes
    Return

End

Public Sub GetBoundLimits2(fxlPoints As Float[])

    Dim i As Integer

    For i = 0 To fxlPoints.max Step 2

        If fxlPoints[i] < Xmenor Then Xmenor = fxlPoints[i]

        If fxlPoints[i + 1] < Ymenor Then Ymenor = fxlPoints[i + 1]

        If fxlPoints[i] > Xmayor Then Xmayor = fxlPoints[i]

        If fxlPoints[i + 1] > Ymayor Then Ymayor = fxlPoints[i + 1]

    Next

End

'Fast Unsafe
Public Sub FillEntityWithHatch4(entToFill As Entity)    ' Apto para rotaciones

    ' reeleno usando un pattern manual
    ' https://knowledge.autodesk.com/support/autocad-lt/learn-explore/caas/CloudHelp/cloudhelp/2018/ENU/AutoCAD-LT/files/GUID-79B99823-7600-4CAB-BD12-04D5103D90CB-htm.html

    ' Parametros de la entidad:

    ' P[]:        son los puntos de la polilinea que define el contorno del sombreado
    ' fParam[0]:  escala del sombreado
    ' fParam[1]:  angulo
    ' StringData[0]: nombre del patron del sombreado

    Dim e As Entity
    Dim fPAtternSIde, fDashTotal, fDistance As Float
    Dim iPatternOffset, iPatternN As Integer
    Dim nx As Integer
    Dim ny As Integer
    Dim ie, i, AlPedo, Sirve, nTrames As Integer
    Dim flxBaseLine, flxOffset, flxBase, flxTrimmedLine, flxPatternLimits, flxContorno, flxFirstPass, flxSecondPass, flxPatternLines, flxDashes, flxInter As New Float[]
    Dim iLoop As Integer
    Dim enxPattern As New Collection
    Dim cPattern As New Collection
    Dim drwPattern As New Drawing
    Dim enxPatternScaled As New Collection
    Dim eBorder As Entity
    Dim sPAtternFile As String
    Dim oPat As Pattern
    Dim EsUtil, NoMoreIntersections, MeAlejo, Filled, UseAxisX As Boolean
    Dim OffsetDirection As Integer = 1
    Dim mX, mY, dX, dY, BaseX, BaseY, Check, StartX, StartY, FinalX, FinalY, TanA, DashLength, DashTrame As Float
    Dim Scale, DashBaseX, DashBaseY, DashFinalX, DashFinalY As Float
    Dim A1, A2, DeltaX, DeltaY, SeedX, SeedY, SeedIndex, CosB, SinB As Float
    Dim Mucho, MuchoViejo As Float
    Dim Xcg, Ycg, DistCg, DistCgOld As Float
    Dim d1, d2, ox, oy, bx, by, fOffset As Float
    Dim OyMax, OxMax As Float
    ' este valor intenta commpensar un problema de compatibilidad entre DWG y DXF
    ' para estar de acuerdo a LibreCAD, debe ser =1, pero algunos DWG se represetan
    ' con una densidad de relleno menor (mas disperso el relleno)
    Dim CorrectionScale As Float = 1 '0.01 ' 0.1
    Dim iHatchLinesDrawn As Integer

    Dim bInvert As Boolean = False    ' TODO ver como hacer andar esto

    If entToFill.fParam[Gcd.CCC["HATCH"].ipaScale] = 0 Then
        entToFill.fParam[Gcd.CCC["HATCH"].ipaScale] = 1
    Else
        ''entToFill.fParam[Gcd.CCC["HATCH"].ipaScale] /= 12  ' TODO: verificar esta escala
    Endif

    'For Each oLoop In entToFill.pBlock

    'If entToFill.id = "45ED" Then Stop
    'If entToFill.StringData[0] = "ANSI31" Then Stop
    'If entToFill.sParam[0] = "GRAVEL" Then Return 'entToFill.Colour = 2

    'If entToFill.sParam[0] = "STARS" Then Stop 'entToFill.Colour = 2

    'If ((entToFill.Flag And 1) = 1) Or (entToFill.Flag = 0) Then ' es external, o sea lo que esta afuera de todo

    If entToFill.pBlock.Polylines.Count = 0 Then Return

    ' veo los limites del contorno exterior
    Xmenor = 1e10
    Ymenor = 1e10
    Xmayor = -1e10
    Ymayor = -1e10

    ' obtengo los limites
    For Each flxContorno In entToFill.pBlock.Polylines
        GetBoundLimits2(flxContorno)
    Next

    ' Calculo el CG
    Xcg = (Xmayor + Xmenor) / 2
    Ycg = (Ymayor + Ymenor) / 2
    If (Xmayor - Xmenor) > (Ymayor - Ymenor) Then
        Mucho = (Xmayor - Xmenor) * 2
    Else
        Mucho = (Ymayor - Ymenor) * 2
    Endif

    If entToFill.pBlock.Patterns.count = 0 Then Return

    DeltaX = Xcg - entToFill.pBlock.Patterns[0].BaseX
    DeltaY = ycg - entToFill.pBlock.Patterns[0].BaseY

    Scale = entToFill.fParam[Me.ipaScale]
    Scale = 1                                   ' La escala ya esta aplicada, pero aqui podriamos corregir

    ' ya tenemos las lineas del pattern, las hacemos intersectar con el contorno
    For Each flxContorno In entToFill.pBlock.Polylines
        Utils.DoEvents(10)
        If entToFill.pBlock.Levels[SeedIndex] < 0 Then Continue ' es un hole

        If flxContorno.Count < 6 Then Continue          ' este borde es nulo

        For Each oPat In entToFill.pBlock.Patterns

            iHatchLinesDrawn = 0
            NoMoreIntersections = False
            OffsetDirection = 1
            iPatternOffset = 0

            ' el angulo de la linea del patron ya tiene incorporado el angulo general del hatch

            CosB = Cos(Rad(oPat.AngleDeg))
            SinB = Sin(Rad(oPat.AngleDeg))

            DistCg = 1e100

            Do
                EsUtil = False

                'If iPatternOffset > 1e3 Then Break 'Stop

                ' el Offset entre lineas del patron ya tiene incorporado el angulo del hatch
                BaseX = DeltaX + oPat.BaseX + iPatternOffset * OffsetDirection * oPat.OffsetX
                BaseY = DeltaY + oPat.BaseY + iPatternOffset * OffsetDirection * oPat.OffsetY

                'Debug baseX, BaseY

                StartX = BaseX - cosB * mucho
                StartY = BaseY - SinB * Mucho

                FinalX = BaseX + CosB * Mucho
                FinalY = BaseY + SinB * Mucho

                Inc iPatternOffset

                ' TEST: para ver si los dashed son el problema, descomentar la siguientes lineas
                'oPat.DashLength.Clear
                'If puntos.PointToLineDistance([186.34, 558.75], [BaseX, baseY, FinalX, FinalY]) < 0.1 Then Stop
                ' PARTE 1

                ' La linea recortada al contorno es (OJO, esto puede ser un conjunto de lineas):
                flxTrimmedLine = puntos.LinePolyIntersection([BaseX, baseY, FinalX, FinalY], flxContorno)

                If flxTrimmedLine.Count > 0 Then
                    'If flxTrimmedLine.Count > 4 Then Stop
                    EsUtil = True

                    Inc iHatchLinesDrawn
                    If oPat.DashLength.Count = 0 Then ' es una linea recta
                        flxFirstPass.Insert(flxTrimmedLine.Copy())

                    Else ' armo los dashes y despue los recorto al contorno
                        'fOffset = puntos.distancia(startX, starty, basex, basey)
                        d1 = puntos.distancia(baseX, basey, flxTrimmedLine[0], flxTrimmedLine[1])
                        'd2 = fOffset + puntos.distancia(startX, starty, flxTrimmedLine[flxTrimmedLine.Max - 1], flxTrimmedLine[flxTrimmedLine.Max])
                        If d1 <= d2 Then

                            'bInvert = False
                            fOffset = 0'd1
                            'Debug "Normal"
                        Else
                            'bInvert = True
                            fOffset = 0'd2
                            'Debug "Invert"
                        End If
                        fOffset = d1
                        flxDashes = puntos.DashedLineStrip(flxTrimmedLine, oPat.DashLength,, fOffset, bInvert, True)
                        'Debug fOffset 'baseX, BaseY
                        flxFirstPass.Insert(flxDashes)
                    End If
                End If
                ' PARTE 2
                'If iHatchLinesDrawn = 265 Then Stop
                ' La linea recortada al contorno es (OJO, esto puede ser un conjunto de lineas):
                flxTrimmedLine = puntos.LinePolyIntersection([BaseX, baseY, startX, startY], flxContorno)
                ' If flxTrimmedLine.Count >= 2 Then
                '     If (puntos.distancia(flxTrimmedLine[flxTrimmedLine.Max - 1], flxTrimmedLine[flxTrimmedLine.Max], 190.0095, 552.2092) < 0.1) Or (puntos.distancia(flxTrimmedLine[0], flxTrimmedLine[1], 190.0095, 552.2092) < 0.1) Then
                '         Stop
                '
                '
                '         Goto QuitFill
                '     End If
                ' End If
                If flxTrimmedLine.Count > 0 Then
                    'If flxTrimmedLine.Count > 4 Then Stop
                    EsUtil = True

                    Inc iHatchLinesDrawn
                    If oPat.DashLength.Count = 0 Then ' es una linea recta
                        flxFirstPass.Insert(flxTrimmedLine.Copy())

                    Else ' armo los dashes y despue los recorto al contorno
                        'fOffset = puntos.distancia(startX, starty, basex, basey)
                        d1 = puntos.distancia(baseX, basey, flxTrimmedLine[0], flxTrimmedLine[1])
                        'd2 = fOffset + puntos.distancia(startX, starty, flxTrimmedLine[flxTrimmedLine.Max - 1], flxTrimmedLine[flxTrimmedLine.Max])
                        If d1 <= d2 Then

                            'bInvert = False
                            fOffset = 0'd1
                            'Debug "Normal"
                        Else
                            'bInvert = True
                            fOffset = 0'd2
                            'Debug "Invert"
                        End If
                        fOffset = d1
                        flxDashes = puntos.DashedLineStrip(flxTrimmedLine, oPat.DashLength,, fOffset, True, True)
                        'Debug fOffset 'baseX, BaseY
                        flxFirstPass.Insert(flxDashes)
                    End If

                End If

                If Not EsUtil Then
                    'RUTINA DE VERIFICACION PARA VER SI SIGO TRAZANDO EN ESTA DIRECCION

                    DistCgOld = DistCg
                    DistCg = Abs(puntos.PointToLineDistance([Xcg, Ycg], [StartX, StartY, FinalX, FinalY]))
                    If DistCg > DistCgOld Then MeAlejo = True Else MeAlejo = False

                End If

                If MeAlejo Then
                    If OffsetDirection = 1 Then
                        OffsetDirection = -1
                        iPatternOffset = 1
                        DistCg = 1e100
                        MeAlejo = False

                    Else
                        NoMoreIntersections = True
                        MeAlejo = False
                    Endif
                End If
                'End If

                '
            Loop Until NoMoreIntersections
            'Next

        Next    ' Patterns
        Inc SeedIndex
    Next    ' contorno
    'If entToFill.PolyLine.Count = 0 Then Stop
    'entToFill.PolyLine.Insert(flxFirstPass.Copy())

    ' HASTA ACA LLEGO BIEN, CON EL CONTORNO PPAL LLENO

    ' https://ezdxf.readthedocs.io/en/stable/dxfentities/hatch.html
    ' Boundary Paths
    ' The hatch entity is build by different functional path types, this are filter flags for the Hatch.dxf.hatch_style:
    '
    ' EXTERNAL: defines the outer boundary of the hatch
    ' OUTERMOST: defines the first tier of inner hatch boundaries
    ' DEFAULT: default boundary path
    ' As you will learn in the next sections, these are more the recommended usage type for the flags, but the fill algorithm doesn’t care much about that, for instance an OUTERMOST path doesn’t have to be inside the EXTERNAL path.

    'limpio los huecos
    'Else If (entToFill.Flag And 16) = 16 Then ' es outermost
QuitFill:

    SeedIndex = -1
    Filled = False
    entToFill.PolyLine.Clear
    For Each flxContorno In entToFill.pBlock.Polylines
        Inc SeedIndex
        If entToFill.pBlock.Levels[SeedIndex] > 0 Then Continue ' es un borde

        Filled = True

        For i = 0 To flxFirstPass.Max - 3 Step 4
            entToFill.PolyLine.Insert(puntos.LineholeIntersection(flxFirstPass.Copy(i, 4), flxContorno))

        Next

    Next

    If Not Filled Then entToFill.PolyLine.Insert(flxFirstPass.Copy())

End
