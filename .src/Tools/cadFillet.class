' Gambas class file

' GauchoCAD
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA

Inherits ToolsBase
Public Const Gender As String = "Fillet"

Public EntityForEdit As Entity
Public iEntity1 As Integer
Public iEntity2 As Integer
Public GripPoint As Integer = -1
Public dX As Float
Public dY As Float
Public Radious As Float

Public Function Start(Optional ElemToBuild As Variant, Optional _Mode As Integer = 0) As Boolean
  ' Modes:
  '       0 = Move, all points in the element must be selected, or click on it.
  '       1 = Stretch, selection may be partial, each element is called to see if the support stretching

  Me.Mode = _Mode
  Me.PointsDone = 0
  Me.PointsTotal = 3
  Me.PoiChecking = False
  Me.EntityChecking = True

  Try Me.Radious = gcd.CurrentDrawing.cModel["Vars"]["FilletRadious"]

  If Me.Radious = 0 Then Me.Radious = 1

  clsDrawingAids.HelperTrabajo = "Fillet: " & ("enter radious") & "[" & Str(Me.Radious) & "]"

  clsEntities.DeSelection()           ' elimino cualquier seleccion previa

End

Public Function KeyText(EnteredText As String) ' esta rutina es llamada por FCAD en el evento FCAD_KeyPress cuando recibe una texto + <Enter>

  If Me.PointsDone = 0 Then       ' introduciendo el radio

    Try Me.Radious = Val(EnteredText)

    If Me.Radious = 0 Then
      clsDrawingAids.ErrorMessage = ("Bad input")
    Else
      clsDrawingAids.HelperTrabajo = ("Select first line")
      Me.PointsDone = 1
    End If
  End If

End

Public Function MouseDown(mouseX As Integer, mouseY As Integer) ' esta rutina es llamada por FCAD en el evento DrawingArea_MouseDown

  Dim i As Integer

  GripPoint = -1
  Me.SelStartX = mouseX
  Me.SelStartY = mouseY
  Me.SelStartXr = AppMain.Xreal(Me.SelStartX)
  Me.SelStartYr = AppMain.Yreal(Me.SelStartY)

  dX = Me.SelStartXr
  dY = Me.SelStartYr

  Me.SelEndX = Me.SelStartX
  Me.SelEndy = Me.SelStartY

  Me.SelEndXr = Me.SelStartXr
  Me.SelEndyr = Me.SelStartYr

  Me.PoiChecking = False

  If Me.PointsDone = 1 Then       ' estamos seleccionando la primer entidad

    If Mouse.Left Then

      If gcd.CurrentDrawing.iEntity[3] >= 0 Then                         ' 1.1.2 el mouse no esta enganchado, pero esta arriba de una entidad

        Me.iEntity1 = gcd.CurrentDrawing.iEntity[3]
        clsEntities.SelectElem(gcd.CurrentDrawing.iEntity[3])                 '   -> la selecciono
        clsDrawingAids.HelperTrabajo = ("Select second line")
        Me.PointsDone = 2
        AppMain.SelectionRefresh()
        Me.Active = False
        clsEntities.GLGenDrawListSel(0)

      Else

        Me.Active = True
      End If
    End If
  Else If Me.PointsDone = 2 Then       ' estamos seleccionando la segunda entidad
    If Mouse.Left Then

      If (gcd.CurrentDrawing.iEntity[3] >= 0) And (Me.iEntity1 <> gcd.CurrentDrawing.iEntity[3]) Then

        Me.iEntity2 = gcd.CurrentDrawing.iEntity[3]
        DoFillet
        Me.Active = False

      Else

        Me.Active = True
      End If
    End If

  End If

End

Public Function MouseUp(mouseX As Integer, mouseY As Integer) ' esta rutina es llamada por FCAD en el evento DrawingArea_MouseUp

  Me.SelEndX = mousex
  Me.SelEndy = mouseY

  If Me.Active Then
    Dim Crossing As Boolean = False
    ' corrijo para start<end
    Me.Active = False
    Me.PoiChecking = True
    If Me.SelStartX > Me.SelEndX Then
      crossing = True
      Swap Me.SelStartX, Me.SelEndX
    Else
      crossing = False
    End If
    If Me.SelStartY < Me.SelEndy Then Swap Me.SelStartY, Me.SelEndy                     ' this is FLIPPED

    ' Paso a coordenadas reales
    Me.SelStartXr = AppMain.Xreal(Me.SelStartX)
    Me.SelStartYr = AppMain.Yreal(Me.SelStartY)
    Me.SelEndXr = AppMain.Xreal(Me.SelEndX)
    Me.SelEndyr = AppMain.Yreal(Me.SelEndy)

    ' veo si el rectangulo es suficientemente grande como para representar una seleccion por rectangulo
    If (Me.SelEndX - Me.SelStartX + (-Me.SelEndy + Me.SelStartY)) > 10 Then

      Dim t As Float = Timer
      Me.selectionCount = clsEntities.SelectionSquare(Me.SelStartXr, Me.SelStartYr, Me.SelEndXr, Me.SelEndyr,, crossing)
      Debug "Select parsing time ", Timer - t

      clsEntities.GLGenDrawListSel(0)
      AppMain.SelectionRefresh()

    End If

  End If

End

Public Function MouseMove(mouseX As Integer, mouseY As Integer) ' esta rutina es llamada por FCAD en el evento DrawingArea_MouseMove

  Me.SelEndX = mouseX
  Me.SelEndy = mouseY
  Me.SelEndXr = AppMain.Xreal(Me.SelEndX)
  Me.SelEndyr = AppMain.Yreal(Me.SelEndy)

  If Me.Active Then

    appmain.redraw
  End If

End

Public Sub Draw() ' esta rutina es llamada por FCAD en el evento DrawingArea_Draw
  ' por ultimo, y para que se vea arriba, la seleccion

  If Me.Active Then

    If Me.SelStartX > Me.SelEndX Then                               ' Seleccion crossing, o sea que si cualquier arista del rectangulo cruza el bounding poligon, queda seleccionado

      GLplus.Rectangle2D(Me.SelStartXr, Me.SelStartYr, Me.SelEndXr - Me.SelStartXr, Me.SelEndyr - Me.SelStartYr, Color.RGB(224, 220, 207, 215),,,, Color.red, 1, 1, 2)

    Else                                                            ' seleccion full, todos los puntos deben estar adentro

      GLplus.Rectangle2D(Me.SelStartXr, Me.SelStartYr, Me.SelEndXr - Me.SelStartXr, Me.SelEndyr - Me.SelStartYr, Color.RGB(224, 220, 207, 215),,,, Color.Green, 1, 1, 2)

    End If
  Else

    ' gl.CallList(gcd.CurrentDrawing.GlListSelectedEntities)
    ' clsEntities.DrawPoiSymbolsAll

  End If

End

Public Function DoFillet() As Boolean

  Dim e1 As Entity
  Dim e2 As Entity
  Dim d, m1, m2, angle As Float
  Dim flxIntersec As New Float[]
  Dim hr1 As Float
  Dim I2x, I2y, Cx, Cy, T1x, T1y, T2x, T2y As Float
  Dim l1, l2, lc, lc2 As Float
  Dim alpha, StartAngle As Float
  Dim EndAngle As Float

  ' intenta hacer el fillet entre las dos entidades seleccionadas, devuelve True si tiene exito
  e1 = gcd.CurrentDrawing.arrEntities[Me.iEntity1]
  e2 = gcd.CurrentDrawing.arrEntities[Me.iEntity2]

  Select Case e1.Gender
    Case "Line"
      Select Case e2.Gender
        Case "Line"
          ' determino el punto de interseccion de ambas lineas
          flxIntersec = puntos.lineLineIntersection([e1.P[0], e1.P[1]], [e1.P[2], e1.P[3]], [e2.P[0], e2.P[1]], [e2.P[2], e2.P[3]])
          ' ahora veo cual punto de los dos esta mas lejos de la interseccion
          ' linea 1
          If puntos.distancia(e1.P[0], e1.P[1], flxIntersec[0], flxIntersec[1]) >= puntos.distancia(e1.P[2], e1.P[3], flxIntersec[0], flxIntersec[1]) Then
            e1.P[2] = flxIntersec[0]
            e1.P[3] = flxIntersec[1]
          Else
            Swap e1.P[0], e1.P[2]
            Swap e1.P[1], e1.P[3]
            e1.P[2] = flxIntersec[0]
            e1.P[3] = flxIntersec[1]

          Endif

          ' linea 2
          If puntos.distancia(e2.P[0], e2.P[1], flxIntersec[0], flxIntersec[1]) >= puntos.distancia(e2.P[2], e2.P[3], flxIntersec[0], flxIntersec[1]) Then
            e2.P[2] = flxIntersec[0]
            e2.P[3] = flxIntersec[1]
          Else
            Swap e2.P[0], e2.P[2]
            Swap e2.P[1], e2.P[3]
            e2.P[2] = flxIntersec[0]
            e2.P[3] = flxIntersec[1]

          Endif

          ' ahora necesito el angulo entre ambas lineas
          alpha = puntos.Angle([e1.P[0] - flxIntersec[0], e1.P[1] - flxIntersec[1]], [e2.P[0] - flxIntersec[0], e2.P[1] - flxIntersec[1]])

          ' verifico que las tangentes esten sobre las lineas
          hr1 = Me.Radious / Tan(alpha / 2)

          ' largo de las lineas
          l1 = puntos.distancia(e1.P[0], e1.P[1], e1.P[2], e1.P[3])
          l2 = puntos.distancia(e2.P[0], e2.P[1], e2.P[2], e2.P[3])

          If (hr1 > l1) Or (hr1 > l2) Then
            ' el punto tangente cae fuera de las lineas
            Return
          Endif

          lc = Sqr(Me.Radious ^ 2 + hr1 ^ 2)

          ' obtengo los puntos tangentes
          t1x = e1.p[2] + (e1.P[0] - e1.P[2]) * hr1 / l1
          t1y = e1.p[3] + (e1.P[1] - e1.P[3]) * hr1 / l1

          t2x = e2.p[2] + (e2.P[0] - e2.P[2]) * hr1 / l2
          t2y = e2.p[3] + (e2.P[1] - e2.P[3]) * hr1 / l2

          ' un punto intermedio en la recta divisoria
          i2x = (t1x + t2x) / 2
          i2y = (t1y + t2y) / 2

          lc2 = puntos.distancia(flxIntersec[0], flxIntersec[1], i2x, i2y)

          'las coordenadas del centro
          Cx = flxIntersec[0] + (i2x - flxIntersec[0]) * lc / lc2
          Cy = flxIntersec[1] + (i2y - flxIntersec[1]) * lc / lc2

          ' corrijo el largo de las lineas
          e1.P[2] = t1x
          e1.P[3] = t1y

          e2.P[2] = t2x
          e2.P[3] = t2y

          ' creo la entidad arc
          ' para ello veo cual angulo es el inicial
          If Ang(e1.p[2] - cx, e1.p[3] - cy) < Ang(e2.p[2] - cx, e2.p[3] - cy) Then

            StartAngle = Ang(e1.p[2] - cx, e1.p[3] - cy) * 180 / Pi
            EndAngle = Ang(e2.p[2] - cx, e2.p[3] - cy) * 180 / Pi
          Else
            EndAngle = Ang(e1.p[2] - cx, e1.p[3] - cy) * 180 / Pi
            StartAngle = Ang(e2.p[2] - cx, e2.p[3] - cy) * 180 / Pi

          Endif

          Dim eArco As New Entity
          eArco.Gender = "Arc"
          eArco.ClassHandler = cadArc
          eArco.P.Insert([cx, cy])
          eArco.fParam.Add(Me.Radious)
          eArco.fParam.Add(StartAngle)
          eArco.fParam.Add(EndAngle)
          eArco.colour = appmain.CurrentColor
          eArco.LineType = appmain.CurrentLtype
          eArco.LayerId = appmain.CurrentLayer
          cadArc.Finish(eArco)
          gcd.CurrentDrawing.arrEntities.Add(eArco)

          'gcd.AddArc(gcd.CurrentDrawing.arrEntities, [cx, cy], Me.Radious, StartAngle, EndAngle, appmain.CurrentColor, appmain.CurrentLtype,, appmain.CurrentLayer)



          Me.Finish

      End Select

  End Select

End
