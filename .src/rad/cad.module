' Gambas module file

'''Working with cad files.
' RADG
' Rapid Application Development for Gambas
'
' Copyright (C) Martín Belmonte
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 2 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
'

Export


Private Function GauchoFloatList(sList As String) As Float[]

  Dim stx As New String[]
  Dim flx As New Float[]
  Dim n As String

  If InStr(sList, ":") > 0 Then
    stx = Split(sList, ":")
    If stx.Count > 0 Then
      For Each n In stx
        flx.Add(CFloat(n))
      Next
    Endif
  Endif

  Return flx

End

'' This function encode a float list like a point angles etc. from a string in
'' delimiter char for dimansions is : the for delimitatiosn of groups we use ;

Private Function GauchoEncodePoint(sPoint As String, sTag As String) As Collection

  Dim cp As New Collection
  Dim fp As New Float[]
  Dim stx As New String[]
  Dim sp As String
  Dim i As Integer

  If InStr(sPoint, ";") > 0 Then
    ' Single point ie.lines
    stx = Split(sPoint, ";")
  Else
    'Multipoint, ie.Polylines
    stx.Add(sPoint)
  Endif

  For Each sp In stx
    If InStr(sPoint, ":") > 0 Then
      fp = Split(sp, ":")
      If fp.Count = 2 Then
        fp.Add(0)
      Endif
    Else
      fp.Add(sp)
    Endif
    cp.Add(fp.Copy(), sTag & CStr(i))
    fp.Clear
    Inc i
  Next

  Return cp

End



'' Import a DXF file into cModel collection.

Public Function DXFImport(sFile As String) As Collection

  Dim sec As New Collection 'String[]

  sec = DXFSections(sFile)

  Return sec

End

'' Import a DWG file into cModel collection.

Public Function DWGImport(sFile As String) As Collection

  Dim sCont As String
  Dim cont As Collection
  Dim FileVersion As String       ''2004, 14, 2007 ...
  Dim vent As Collection
  Dim model As New Collection       ''Complete model
  Dim layers As Collection
  Dim AcHeader As Collection

  layers = DWGLayersList(sFile)

  vent = DWGEntityList()

  sCont = dwgread(sFile)

  If sCont <> "" Then
    FileVersion = Split(sCont, "\n")[1]
    FileVersion = Replace(FileVersion, " ", "")
    FileVersion = Replace(FileVersion, "(", ":")
    FileVersion = Split(FileVersion, ":")[1]

    cont = DWGSections(sCont, FileVersion)

    model.Add(sFile, "File")
    model.Add(FileVersion, "Version")
    model.Add(layers, "Layers")

    If cont.Exist("Header") Then
      AcHeader = DWGHeader(cont["Header"])
      If AcHeader.Count > 0 Then
        model.Add(AcHeader, "Header")
      Endif
    Endif

    If model.Exist("Entities") = False Then
      If cont.Exist("Entities") Then
        model.Add(cont["Entities"], "Entities")
      Endif
    Endif
  Endif
  Return model

End

'' Get the DWG file layers list.

Public Function DWGLayersList(sFile As String) As Collection

  Dim layers As New Collection
  Dim sOut As String
  Dim stx As String[]
  Dim slay As String
  Dim lay As New Collection

  If Exist(sFile) Then
    Shell "/usr/local/bin/dwglayers -f '" & sFile & "' 2>&1 " To sOut
  Endif

  If sOut <> "" Then
    stx = Split(sOut, "\n")
    For Each slay In stx
      If InStr(slay, "\t") > 0 Then

        If String.Mid(slay, 1, 1) = "font" Then
          lay.Add(True, "Frozen")
        Else
          lay.Add(False, "Frozen")
        Endif
        If String.Mid(slay, 2, 1) = "+" Then
          lay.Add(True, "On")
        Else
          lay.Add(False, "On")
        Endif
        If String.Mid(slay, 3, 1) = "l" Then
          lay.Add(True, "Locked")
        Else
          lay.Add(False, "Locked")
        Endif

        lay.Add(Split(slay, "\t")[1], "Name")

      Endif
      layers.Add(lay.Copy(), lay["Name"])
    Next
  Endif

  Return layers

End

'' Create the stanard entities list.

Public Function DWGEntityList() As Collection

  Dim entity As New Collection

  entity.Add(False, "3DFACE")
  entity.Add(False, "3DSOLID")
  entity.Add(False, "ACAD_PROXY_ENTITY")
  entity.Add(True, "ARC") 'ok
  entity.Add(True, "ATTDEF") 'ok
  entity.Add(True, "ATTRIB") 'ok
  entity.Add(False, "BODY")
  entity.Add(True, "CIRCLE") 'ok
  entity.Add(False, "DIMENSION")
  entity.Add(True, "ELLIPSE") 'ok
  entity.Add(False, "ENDBLK") ' solo de referencia
  entity.Add(True, "HATCH")
  entity.Add(False, "HELIX")
  entity.Add(False, "IMAGE")
  entity.Add(True, "INSERT") 'ok
  entity.Add(False, "LEADER")
  entity.Add(False, "LIGHT")
  entity.Add(True, "LINE") 'ok
  entity.Add(True, "LWPOLYLINE") 'ok
  entity.Add(False, "MLINE") 'very complex, to do later
  entity.Add(False, "MULTILEADER")
  entity.Add(False, "MLEADERSTYLE")
  entity.Add(True, "MTEXT") 'ok
  entity.Add(False, "OLEFRAME")
  entity.Add(False, "OLE2FRAME")
  entity.Add(True, "POINT") 'ok
  entity.Add(False, "POLYLINE") 'not yey
  entity.Add(False, "RAY")
  entity.Add(False, "REGION")
  entity.Add(False, "SECTION")
  entity.Add(False, "SEQEND")
  entity.Add(False, "SHAPE")
  entity.Add(False, "SOLID")
  entity.Add(False, "SPLINE")
  entity.Add(False, "SUN")
  entity.Add(False, "SURFACE")
  entity.Add(False, "TABLE")
  entity.Add(True, "TEXT") 'ok
  entity.Add(False, "TOLERANCE")
  entity.Add(False, "TRACE")
  entity.Add(False, "UNDERLAY")
  entity.Add(False, "VERTEX")
  entity.Add(False, "VIEWPORT")
  entity.Add(False, "WIPEOUT")
  entity.Add(False, "XLINE")

  Return entity

End

'dwg2dxf
'dwg2svg
'dwgdump
'dwgfilter
'dwggrep
'dwglayers
'dwgread *
'dwgwrite
'dxf2dwg
'dxfwrite

'' Read a DWG file using the dwgread utility from libreDWG library.

Public Function DWGRead(f As String, Optional fmt As String) As String

  Dim sOut As String

  If Exist(f) Then
    Select fmt
      Case ""
        Shell "/usr/local/bin/dwgread -v4 '" & f & "' 2>&1 " To sOut
      Case "json"
        Shell "/usr/local/bin/dwgread -v4 --format JSON '" & f & "' 2>&1 " To sOut
    End Select

  Endif

  Return sOut

End

'' Create a list of DWG sections using the previously extracted text with the dwgread function.

Public Function DWGSections(s As String, vsn As String) As Collection

  Dim sWrd As String
  Dim cont As New Collection
  Dim sec As New String[]
  Dim sn As String
  Dim sName As String
  Dim sHead As String
  Dim contx As String[]
  Dim tmx As New String[]
  Dim tm As String
  Dim sCont As Variant
  Dim cCont As Collection
  Dim out As New Collection

  Select vsn

    Case "AC1015" '"DWG2000"
      sWrd = "=======> "
      s = Replace(s, "\t", " ")
      s = Replace(s, sWrd, "\t")
      sec = Split(s, "\t")

      tmx = ["AuxHeader", "Thumbnail", "Header Variables", "CLASS", "Handles", "Last Object", "Second Header", "MEASUREMENT"]

      For Each sn In sec
        If InStr(sn, "\n") > 0 Then
          contx = Split(sn, "\n")
          sHead = contx[0]
          sName = ""
          For Each tm In tmx
            If InStr(sHead, tm) > 0 Then
              sName = tm
              Break
            Endif
          Next
          If sName <> "" Then
            sName = Replace(sName, "AcDb:", "")
            If sName = "Header Variables" Then
              sName = "Header"
            Endif

            If sName = "Handles" Then
              sn = Replace(sn, "==========================================\n", "\t")
            Endif
            cont.Add(sn, sName)
          Endif
        Endif
      Next

    Case "AC1018", "AC1024", "AC1027"
      sWrd = "Found section_info["
      s = Replace(s, "\t", " ")
      s = Replace(s, sWrd, "\t")
      sec = Split(s, "\t")

      For Each sn In sec
        If InStr(sn, "\n") > 0 Then
          contx = Split(sn, "\n")
          sHead = contx[0]
          If InStr(sHead, "] AcDb:") > 0 Then
            sName = Split(sHead, " ")[1]
            sName = Replace(sName, "AcDb:", "")
            cont.Add(sWrd & sn, sName)
            '==========================================
          Endif
        Endif
      Next

    Case "AC1021"

      s = Replace(s, "\t", " ")

      tmx = ["AppInfoHistory", "AppInfo", "Preview", "SummaryInfo", "RevHistory", "AcDbObjects", "ObjFreeSpace", "Template", "Handles", "Classes", "AuxHeader", "Header"]

      For Each tm In tmx
        Select tm
          Case "AppInfoHistory", "AppInfo", "Preview", "SummaryInfo", "RevHistory", "ObjFreeSpace", "Template"
            s = Replace(s, tm & " (", "\t" & tm & " (")

          Case "AcDbObjects", "Handles", "Classes", "AuxHeader", "Header"
            s = Replace(s, tm & "\n-------------------", "\t" & tm & "\n-------------------")

        End Select
      Next

      sec = Split(s, "\t")

      For Each sn In sec
        If InStr(sn, "\n") > 0 Then
          contx = Split(sn, "\n")
          sHead = contx[0]
          sName = ""
          For Each tm In tmx
            If InStr(sHead, tm) > 0 Then
              sName = tm
              Break
            Endif
          Next
          If sName <> "" Then
            cont.Add(sn, "AcDb:" & sName)
          Endif
        Endif
      Next

  End Select

  '' Arranging the data to standarize like DXF collection
  For Each sCont In cont
    Select cont.Key
      Case "Handles" 'Entities en DXF
        cCont = DWGEntities(sCont)
        out.Add(cCont, "Entities")
    End Select
  Next

  Return out

End

'' Create a list of DWG entities using the previously extracted text with the dwgread function

Public Function DWGEntities(s As String) As Collection

  Dim stx As String[]
  Dim i As Integer
  Dim obt As String
  Dim obx As New String[]
  Dim tmx As New Collection
  Dim j As Integer
  Dim hdx As New String[]
  Dim sTag As String
  Dim sVal As String
  Dim vVal As Variant
  Dim out As New Collection

  Dim sRaw As String
  Dim t As String
  Dim otx As New String[]
  Dim enty As Collection
  Dim alias As Collection
  Dim sAlias As Variant
  Dim r As Variant
  Dim sOut As String
  Dim arr As New Collection
  Dim sKey As String
  Dim out2 As Collection

  enty = DWGEntityList()
  alias = DWGAlias()

  s = Replace(s, "==========================================\n", "\t")
  stx = Split(s, "\t")

  If stx.count > 0 Then
    For i = 1 To stx.Max
      tmx.Clear
      obt = stx[i]
      obx.Clear
      obx = Split(obt, "\n")

      If obx.Count > 1 Then
        If InStr(obx[1], " Decode entity ") > 0 Then
          hdx.Clear
          hdx = Split(Replace(obx[1], " Decode entity ", "\t"), "\t")
          vVal = hdx[hdx.Max]
          tmx.Add(vVal, "entity")
          File.Save("/tmp" &/ vVal & ".txt", obt)

          If enty.Exist(hdx[hdx.Max]) Then
            If enty[hdx[hdx.Max]] Then
              Print "Acepted: " & hdx[hdx.Max]
              File.Save("/tmp" &/ Format(i, "0000") & ".txt", obt)

              otx = Split(Replace(obx[0], ", ", "\t"), "\t")

              For Each t In otx
                sRaw = Replace(t, ": ", ":")
                sTag = String.Lower(Split(sRaw, ":")[0])
                sTag = Replace(sTag, " ", "")
                sVal = Replace(sRaw, Split(sRaw, ":")[0] & ":", "")
                vVal = DWGDecodeItem([sTag, sVal])
                If tmx.Exist(sTag) = False Then
                  If sTag = "objectnumber" Then
                    If InStr(sVal, "/") > 0 Then
                      tmx.Add(CStr(Split(sVal, "/")[0]), "id") 'Long
                    Endif
                  Else
                    tmx.Add(vVal, sTag)
                  Endif
                Endif
              Next

              For j = 2 To obx.Max

                If InStr(obx[j], ":") > 0 Then
                  sRaw = Replace(obx[j], ": ", ":")
                  sTag = String.Lower(Split(sRaw, ":")[0])
                  sTag = Replace(sTag, " ", "")
                  If alias.Exist(sTag) Then
                    sAlias = alias[sTag]
                  Else
                    sAlias = sTag
                  Endif

                  sVal = Replace(sRaw, Split(sRaw, ":")[0] & ":", "")

                  vVal = DWGDecodeItem([sTag, sVal])
                  If tmx.Exist(sTag) = False Then
                    tmx.Add(vVal, sAlias)
                  Else
                    tmx.Add(vVal, sAlias & "[" & CStr(j) & "]")
                  Endif
                Else
                Endif
              Next
              If tmx.Count > 0 Then
                'out.Add([tmx.Copy()], tmx["object_name"])
                sOut = ""
                For Each r In tmx
                  If TypeOf(r) <> 16 Then
                    sOut &= tmx.Key & ": " & CStr(r) & "\n"
                  Else
                    sOut &= tmx.Key & ": [type 16]" & "\n"
                  Endif
                Next

                arr = DWGArrangeEnty(tmx.Copy())
                If arr.Exist("id") Then
                  sKey = arr["entity"] & ":" & arr["id"]
                  out.Add(arr.Copy(), sKey)
                Endif
              Endif
            Endif
          Endif
        Else
        Endif
      Endif
      APPMain.Progress(stx.Count, i)
    Next
  Endif

  out2 = GauchoEntitiesSort(out)

  Return out2

End

Public Function DWGDecodeItem(xRaw As String[]) As Variant

  Dim sVal As String
  Dim sTag As String
  Dim vVal As Variant
  Dim k As Integer
  Dim sDxf As String
  Dim sType As String
  Dim tVal As String
  Dim sGrp As String
  Dim kword As String
  Dim px As Float[]

  sTag = String.Lower(xRaw[0])
  If InStr(sTag, "entries[vcount]") > 0 Then
    sGrp = "entries"
  Endif
  sVal = Replace(xRaw[1], " [", "[")

  Print sTag & ": " & sVal

  Select sTag

    Case "ownerhandle", "layer", "style", "block_header"
      If InStr(sVal, "=>") > 0 Then
        k = InStr(sVal, " => ")
        If k > 0 Then
          tVal = String.Mid(sVal, k + 4)
          For Each kword In ["LAYER", "BLOCK_HEADER", "STYLE"]
            If InStr(tVal, kword) > 0 Then
              tVal = Replace(tVal, kword & " ", "")
              Break
            Endif
          Next
          vVal = tVal
        Endif
      Else
        vVal = "Error"
      Endif

    Case "start", "end", "ins_pt", "center", "alignment_pt", "sm_axis", "extrusion"
      px = DWGDecodeCoord(sVal)
      If px.Count = 2 Then
        px.Add(0.0)
      Endif
      vVal = px

    Case "scale"
      px = DWGDecodeCoord(sVal)
      If px.Count = 2 Then
        px.Add(1.0)
      Endif
      vVal = px

    Case "crc"
      vVal = DWGDecodeCRC(sVal)

    Case "color.index"
      vVal = DWGDecodeColor(sVal)

    Case "linewt", "color.raw"
      If InStr(sVal, "[") > 0 Then
        tVal = Split(sVal, "[")[0]
        vVal = tVal
      Else
        vVal = sVal
      Endif
      vVal = DWGDecodeHex(tVal)

    Case "handle"
      vVal = DWGDecodeHandle(sVal)

    Case "start_angle", "end_angle", "axis_ratio"
      If InStr(sVal, "[") > 0 Then
        tVal = Split(sVal, "[")[0]
        vVal = DWGDecodeFloat(tVal)
      Else
        vVal = DWGDecodeFloat(sVal)
      Endif

    Case "prev_entity", "next_entity", "xdicobjhandle"
      If InStr(sVal, ")") > 0 Then
        tVal = Split(sVal, ")")[0]
        tVal = Replace(tVal, "(", "")
        vVal = tVal
      Else
        vVal = sVal
      Endif

    Case "address"
      vVal = sVal

    Case "bitsize", "num_eed", "horiz_alignment"
      vVal = DWGDecodeInteger(sVal)

    Case "hdlsize"
      If InStr(sVal, ",") > 0 Then
        tVal = Split(sVal, ",")[0]
      Else
        tVal = sVal
      Endif
      vVal = DWGDecodeInteger(tVal)

    Case "x_ang", "height", "x", "y", "z", "radius", "rotation"
      vVal = DWGDecodeFloat(tVal)

    Case Else
      If InStr(sVal, "[") > 0 And Right(sVal) = "]" Then
        If InStr(sVal, " ") > 0 Then
          sType = Split(Split(sVal, "[")[1], " ")[0]
          sDxf = Split(Split(sVal, "[")[1], " ")[1]
        Else
          sType = Split(sVal, "[")[1]
          sType = Replace(sType, "]", "")
          sDxf = ""
        Endif
        tVal = Split(sVal, "[")[0]

        Select sType
          Case "3B", "4BITS", "B", "BB" 'Byte
            Try vVal = CByte(tVal)

            If Error Then
              Print Error.Backtrace
              vVal = CByte("0")
            Endif

          Case "BD", "BE", "BT", "RD" 'FLoat
            vVal = vag.CFloat(tVal)

          Case "DD" 'Coords
            Select sDxf
              Case ""
                vVal = vag.CFloat(tVal)
              Case "10", "11", "20", "21", "30", "31", "40", "41"
                vVal = DWGDecodeCoord(sVal)
            End Select

          Case "BL", "BLL", "MC", "MS", "RL", "UMC" 'Long
            vVal = CLong(tVal)

          Case "BS", "RS"  'Short
            vVal = CShort(tVal)

          Case "RC", "TF", "TFF", "TU", "TV" 'String
            vVal = CString(tVal)

          Case "CMC", "H" ' ¿String?
            vVal = CString(tVal)

          Case Else
            vVal = tVal

        End Select

      Else
        vVal = sVal
      Endif

  End Select

  Return vVal

End

'' Create a list of DWG headers using the previously extracted text with the dwgread function

Public Function DWGHeader(s As String) As Collection

  Dim stx As String[]
  Dim i As Integer
  Dim obt As String
  Dim obx As New String[]
  Dim sTag As String
  Dim sVal As String
  Dim out As New Collection

  stx = Split(s, "\n")

  If stx.count > 0 Then
    For i = 1 To stx.Max
      obt = stx[i]
      obx.Clear
      If InStr(obt, ": ") > 0 Then
        obt = Replace(obt, ": ", "\t")
        obt = Replace(obt, " [", "\t")
        obt = Replace(obt, "]", "")
        obx = Split(obt, "\t")
        sTag = obx[0]
        sVal = obx[1]
        out.Add(sVal, sTag)
      Endif
    Next
  Endif

  Return out

End

'' Decode common fields to DWG entities.

Public Function DWGDecodeCommon(c As Collection) As Collection

  Dim v As Variant
  Dim prp As New Collection
  Dim sVal As Variant
  Dim i As Integer
  Dim f As Float

  If c.Exist("XName") Then

    prp.Add(c["XName"], "entity")

    If c.Exist("Objectnumber") Then
      If InStr(c["Objectnumber"], "/") > 1 Then
        i = CInt(Split(c["Objectnumber"], "/")[0])
      Endif
      prp.Add(i, "handle")
    Endif

    For Each v In c
      i = -1
      f = 0.0
      Select c.Key

        Case "layer"
          sVal = DWGDecodeLayer(CStr(v))
          prp.Add(sVal, "layer")

        Case "ltype_flags"
          i = DWGDecodeInteger(CStr(v))
          prp.Add(i, "style")

        Case "linewt"
          i = DWGDecodeHex(sVal)
          prp.Add(i, "linewt")

        Case "ltype_scale"
          f = DWGDecodeFloat(CStr(v))
          prp.Add(f, c.Key)

        Case "plotstyle_flags"
          i = DWGDecodeInteger(CStr(v))
          prp.Add(i, c.Key)

        Case "invisible"
          i = DWGDecodeInteger(CStr(v))
          prp.Add(i, c.Key)

      End Select

      ' Colour
      sVal = ""
      If c.Exist("color.raw") Then
        sVal = String.Mid(c["color.raw"], 1, InStr(c["color.raw"], "[") - 1)
        i = DWGDecodeHex(sVal)
      Else
        If c.Exist("color.index") Then
          sVal = String.Mid(c["color.index"], 1, InStr(c["color.index"], "[") - 1)
          sval = Replace(sval, " ", "")
          i = CInt(sval)
        Endif
      Endif

      If i >= 0 And i <= 256 Then
        prp.Add(i, "color")
      Else
        prp.Add(0, "color")
      Endif

    Next
  Endif

  Return prp

End

'' Decode the specific fields of an entity

Public Function DWGDecodeEntity(c As Collection) As Collection

  Dim v As Variant
  Dim prp As New Collection
  Dim sVal As Variant
  Dim pt As New Float[]
  Dim pt1 As New Float[]
  Dim pt2 As New Float[]
  Dim i As Integer
  Dim f As Float
  Dim p As Integer
  Dim sDec As String
  Dim sTag As String
  Dim sTag1 As String
  Dim sTag2 As String
  Dim hx As Integer
  Dim sTag3 As String
  Dim n As Integer
  Dim d As Integer
  Dim sTag5 As String
  Dim sTag4 As String
  Dim vVal As Variant

  If c.Exist("XName") Then

    If c.Exist("Objectnumber") Then
      If InStr(c["Objectnumber"], "/") > 1 Then
        i = CInt(Split(c["Objectnumber"], "/")[0])
      Endif
      prp.Add(CStr(i), "handle")
    Endif

    prp.Add(c["XName"], "entity")

    Select c["XName"]

      Case "TEXT"

        For Each v In c
          Select c.Key
            Case "insertion_pt"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, "p1")

            Case "alignment_pt"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, "p2")

            Case "rotation"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, "angle")

            Case "height"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, "height")

            Case "horiz_alignment"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, "horiz")

            Case "style"
              sVal = DWGDecodeTextStyle(CStr(v))
              prp.Add(sVal, "font")

            Case "text_value" ' I deide call just "text" to the tag
              sVal = DWGDecodeText(CStr(v))
              prp.Add(sVal, "text")

          End Select
        Next

      Case "MTEXT"

        For Each v In c
          Select c.Key
            Case "insertion_pt"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, "p1")

            Case "extrusion"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, c.Key)

            Case "x_axis_dir"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, c.Key)

            Case "rect_width"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, c.Key)

            Case "text_height"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, "height")

            Case "attachment"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "drawing_dir"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "extents_height"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, c.Key)

            Case "extents_width"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, c.Key)

            Case "text"
              sVal = DWGDecodeText(CStr(v))
              prp.Add(sVal, "text")

            Case "linespace_style"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "linespace_factor"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, c.Key)

            Case "unknown_bit"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "bg_fill_flag"

              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "style"
              sVal = DWGDecodeTextStyle(CStr(v))
              prp.Add(sVal, "font")

          End Select
        Next

      Case "ATTDEF"

        For Each v In c
          Select c.Key
            Case "insertion_pt"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, "p1")

            Case "height"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, "height")

            Case "default_value"
              sVal = DWGDecodeText(CStr(v))
              prp.Add(sVal, "default")

            Case "tag"
              sVal = DWGDecodeText(CStr(v))
              prp.Add(sVal, "tag")

            Case "field_length"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, "length")

            Case "prompt"
              sVal = DWGDecodeText(CStr(v))
              prp.Add(sVal, "prompt")

            Case "style"
              sVal = DWGDecodeTextStyle(CStr(v))
              prp.Add(sVal, "font")

          End Select
        Next

      Case "ATTRIB"

        For Each v In c
          Select c.Key
            Case "insertion_pt"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, "p1")

            Case "height"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, "height")

            Case "text_value"
              sVal = DWGDecodeText(CStr(v))
              prp.Add(sVal, "text")

            Case "tag"
              sVal = DWGDecodeText(CStr(v))
              prp.Add(sVal, "tag")

            Case "field_length"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, "length")

            Case "style"
              sVal = DWGDecodeTextStyle(CStr(v))
              prp.Add(sVal, "font")

          End Select
        Next

      Case "POINT"
        prp.Add([0, 0, 0], "p1")
        For Each v In c
          Select c.Key
            Case "x"
              f = DWGDecodeFloat(CStr(v))
              prp["p1"][0] = f

            Case "y"
              f = DWGDecodeFloat(CStr(v))
              prp["p1"][1] = f

            Case "z"
              f = DWGDecodeFloat(CStr(v))
              prp["p1"][2] = f

          End Select
        Next

        f = DWGDecodeFloat(c["x_ang"])
        prp.Add(f, "angle")

      Case "LINE"
        For Each v In c
          Select c.Key
            Case "start"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, "p1")
            Case "end"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, "p2")
          End Select
        Next

      Case "INSERT"
        For Each v In c
          Select c.Key

            Case "ins_pt"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, "p1")

            Case "scale_flag"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "scale"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, "scale")

            Case "rotation"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, "angle")

            Case "extrusion"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, c.Key)

            Case "has_attribs"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "num_owned"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "block_header"
              sVal = DWGDecodeBlockHeader(CStr(v))
              prp.Add(sVal, c.Key)

          End Select
        Next

      Case "CIRCLE"
        For Each v In c
          Select c.Key
            Case "center"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, "p1")

            Case "radius"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, "radius")
          End Select
        Next

      Case "ARC"
        For Each v In c
          Select c.Key
            Case "center"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, "p1")

            Case "radius"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, "radius")

            Case "start_angle"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, "angle1")

            Case "end_angle"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, "angle2")
          End Select
        Next

      Case "ELLIPSE"
        For Each v In c
          Select c.Key
            Case "center"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, "p1")

            Case "sm_axis"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, c.Key)

            Case "extrusion"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, c.Key)

            Case "axis_ratio"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, c.Key)

            Case "start_angle"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, "angle1")

            Case "end_angle"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, "angle2")

          End Select

        Next

      Case "LWPOLYLINE"
        For Each v In c
          Select c.Key
            Case "num_points"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, "points")
              For p = 0 To i
                sDec = "points[" & p & "]"
                sTag = "p" & CStr(p)
                If c.Exist(sDec) Then
                  pt = DWGDecodeCoord(CStr(c[sDec]))
                  prp.Add(pt, sTag)
                Endif
              Next
          End Select
        Next

      Case "HATCH"
        For Each v In c
          Select c.Key

            Case "is_gradient_fill"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "reserved"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "gradient_angle"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, c.Key)

            Case "gradient_shift"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, c.Key)

            Case "single_color_gradient"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "gradient_tint"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, c.Key)

            Case "num_colors"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "gradient_name"
              sVal = DWGDecodeText(CStr(v))
              prp.Add(sVal, c.Key)

            Case "elevation"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, c.Key)

            Case "extrusion"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, c.Key)

            Case "name"
              sVal = DWGDecodeText(CStr(v))
              prp.Add(sVal, c.Key)

            Case "solid_fill"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "associative"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "num_paths"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "paths[0].flag"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "paths[0].num_segs_or_paths"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

              For p = 0 To i
                sTag = "paths[0].segs[p].type_status"
                sTag1 = "paths[0].segs[p].first_endpoint"
                sTag2 = "paths[0].segs[p].second_endpoint"

                If c.Exist(sTag) Then
                  hx = DWGDecodeHex(CStr(c[sTag]))
                  prp.Add(hx, sTag1)
                Endif

                If c.Exist(sTag1) Then
                  pt1 = DWGDecodeCoord(CStr(c[sTag1]))
                  prp.Add(pt1, sTag1)
                Endif

                If c.Exist(sTag2) Then
                  pt2 = DWGDecodeCoord(CStr(c[sTag2]))
                  prp.Add(pt2, sTag2)
                Endif

              Next

            Case "paths[0].num_boundary_handles"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "style"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "pattern_type"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "angle"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, c.Key)

            Case "scale_spacing"
              f = DWGDecodeFloat(CStr(v))
              prp.Add(f, c.Key)

            Case "double_flag"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "num_deflines"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

              For p = 0 To i

                sTag1 = "deflines[" & CStr(i) & "].pt0"
                pt = DWGDecodeCoord(CStr(c[sTag1]))
                prp.Add(pt, sTag1)

                sTag2 = "deflines[" & CStr(i) & "].offset"
                pt = DWGDecodeCoord(CStr(c[sTag2]))
                prp.Add(pt, sTag2)

                sTag3 = "deflines[" & CStr(i) & "].num_dashes"
                n = DWGDecodeInteger(CStr(c[sTag3]))
                prp.Add(n, sTag3)

                For d = 0 To n
                  sTag4 = "deflines[rcount1].dashes[" & CStr(d) & "]"
                  f = DWGDecodeFloat(CStr(c[sTag4]))
                  prp.Add(f, sTag4)
                Next
                sTag5 = "deflines[rcount1].angle"
                f = DWGDecodeFloat(CStr(c[sTag5]))
                prp.Add(f, sTag5)

              Next

            Case "num_seeds"
              i = DWGDecodeInteger(CStr(v))
              prp.Add(i, c.Key)

            Case "seeds[vcount]"
              pt = DWGDecodeCoord(CStr(v))
              prp.Add(pt, c.Key)

          End Select
        Next
      Case Else
        For Each v In c
          sVal = CStr(v)
          If InStr(sVal, "[") > 0 And InStr(sVal, "]") > 0 Then
            vVal = DWGDecodeItem(sVal)
          Else
            vVal = sVal
          Endif
          prp.Add(vVal, c.Key)
        Next

    End Select
  Endif

  Return prp

End

'' Decode the coordinate fields in a entity from DWG file.

Public Function DWGDecodeCoord(s As String) As Float[]

  Dim pt As New Float[]
  Dim sVal As String

  sVal = Replace(s, " ", "")
  sVal = Replace(sVal, ",", ":")
  sVal = Replace(sVal, "(", "")
  sVal = Replace(sVal, ")", "")
  If InStr(sVal, "[") > 0 Then
    sVal = String.Mid(sVal, 1, InStr(sVal, "[") - 1)
  Endif

  pt = Split(sVal, ":")

  Return pt

End

Public Function DWGDecodeCRC(s As String) As String

  Dim out As String

  If InStr(s, "[RSx]") > 0 Then
    out = Split(s, "[")[0]
  Else
    out = ""
  Endif

  Return out

End

Public Function DWGDecodeColor(s As String) As Byte

  Dim out As Byte

  If InStr(s, "[") > 0 Then
    s = Replace(s, " [", "[")
    Try out = CByte(Split(s, "[")[0])
    If Error Then
      out = 0
    Endif
  Else
    out = 0
  Endif

  Return out

End

'' Decode the Hex fields in a entity from DWG file.

Public Function DWGDecodeHex(s As String) As Integer

  Dim out As Integer

  If InStr(s, "0x") > 0 Then
    out = Val(Replace(s, "0x", "&00"))
  Else
    out = 0
  Endif

  Return out

End

'' Decode the Floar fields in a entity from DWG file.

Public Function DWGDecodeFloat(s As String) As Float

  Dim out As Float
  Dim sVal As String

  sVal = Replace(s, " ", "")
  If InStr(sVal, "[") > 0 Then
    out = Split(sVal, "[")[0]
  Else
    out = 0.0
  Endif

  Return out

End

'' Decode the Integer fields.

Public Function DWGDecodeInteger(s As String) As Integer

  Dim out As Integer
  Dim sVal As String

  sVal = Replace(s, " ", "")
  If InStr(sVal, "[") > 0 Then
    out = Split(sVal, "[")[0]
  Else
    out = 0
  Endif

  Return out

End

'' Decode the layers fields.

Public Function DWGDecodeLayer(s As String) As String

  Dim out As String

  If InStr(s, " => LAYER ") > 0 Then
    out = Split(Replace(s, " => LAYER ", "\t"), "\t")[1]
  Else
    out = s
  Endif

  Return out

End

'' Decode the block header.

Public Function DWGDecodeHandle(s As String) As String

  Dim out As String

  If InStr(s, "[H 5]") > 0 Then
    out = Split(s, "[")[0]
  Else
    out = s
  Endif

  Return out

End

Public Function DWGDecodeBlockHeader(s As String) As String

  Dim out As String

  If InStr(s, " => BLOCK_HEADER ") > 0 Then
    out = Split(Replace(s, " => BLOCK_HEADER ", "\t"), "\t")[1]
  Else
    out = s
  Endif

  Return out

End

'' Decode the text style field.

Public Function DWGDecodeTextStyle(s As String) As String

  Dim out As String

  If InStr(s, " => STYLE ") > 0 Then
    out = Split(Replace(s, " => STYLE ", "\t"), "\t")[1]
  Else
    out = s
  Endif

  Return out

End

'' Decode the text fields.

Public Function DWGDecodeText(s As String) As String

  Dim out As String

  s = Conv$(s, "ISO-8859-1", "UTF-8")
  If InStr(s, "\\U+") > 0 Then
    s = String2.Flat(s)
  Endif

  If InStr(s, " [") > 0 Then
    out = Split(Replace(s, " [", "\t"), "\t")[0]
    If String.Left(out) = Chr(34) Then
      out = String.Mid(out, 2)
    Endif
    If String.Right(out) = Chr(34) Then
      out = String.Mid(out, 1, String.Len(out) - 1)

    Endif
  Else
    out = s
  Endif

  Return out

End

Public Function DWGAlias() As Collection

  Dim d As New Collection

  d.Add("linewt", "linewt")
  d.Add("style", "ltype_flags")
  d.Add("block", "ownerhandle")

  Return d

End

Public Function DWGArrangeEnty(c As Collection) As Collection

  Dim o As New Collection
  Dim x As New Collection
  Dim err As New String[]
  Dim tag As String
  Dim str As String
  Dim p As Integer
  Dim pt As String
  Dim ps As String
  Dim px As New Float[]
  Dim flo As Float
  Dim int As Integer

  If c.Exist("entity") Then

    o.Add(c["entity"], "entity")

    If c.Exist("id") Then
      o.Add(c["id"], "id")
    Else
      o.Add("id", "error")
    Endif

    If c.Exist("handle") Then
      o.Add(c["handle"], "handle")
    Else
      If c.Exist("id") Then
        o.Add(c["id"], "handle")
      Else
        o.Add("handle", "error")
      Endif
    Endif

    For Each tag In ["layer", "style", "linewt"]
      If c.Exist(tag) Then
        o.Add(c[tag], tag)
      Else
        err.Add(tag)
      Endif
    Next

    If c.Exist("invisible") Then
      o.Add(c["invisible"], "invisible")
    Else
      o.Add(0, "invisible")
    Endif

    If c.Exist("block") Then
      o.Add(c["block"], "block")
    Else
      o.Add("", "block")
    Endif

    If c.Exist("color.index") Then
      o.Add(c["color.index"], "color")
    Else
      If c.Exist("color.raw") Then
        o.Add(c["color.raw"], "color")
      Else
        o.Add(0, "color")
      Endif
    Endif

    Select c["entity"]

      Case "ELLIPSE"
        x.Clear
        If c.Exist("center") Then
          x.Add(c["center"], "p0")
          If c.Exist("sm_axis") Then
            x.Add(c["sm_axis"], "p1")
          Endif
          o.Add(x.Copy(), "p")
        Else
          err.Add("p")
        Endif

        If c.Exist("axis_ratio") Then
          o.Add(c["axis_ratio"], "ratio")
        Else
          err.Add("ratio")
        Endif

        If c.Exist("start_angle") Then
          o.Add(c["start_angle"], "start_angle")
        Else
          err.Add("start_angle")
        Endif

        If c.Exist("end_angle") Then
          o.Add(c["end_angle"], "end_angle")
        Else
          err.Add("end_angle")
        Endif

      Case "ARC"
        If c.Exist("center") Then
          x.Clear
          x.Add(c["center"], "p0")
          o.Add(x.Copy(), "p")
        Else
          err.Add("p")
        Endif

        If c.Exist("radius") Then
          o.Add(c["radius"], "radius")
        Else
          err.Add("radius")
        Endif

        If c.Exist("start_angle") Then
          o.Add(c["start_angle"], "start_angle")
        Else
          err.Add("start_angle")
        Endif

        If c.Exist("end_angle") Then
          o.Add(c["end_angle"], "end_angle")
        Else
          err.Add("end_angle")
        Endif

      Case "ATTDEF"
        If c.Exist("ins_pt") Then
          x.Clear
          x.Add(c["ins_pt"], "p0")
          o.Add(x.Copy(), "p")
          x.Clear
        Else
          err.Add("p")
        Endif
        If c.Exist("height") Then
          flo = DWGDecodeFloat(c["height"])
          o.Add(flo, tag)
        Else
          err.Add("height")
        Endif
        For Each tag In ["default_value", "tag", "prompt", "style"]
          If c.Exist(tag) Then
            str = UnQuote(c[tag])
            o.Add(str, tag)
          Else
            err.Add(tag)
          Endif
        Next

        'Case "ATTRIB"

      Case "CIRCLE"
        If c.Exist("center") Then
          x.Clear
          x.Add(c["center"], "p0")
          o.Add(x.Copy(), "p")
        Else
          err.Add("p")
        Endif
        If c.Exist("radius") Then
          o.Add(c["radius"], "radius")
        Else
          err.Add("radius")
        Endif

      Case "HATCH"

      Case "INSERT"

        If c.Exist("ins_pt") Then
          x.Clear
          x.Add(c["ins_pt"], "p0")
          o.Add(x.Copy(), "p")
        Else
          err.Add("p")
        Endif

        If c.Exist("scale") Then
          If c["scale"].Count > 1 Then
            o.Add(c["scale"][0], "scalex")
            o.Add(c["scale"][1], "scaley")
            If c["scale"].Count > 2 Then
              o.Add(c["scale"][2], "scalez")
            Endif
          Else
            err.Add("scalex")
            err.Add("scaley")
          Endif
        Endif

        If c.Exist("rotation") Then
          o.Add(c["rotation"], "angle")
        Else
          err.Add("angle")
        Endif

        If c.Exist("block_header") Then
          o.Add(c["block_header"], "block")
        Else
          err.Add("block")
        Endif

      Case "LINE"
        If c.Exist("start") And c.Exist("end") Then
          x.Clear
          x.Add(c["start"], "p0")
          x.Add(c["end"], "p1")
          o.Add(x.Copy(), "p")
          x.Clear
        Else
          err.Add("p")
        Endif

      Case "LWPOLYLINE"
        If c.Exist("num_points") Then
          o.Add(c["num_points"], "num_points")
          x.Clear
          For p = 0 To c["num_points"] - 1
            pt = "p" & CStr(p)
            ps = "points[" & CStr(p) & "]"

            If c.Exist(ps) Then
              px = DWGDecodeCoord(c[ps])
              If px.Count = 2 Then
                px.Add(0.0)
              Endif
              x.Add(px, pt)
            Else
              err.Add("p")
            Endif
          Next
          o.Add(x.Copy(), "p")
          x.Clear
        Else
          err.Add("p")
        Endif

      Case "MTEXT"

        If c.Exist("text_height") Then
          flo = c["text_height"]
          o.Add(flo, "text_height")
        Else
          err.Add("text_height")
        Endif

        If c.Exist("rotation") Then
          flo = c["rotation"]
        Else
          flo = 0.0
        Endif
        o.Add(flo, "angle")

        If c.Exist("horiz_alignment") Then
          int = c["horiz_alignment"]
          o.Add(int, "horiz_alignment")
        Endif

        If c.Exist("text") Then
          str = UnQuote(c["text"])
          o.Add(str, "text")
        Else
          err.Add("text")
        Endif

        If c.Exist("text_style") Then
          str = UnQuote(c["text_style"])
          o.Add(str, "text_style")
        Else
          err.Add("text_style")
        Endif

        If c.Exist("ins_pt") Then
          x.Clear
          x.Add(c["ins_pt"], "p0")
          If c.Exist("alignment_pt") Then
            x.Add(c["alignment_pt"], "p1")
          Endif
          o.Add(x.Copy(), "p")
        Endif

      Case "POINT"
        If c.Exist("x") And c.Exist("y") And c.Exist("z") Then
          x.Clear
          px.Add(c["x"])
          px.Add(c["y"])
          px.Add(c["z"])
          x.Add(px, "p0")
          o.Add(x, "p")
        Else
          err.Add("p")
        Endif

      Case "TEXT"

        If c.Exist("height") Then
          flo = c["height"]
          o.Add(flo, "text_height")
        Else
          err.Add("text_height")
        Endif

        If c.Exist("rotation") Then
          flo = c["rotation"]
        Else
          flo = 0.0
        Endif
        o.Add(flo, "angle")

        If c.Exist("horiz_alignment") Then
          int = c["horiz_alignment"]
          o.Add(int, "horiz_alignment")
        Endif

        If c.Exist("text") Then
          str = UnQuote(c["text"])
          o.Add(str, "text")
        Else
          err.Add("text")
        Endif

        If c.Exist("text_style") Then
          str = UnQuote(c["text_style"])
          o.Add(str, "text_style")
        Else
          err.Add("text_style")
        Endif

        If c.Exist("ins_pt") Then
          x.Clear
          x.Add(c["ins_pt"], "p0")
          If c.Exist("alignment_pt") Then
            x.Add(c["alignment_pt"], "p1")
          Endif
          o.Add(x.Copy(), "p")
        Else
          err.Add("p")
        Endif

    End Select
  Endif

  If err.Count > 0 Then
    o.Add(err, "error")
  Endif

  Return o

End

'' creates a list of dimension codes.

Public Function DWGDimCodes() As Collection

  Dim d As New Collection

  d.Add(["DIMPOST", "string"], "3")
  d.Add(["DIMAPOST", "float"], "4")
  d.Add(["DIMBLK", "string"], "5")
  d.Add(["DIMBLK1", "string"], "6")
  d.Add(["DIMBLK2", "string"], "7")
  d.Add(["DIMSCALE", "float"], "40")
  d.Add(["DIMASZ", "float"], "41")
  d.Add(["DIMEXO", "float"], "42")
  d.Add(["DIMDLI", "float"], "43")
  d.Add(["DIMEXE", "float"], "44")
  d.Add(["DIMRND", "float"], "45")
  d.Add(["DIMDLE", "float"], "46")
  d.Add(["DIMTP", "float"], "47")
  d.Add(["DIMTM", "float"], "48")
  d.Add(["DIMTXT", "float"], "140")
  d.Add(["DIMCEN", "float"], "141")
  d.Add(["DIMTSZ", "float"], "142")
  d.Add(["DIMALTF", "float"], "143")
  d.Add(["DIMLFAC", "float"], "144")
  d.Add(["DIMTVP", "float"], "145")
  d.Add(["DIMTFAC", "float"], "146")
  d.Add(["DIMGAP", "float"], "147")
  d.Add(["DIMALTRND", "float"], "148")
  d.Add(["DIMTOL", "float"], "71")
  d.Add(["DIMLIM", "float"], "72")
  d.Add(["DIMTIH", "float"], "73")
  d.Add(["DIMTOH", "float"], "74")
  d.Add(["DIMSE1", "float"], "75")
  d.Add(["DIMSE2", "float"], "76")
  d.Add(["DIMTAD", "float"], "77")
  d.Add(["DIMZIN", "float"], "78")
  d.Add(["DIMAZIN", "float"], "79")
  d.Add(["DIMALT", "float"], "170")
  d.Add(["DIMALTD", "float"], "171")
  d.Add(["DIMTOFL", "float"], "172")
  d.Add(["DIMSAH", "float"], "173")
  d.Add(["DIMTIX", "float"], "174")
  d.Add(["DIMSOXD", "float"], "175")
  d.Add(["DIMCLRD", "float"], "176")
  d.Add(["DIMCLRE", "float"], "177")
  d.Add(["DIMCLRT", "float"], "178")
  d.Add(["DIMADEC", "float"], "179")
  d.Add(["DIMUNIT", "float"], "270")
  d.Add(["DIMDEC", "float"], "271")
  d.Add(["DIMTDEC", "float"], "272")
  d.Add(["DIMALTU", "float"], "273")
  d.Add(["DIMALTTD", "float"], "274")
  d.Add(["DIMAUNIT", "float"], "275")
  d.Add(["DIMFRAC", "float"], "276")
  d.Add(["DIMLUNIT", "float"], "277")
  d.Add(["DIMDSEP", "float"], "278")
  d.Add(["DIMTMOVE", "float"], "279")
  d.Add(["DIMJUST", "float"], "280")
  d.Add(["DIMSD1", "float"], "281")
  d.Add(["DIMSD2", "float"], "282")
  d.Add(["DIMTOLJ", "float"], "283")
  d.Add(["DIMTZIN", "float"], "284")
  d.Add(["DIMALTZ", "float"], "285")
  d.Add(["DIMALTTZ", "float"], "286")
  d.Add(["DIMFIT", "float"], "287")
  d.Add(["DIMUPT", "float"], "288")
  d.Add(["DIMATFIT", "float"], "289")
  d.Add(["DIMTXSTY", "string"], "340")
  d.Add(["DIMLDRBLK", "string"], "341")
  d.Add(["DIMBLK", "string"], "342")
  d.Add(["DIMBLK1", "string"], "343")
  d.Add(["DIMBLK2", "string"], "344")
  d.Add(["DIMLWD", "string"], "371")
  d.Add(["DIMLWE", "string"], "372")

  Return d

End

'' Creates a list with the codes of an entity indicated as a parameter.

Public Function DXFEntityDefaults(Optional ent As String) As Collection

  Dim cod As New Collection
  'Common defaults
  cod.Add("BYLAYER", "6")
  cod.Add("BYLAYER", "347")
  cod.Add(0, "370") ' Este no es el valor por defecto en el estandar pero lo puse asi porque a veces es omitido en el dxf
  cod.Add(0, "60")
  cod.Add(256, "62")
  cod.Add(0, "67")
  cod.Add(1.0, "48")

  Select String.LCase(ent)
    Case "insert"
      cod.Add(1, "41")
      cod.Add(1, "42")
      cod.Add(1, "43")
      cod.Add(0, "44")
      cod.Add(0, "45")
      cod.Add(0, "50")
      cod.Add(1, "70")
      cod.Add(1, "71")

    Case "text"
      cod.Add(0, "39")
      cod.Add(0, "50")
      cod.Add("STANDARD", "7")
      cod.Add(1, "41")
      cod.Add(0, "71")
      cod.Add(0, "72")
      cod.Add(0, "73")
    Case "mtext"
      cod.Add(1, "71")
      cod.Add(0, "50")

  End Select

  Return cod

End

'' Creates a list with all the codes of an entity indicated as a parameter.

Public Function DXFEntityCodes(Optional ent As String) As Collection

  Dim cod As New Collection

  cod.Add("entity", "0") '*
  cod.Add("handle", "5") '*
  cod.Add("style", "6") '*
  cod.Add("layer", "8") '*
  cod.Add("color", "62") '*
  cod.Add("material", "347")
  cod.Add("linewt", "370") '*
  cod.Add("linetype_scale", "48")

  cod.Add("visible", "60") '*
  cod.Add("paper", "67") '*
  cod.Add("flag", "71")
  cod.Add("elev", "38")
  cod.Add("thick", "39")
  cod.Add("x0", "10")
  cod.Add("y0", "20")
  cod.Add("z0", "30")
  cod.Add("x1", "11")
  cod.Add("y1", "21")
  cod.Add("z1", "31")

  cod.Add("x2", "12")
  cod.Add("y2", "22")
  cod.Add("z2", "32")

  cod.Add("x3", "13")
  cod.Add("y3", "23")
  cod.Add("z3", "33")

  ' used in dims
  cod.Add("x4", "14")
  cod.Add("y4", "24")
  cod.Add("z4", "34")

  cod.Add("x5", "15")
  cod.Add("y5", "25")
  cod.Add("z5", "35")

  cod.Add("x6", "16")
  cod.Add("y6", "26")
  cod.Add("z6", "36")

  cod.Add("extrx", "210")
  cod.Add("extry", "220")
  cod.Add("extrz", "230")
  cod.Add("blkid", "330")

  Select String.LCase(ent)

    Case "3dsolid"
      cod.Add("format", "70")

    Case "arc"
      cod.Add("radius", "40")
      cod.Add("start_angle", "50")
      cod.Add("end_angle", "51")

    Case "circle"
      cod.Add("radius", "40")

    Case "ellipse"
      cod.Add("ratio", "40")
      cod.Add("start_angle", "41")
      cod.Add("end_angle", "42")

    Case "lwpolyline"
      cod.Add("points", "90")
      cod.Add("closed", "70")
      cod.Add("constant", "43")

    Case "insert"
      cod.Add("block", "2")
      cod.Add("scalex", "41")
      cod.Add("scaley", "42")
      cod.Add("scalez", "43")
      cod.Add("angle", "50")
      cod.Add("has_attribs", "66")
      cod.Add("column_count", "70")
      cod.Add("row_count", "71")
      cod.Add("column_spacing", "44")
      cod.Add("row_spacing", "45")

    Case "attdef"
      cod.Add("text_height", "40")
      cod.Add("default_value", "1")
      cod.Add("tag", "2")
      cod.Add("promt", "3")
      cod.Add("flen", "73")
      cod.Add("vert", "74")
      cod.Add("angle", "50")
      cod.Add("wfactor", "41")
      cod.Add("tstyle", "7")
      cod.Add("oblique", "51")
      cod.Add("version", "280")

    Case "block"
      cod.Add("xref", "1")
      cod.Add("block", "2")
      cod.Add("bdesc", "4")

    Case "text"
      cod.Add("text_height", "40")
      cod.Add("text", "1")
      cod.Add("hjust", "72")
      cod.Add("vjust", "73")
      cod.Add("angle", "50")
      cod.Add("wfactor", "41")
      cod.Add("tstyle", "7")
      cod.Add("oblique", "51")

    Case "mtext"
      cod.Add("text_height", "40")
      cod.Add("textv", "43")
      cod.Add("text", "1")
      cod.Add("text2", "3")
      cod.Add("attachment_point", "71")
      cod.Add("hjust", "72")
      cod.Add("vjust", "73")
      cod.Add("angle", "50")
      cod.Add("rfactor", "41")
      cod.Add("hfactor", "42")
      cod.Add("lfactor", "44")
      cod.Add("tstyle", "7")
      cod.Add("oblique", "51")

      'Dimensions
    Case "arc_dimension"
      'common
      cod.Add("text", "1")
      cod.Add("block", "2")
      cod.Add("dimstyle", "3")
      cod.Add("version", "280")
      cod.Add("dimtype", "70")
      cod.Add("attachment_point", "71")
      cod.Add("text_style", "72")
      cod.Add("leader_length", "40")
      cod.Add("text_factor", "41")
      cod.Add("measurement", "42")
      cod.Add("rotation_angle", "53")
      cod.Add("horizontal_direction", "51")
      cod.Add("angle_rotated", "50")
      cod.Add("angle_extensions", "52")

  End Select

  Return cod

End

'' Return a colors list by the form r,g,b where each index is the DXF color integer number.

Public Function DWGColors() As String[]

  Dim rgbx As New String[]

  rgbx.Add("0,0,0")
  rgbx.Add("255,0,0")
  rgbx.Add("255,255,0")
  rgbx.Add("0,255,0")
  rgbx.Add("0,255,255")
  rgbx.Add("0,0,255")
  rgbx.Add("255,0,255")
  rgbx.Add("255,255,255")
  rgbx.Add("128,128,128")
  rgbx.Add("192,192,192")
  rgbx.Add("255,0,0")
  rgbx.Add("255,127,127")
  rgbx.Add("165,0,0")
  rgbx.Add("165,82,82")
  rgbx.Add("127,0,0")
  rgbx.Add("127,63,63")
  rgbx.Add("76,0,0")
  rgbx.Add("76,38,38")
  rgbx.Add("38,0,0")
  rgbx.Add("38,19,19")
  rgbx.Add("255,63,0")
  rgbx.Add("255,159,127")
  rgbx.Add("165,41,0")
  rgbx.Add("165,103,82")
  rgbx.Add("127,31,0")
  rgbx.Add("127,79,63")
  rgbx.Add("76,19,0")
  rgbx.Add("76,47,38")
  rgbx.Add("38,9,0")
  rgbx.Add("38,23,19")
  rgbx.Add("255,127,0")
  rgbx.Add("255,191,127")
  rgbx.Add("165,82,0")
  rgbx.Add("165,124,82")
  rgbx.Add("127,63,0")
  rgbx.Add("127,95,63")
  rgbx.Add("76,38,0")
  rgbx.Add("76,57,38")
  rgbx.Add("38,19,0")
  rgbx.Add("38,28,19")
  rgbx.Add("255,191,0")
  rgbx.Add("255,223,127")
  rgbx.Add("165,124,0")
  rgbx.Add("165,145,82")
  rgbx.Add("127,95,0")
  rgbx.Add("127,111,63")
  rgbx.Add("76,57,0")
  rgbx.Add("76,66,38")
  rgbx.Add("38,28,0")
  rgbx.Add("38,33,19")
  rgbx.Add("255,255,0")
  rgbx.Add("255,255,127")
  rgbx.Add("165,165,0")
  rgbx.Add("165,165,82")
  rgbx.Add("127,127,0")
  rgbx.Add("127,127,63")
  rgbx.Add("76,76,0")
  rgbx.Add("76,76,38")
  rgbx.Add("38,38,0")
  rgbx.Add("38,38,19")
  rgbx.Add("191,255,0")
  rgbx.Add("223,255,127")
  rgbx.Add("124,165,0")
  rgbx.Add("145,165,82")
  rgbx.Add("95,127,0")
  rgbx.Add("111,127,63")
  rgbx.Add("57,76,0")
  rgbx.Add("66,76,38")
  rgbx.Add("28,38,0")
  rgbx.Add("33,38,19")
  rgbx.Add("127,255,0")
  rgbx.Add("191,255,127")
  rgbx.Add("82,165,0")
  rgbx.Add("124,165,82")
  rgbx.Add("63,127,0")
  rgbx.Add("95,127,63")
  rgbx.Add("38,76,0")
  rgbx.Add("57,76,38")
  rgbx.Add("19,38,0")
  rgbx.Add("28,38,19")
  rgbx.Add("63,255,0")
  rgbx.Add("159,255,127")
  rgbx.Add("41,165,0")
  rgbx.Add("103,165,82")
  rgbx.Add("31,127,0")
  rgbx.Add("79,127,63")
  rgbx.Add("19,76,0")
  rgbx.Add("47,76,38")
  rgbx.Add("9,38,0")
  rgbx.Add("23,38,19")
  rgbx.Add("0,255,0")
  rgbx.Add("127,255,127")
  rgbx.Add("0,165,0")
  rgbx.Add("82,165,82")
  rgbx.Add("0,127,0")
  rgbx.Add("63,127,63")
  rgbx.Add("0,76,0")
  rgbx.Add("38,76,38")
  rgbx.Add("0,38,0")
  rgbx.Add("19,38,19")
  rgbx.Add("0,255,63")
  rgbx.Add("127,255,159")
  rgbx.Add("0,165,41")
  rgbx.Add("82,165,103")
  rgbx.Add("0,127,31")
  rgbx.Add("63,127,79")
  rgbx.Add("0,76,19")
  rgbx.Add("38,76,47")
  rgbx.Add("0,38,9")
  rgbx.Add("19,38,23")
  rgbx.Add("0,255,127")
  rgbx.Add("127,255,191")
  rgbx.Add("0,165,82")
  rgbx.Add("82,165,124")
  rgbx.Add("0,127,63")
  rgbx.Add("63,127,95")
  rgbx.Add("0,76,38")
  rgbx.Add("38,76,57")
  rgbx.Add("0,38,19")
  rgbx.Add("19,38,28")
  rgbx.Add("0,255,191")
  rgbx.Add("127,255,223")
  rgbx.Add("0,165,124")
  rgbx.Add("82,165,145")
  rgbx.Add("0,127,95")
  rgbx.Add("63,127,111")
  rgbx.Add("0,76,57")
  rgbx.Add("38,76,66")
  rgbx.Add("0,38,28")
  rgbx.Add("19,38,33")
  rgbx.Add("0,255,255")
  rgbx.Add("127,255,255")
  rgbx.Add("0,165,165")
  rgbx.Add("82,165,165")
  rgbx.Add("0,127,127")
  rgbx.Add("63,127,127")
  rgbx.Add("0,76,76")
  rgbx.Add("38,76,76")
  rgbx.Add("0,38,38")
  rgbx.Add("19,38,38")
  rgbx.Add("0,191,255")
  rgbx.Add("127,223,255")
  rgbx.Add("0,124,165")
  rgbx.Add("82,145,165")
  rgbx.Add("0,95,127")
  rgbx.Add("63,111,127")
  rgbx.Add("0,57,76")
  rgbx.Add("38,66,76")
  rgbx.Add("0,28,38")
  rgbx.Add("19,33,38")
  rgbx.Add("0,127,255")
  rgbx.Add("127,191,255")
  rgbx.Add("0,82,165")
  rgbx.Add("82,124,165")
  rgbx.Add("0,63,127")
  rgbx.Add("63,95,127")
  rgbx.Add("0,38,76")
  rgbx.Add("38,57,76")
  rgbx.Add("0,19,38")
  rgbx.Add("19,28,38")
  rgbx.Add("0,63,255")
  rgbx.Add("127,159,255")
  rgbx.Add("0,41,165")
  rgbx.Add("82,103,165")
  rgbx.Add("0,31,127")
  rgbx.Add("63,79,127")
  rgbx.Add("0,19,76")
  rgbx.Add("38,47,76")
  rgbx.Add("0,9,38")
  rgbx.Add("19,23,38")
  rgbx.Add("0,0,255")
  rgbx.Add("127,127,255")
  rgbx.Add("0,0,165")
  rgbx.Add("82,82,165")
  rgbx.Add("0,0,127")
  rgbx.Add("63,63,127")
  rgbx.Add("0,0,76")
  rgbx.Add("38,38,76")
  rgbx.Add("0,0,38")
  rgbx.Add("19,19,38")
  rgbx.Add("63,0,255")
  rgbx.Add("159,127,255")
  rgbx.Add("41,0,165")
  rgbx.Add("103,82,165")
  rgbx.Add("31,0,127")
  rgbx.Add("79,63,127")
  rgbx.Add("19,0,76")
  rgbx.Add("47,38,76")
  rgbx.Add("9,0,38")
  rgbx.Add("23,19,38")
  rgbx.Add("127,0,255")
  rgbx.Add("191,127,255")
  rgbx.Add("82,0,165")
  rgbx.Add("124,82,165")
  rgbx.Add("63,0,127")
  rgbx.Add("95,63,127")
  rgbx.Add("38,0,76")
  rgbx.Add("57,38,76")
  rgbx.Add("19,0,38")
  rgbx.Add("28,19,38")
  rgbx.Add("191,0,255")
  rgbx.Add("223,127,255")
  rgbx.Add("124,0,165")
  rgbx.Add("145,82,165")
  rgbx.Add("95,0,127")
  rgbx.Add("111,63,127")
  rgbx.Add("57,0,76")
  rgbx.Add("66,38,76")
  rgbx.Add("28,0,38")
  rgbx.Add("33,19,38")
  rgbx.Add("255,0,255")
  rgbx.Add("255,127,255")
  rgbx.Add("165,0,165")
  rgbx.Add("165,82,165")
  rgbx.Add("127,0,127")
  rgbx.Add("127,63,127")
  rgbx.Add("76,0,76")
  rgbx.Add("76,38,76")
  rgbx.Add("38,0,38")
  rgbx.Add("38,19,38")
  rgbx.Add("255,0,191")
  rgbx.Add("255,127,223")
  rgbx.Add("165,0,124")
  rgbx.Add("165,82,145")
  rgbx.Add("127,0,95")
  rgbx.Add("127,63,111")
  rgbx.Add("76,0,57")
  rgbx.Add("76,38,66")
  rgbx.Add("38,0,28")
  rgbx.Add("38,19,33")
  rgbx.Add("255,0,127")
  rgbx.Add("255,127,191")
  rgbx.Add("165,0,82")
  rgbx.Add("165,82,124")
  rgbx.Add("127,0,63")
  rgbx.Add("127,63,95")
  rgbx.Add("76,0,38")
  rgbx.Add("76,38,57")
  rgbx.Add("38,0,19")
  rgbx.Add("38,19,28")
  rgbx.Add("255,0,63")
  rgbx.Add("255,127,159")
  rgbx.Add("165,0,41")
  rgbx.Add("165,82,103")
  rgbx.Add("127,0,31")
  rgbx.Add("127,63,79")
  rgbx.Add("76,0,19")
  rgbx.Add("76,38,47")
  rgbx.Add("38,0,9")
  rgbx.Add("38,19,23")
  rgbx.Add("0,0,0")
  rgbx.Add("51,51,51")
  rgbx.Add("102,102,102")
  rgbx.Add("153,153,153")
  rgbx.Add("204,204,204")
  rgbx.Add("255,255,255")
  rgbx.Add("255,255,255")
  rgbx.Add("255,255,255")

  Return rgbx

End

'' Input a DXF color return a RGB color.

Public Function GauchoDecodeColor() As Integer[]

  Dim rgb As New Integer[]

  Dim s As String
  Dim r As String
  Dim g As String
  Dim b As String
  Dim irgb As Integer
  Dim rgbx As String[]

  rgbx = DWGColors()

  For Each s In rgbx
    r = Split(s, ",")[0]
    g = Split(s, ",")[1]
    b = Split(s, ",")[2]
    irgb = Color.RGB(CInt(r), CInt(g), CInt(b))
    rgb.Add(irgb)
  Next

  Return rgb

End

'' Create a collection whith te program variables needed

Public Function GauchoConfig() As Collection

  Dim ctnOut As New Collection
  Dim ctnTmp As New Collection
  Dim str As String
  Dim sBase As String

  sBase = User.Home &/ "." & String.LCase(vag.NoSymbols(Application.Name))

  ctnTmp.Clear

  'Program
  ctnTmp.Clear
  ctnTmp.Add("Application.Directory", "Name")
  ctnTmp.Add(("Program"), "Group")
  ctnTmp.Add(sBase, "Value")
  ctnTmp.Add("String", "Data")
  ctnTmp.Add("dio", "Ctrl")
  ctnTmp.Add(("Application directory"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ctnTmp.Clear
  ctnTmp.Add("Application.window-background-color", "Name")
  ctnTmp.Add(("Program"), "Group")
  ctnTmp.Add("Dark", "Value")
  ctnTmp.Add("String", "Data")
  ctnTmp.Add("cmo~Dark:Light", "Ctrl")
  ctnTmp.Add(("Window background color"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  'Desktop
  ctnTmp.Clear
  ctnTmp.Add("Desktop.Text-Editor", "Name")
  If sog.MimeDefaultApp("text/plain").Count > 0 Then
    str = sog.MimeDefaultApp("text/plain")[0]
  Else
    str = ""
  Endif
  ctnTmp.Add(("Desktop"), "Group")
  ctnTmp.Add(str, "Value")
  ctnTmp.Add("String", "Data")
  ctnTmp.Add("txo", "Ctrl")
  ctnTmp.Add(("Simple text editor by default"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ctnTmp.Clear
  ctnTmp.Add("Desktop.Icons", "Name")
  ctnTmp.Add(("Desktop"), "Group")
  ctnTmp.Add("/usr/share/icons/Numix/32", "Value")
  ctnTmp.Add("String", "Data")
  ctnTmp.Add("dio", "Ctrl")
  ctnTmp.Add(("Program icons"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ' CAD
  ctnTmp.Add("CAD.Background-Dark", "Name")
  ctnTmp.Add("CAD", "Group")
  ctnTmp.Add(False, "Value")
  ctnTmp.Add("Boolean", "Data")
  ctnTmp.Add("cko", "Ctrl")
  ctnTmp.Add(("Drawing window dark mode"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ctnTmp.Add("CAD.DrawOriginals", "Name")
  ctnTmp.Add("CAD", "Group")
  ctnTmp.Add(False, "Value")
  ctnTmp.Add("Boolean", "Data")
  ctnTmp.Add("cko", "Ctrl")
  ctnTmp.Add(("Draw originals"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ctnTmp.Add("CAD.DrawMarcados", "Name")
  ctnTmp.Add("CAD", "Group")
  ctnTmp.Add(True, "Value")
  ctnTmp.Add("Boolean", "Data")
  ctnTmp.Add("cko", "Ctrl")
  ctnTmp.Add(("Draw marked"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ctnTmp.Add("CAD.DrawSoloColumnas", "Name")
  ctnTmp.Add("CAD", "Group")
  ctnTmp.Add(False, "Value")
  ctnTmp.Add("Boolean", "Data")
  ctnTmp.Add("cko", "Ctrl")
  ctnTmp.Add(("Draw only columns"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ctnTmp.Add("CAD.DrawBounds", "Name")
  ctnTmp.Add("CAD", "Group")
  ctnTmp.Add(False, "Value")
  ctnTmp.Add("Boolean", "Data")
  ctnTmp.Add("cko", "Ctrl")
  ctnTmp.Add(("Draw bounds"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ctnTmp.Add("CAD.FormatoCotas", "Name")
  ctnTmp.Add("CAD", "Group")
  ctnTmp.Add("0.00", "Value")
  ctnTmp.Add("String", "Data")
  ctnTmp.Add("txo", "Ctrl")
  ctnTmp.Add(("Dimensions format"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ctnTmp.Add("CAD.ColorForSelected", "Name")
  ctnTmp.Add("CAD", "Group")
  ctnTmp.Add(&H70E000, "Value")
  ctnTmp.Add("String", "Data")
  ctnTmp.Add("txo", "Ctrl")
  ctnTmp.Add(("Color sellection"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ctnTmp.Add("CAD.ToolActive", "Name")
  ctnTmp.Add("CAD", "Group")
  ctnTmp.Add(True, "Value")
  ctnTmp.Add("Boolean", "Data")
  ctnTmp.Add("cko", "Ctrl")
  ctnTmp.Add(("Tool active"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ctnTmp.Add("CAD.Orthogonal", "Name")
  ctnTmp.Add("CAD", "Group")
  ctnTmp.Add(False, "Value")
  ctnTmp.Add("Boolean", "Data")
  ctnTmp.Add("cko", "Ctrl")
  ctnTmp.Add(("Orthogonal"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ctnTmp.Add("CAD.OrthogonalForced", "Name")
  ctnTmp.Add("CAD", "Group")
  ctnTmp.Add(False, "Value")
  ctnTmp.Add("Boolean", "Data")
  ctnTmp.Add("cko", "Ctrl")
  ctnTmp.Add(("Orthogonal forced"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ctnTmp.Add("CAD.OrthogonalIgnored", "Name")
  ctnTmp.Add("CAD", "Group")
  ctnTmp.Add(False, "Value")
  ctnTmp.Add("Boolean", "Data")
  ctnTmp.Add("cko", "Ctrl")
  ctnTmp.Add(("Orthogonal ignored"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  ctnTmp.Add("CAD.flgShowInspector", "Name")
  ctnTmp.Add("CAD", "Group")
  ctnTmp.Add(False, "Value")
  ctnTmp.Add("Boolean", "Data")
  ctnTmp.Add("cko", "Ctrl")
  ctnTmp.Add(("Show inspector"), "Desc")
  str = ctnTmp["Name"]
  ctnOut.Add(ctnTmp.Copy(), str)

  Return ctnOut

End

'DXF ========================================================================

'' Create a list of sections from a DXF file, for this it requires the raw text of the DXF file.

Public Function DXFSections(sFile As String) As Collection

  Dim sContent As String
  Dim tmx As New String[]
  Dim sec As String
  Dim sSub As String
  Dim out As New Collection
  Dim sName As String
  Dim sCont As String
  Dim cCont As New Collection
  Dim isec As Variant

  If Exist(sFile) Then
    If Stat(sFile).Type = gb.File Then
      sContent = File.Load(sFile)
      sSub = String.Mid(sContent, 1, 25)

      out.Add(File.Name(sFile), "File")

      sContent = Replace(sContent, "\r\n", "\n")
      sContent = Replace(sContent, "\t", " ")
      sContent = Replace(sContent, "  0\nSECTION\n  2\n", "\t")
      sContent = Replace(sContent, "  0\nENDSEC\n", "\t")
      tmx = Split(sContent, "\t")

      If tmx.count > 0 Then
        For Each sec In tmx
          If sec <> "" Then
            'File.Save(User.Home &/ ".txt", sec)
            sName = Split(sec, "\n")[0]
            sCont = String.Mid(sec, String.Len(sName & "\n") + 1)

            Select sName
              Case "HEADER"
                cCont = DXFHeader(sCont)
                If cCont.Exist("ACADVER") Then
                  out.Add(cCont["ACADVER"], "version")
                Endif
                out.Add(cCont, "Variables")

              Case "TABLES"
                cCont = DXFTables(sCont)
                For Each isec In cCont
                  out.Add(isec.Copy(), cCont.Key)
                Next

              Case "BLOCKS"
                cCont = DXFBlocks(sCont)
                out.Add(cCont, "Blocks")

              Case "ENTITIES"
                cCont = DXFEntities(sCont)
                out.Add(cCont, "Entities")

            End Select

          Endif
        Next
      Endif
    Endif
  Endif

  Return out

End

'' Creates a list of blocks from a DXF file, for this it requires the raw text of the DXF file.

Public Function DXFBlocks(sCont As String) As Collection

  Dim stx As New String[]
  Dim out As New Collection
  Dim i As Integer
  Dim cItem As New Collection

  sCont = Replace(sCont, "\t", " ")
  sCont = Replace(sCont, "  0\nBLOCK\n", "\t  0\nBLOCK\n")

  stx = Split(sCont, "\t")

  For i = 0 To stx.Max
    If InStr(stx[i], "AcDbBlockBegin") > 0 Then
      If String2.Count(stx[i], "\n  0\n") > 1 And InStr(stx[i], "  0\nVIEWPORT") = 0 Then
        cItem = DXFDecodeBlock(stx[i])
        If cItem.Count > 1 Then
          out.Add(cItem.Copy(), cItem["block"])
          cItem.Clear
        Endif
      Endif
    Endif
  Next
  Return out

End

'' Creates a list of entities from a DXF file, for this it requires the raw text of the DXF file.

Public Function DXFEntities(sCont As String) As Collection

  Dim stx As New String[]
  Dim out As New Collection
  Dim sout As New Collection
  Dim i As Integer
  Dim cItem As New Collection
  Dim sKey As String
  Dim cEnty As Collection
  Dim eN As Variant

  cEnty = DWGEntityList()

  sCont = Replace(sCont, "\t", " ")

  For Each eN In cEnty
    sCont = Replace(sCont, "  0\n" & cEnty.Key & "\n  5\n", "\t  0\n" & cEnty.Key & "\n  5\n")
  Next

  stx = Split(sCont, "\t")

  For i = 0 To stx.Max
    If InStr(stx[i], "\n100\nAcDbEntity\n") > 0 Then
      cItem.Clear
      cItem = DXFDecodeItem(stx[i])
      cItem.Add(CStr(i), "id")
      If cItem.Count > 1 Then
        sKey = ""
        If cItem.Exist("id") Then
          sKey = cItem["entity"] & ":" & cItem["id"]
          out.Add(cItem.Copy(), sKey)
        Endif
      Endif
    Endif
    APPMain.Progress(stx.Count, i)
  Next

  sout = GauchoEntitiesSort(out)

  Return sout

End

'' Sorts the list of entities previously generated that is passed as a parameter.

Public Function GauchoEntitiesSort(c As Collection) As Collection

  Dim stx As New String[]
  Dim eName As String
  Dim eType As String
  Dim tmp As New Collection
  Dim out As New Collection
  Dim ety As Variant

  For Each ety In c
    If ety.Exist("entity") Then
      eName = String.LCase(ety["entity"])
      eType = "entity"
    Else
      If ety.Exist("object") Then
        eName = String.LCase(ety["object"])
        eType = "object"
      Endif
    Endif

    If stx.Exist(eName) = False Then
      stx.Add(eName)
    Endif
  Next

  stx.Sort

  For Each eName In stx
    For Each ety In c
      If eName = String.LCase(ety["entity"]) Or eName = String.LCase(ety["object"]) Then
        If ety.Exist("handle") Then
          Select TypeOf(ety["handle"])
            Case gb.Object
              If ety["handle"] Is Variant[] Then
                tmp.Add(ety, ety["handle"][1])
              Endif
            Case Else
              tmp.Add(ety, ety["handle"])
          End Select
        Endif
      Endif
    Next
    out.Add(tmp.Copy(), eName)
    tmp.Clear
  Next

  Return out

End

'' Creates a list of headers from a DXF file, for this it requires the raw text of the DXF file.

Public Function DXFHeader(sCont As String) As Collection

  Dim stx As New String[]
  Dim cTmp As New Collection
  Dim out As New Collection
  Dim item As String
  Dim vrt As Variant

  sCont = Replace(sCont, "  9\n$", "\t")

  stx = Split(sCont, "\t")

  For Each item In stx
    If item <> "" Then
      If TypeOf(item) = gb.String Then
        cTmp = DXFDecodeHeader(item)

        Select cTmp.Count
          Case 0
            'skip
          Case 1
            For Each vrt In cTmp
              out.Add(vrt, cTmp.Key)
            Next
        End Select
      Endif

    Endif
  Next
  Return out

End

'' Creates a list of tables from a DXF file, for this it requires the raw text of the DXF file.

Public Function DXFTables(sCont As String) As Collection

  Dim stx As New String[]
  Dim cDecoded As New Collection
  Dim out As New Collection
  Dim item As String

  sCont = Replace(sCont, "\t", " ")
  sCont = Replace(sCont, "  0\nTABLE\n  2\n", "\t")
  sCont = Replace(sCont, "  0\nENDTAB\n", "\t")

  stx = Split(sCont, "\t")

  For Each item In stx
    If item <> "" Then
      If InStr(item, "\n  5\n") > 0 Then
        Select Split(item, "\n")[0]
          Case "LAYER"
            cDecoded = DXFLayerList(item)
            out.Add(cDecoded.Copy(), "Layers")
            cDecoded.Clear
          Case "LTYPE"
            cDecoded = DXFLtypeList(item)
            out.Add(cDecoded.Copy(), "LineTypes")
            cDecoded.Clear
          Case "STYLE"
            cDecoded = DXFStyleList(item)
            out.Add(cDecoded.Copy(), "TextStyles")
            cDecoded.Clear
          Case "DIMSTYLE"
            cDecoded = DXFDimStyleList(item)
            out.Add(cDecoded.Copy(), "DimStyles")
            cDecoded.Clear
        End Select
      Endif
    Endif
  Next
  Return out

End

'' Creates a list of layers from a DXF file, for this it requires the text in the LAYER section in tables.

Private Function DXFLayerList(sItem As String) As Collection

  Dim stx As String[]
  Dim i As Integer
  Dim sCont As String
  Dim cTmp As New Collection
  Dim cDeco As New Collection
  Dim sLay As String
  Dim slx As String[]
  Dim sTag As String
  Dim sVal As String
  Dim j As Integer

  sCont = Replace(sItem, "\t", " ")
  sCont = Replace(sCont, "LAYER\n  5\n", "\t")
  sCont = Replace(sCont, "100\nAcDbSymbolTableRecord\n100\n", "\t")
  '
  stx = Split(sCont, "\t")

  For i = 0 To stx.Max
    If InStr(stx[i], "AcDbLayerTableRecord\n  2\n") > 0 Then
      sLay = Replace(stx[i], "AcDbLayerTableRecord\n  2\n", "")
      slx = Split(slay, "\n")

      cTmp.Add(slx[0], "name")

      For j = 1 To slx.Max - 2 Step 2
        sTag = Replace(slx[j], " ", "")
        sVal = Replace(slx[j + 1], " ", "")
        Select sTag
          Case "70"
            Select sVal
              Case "1"
                cTmp.Add(True, "frozen")
                cTmp.Add(False, "locked")
              Case "4"
                cTmp.Add(False, "frozen")
                cTmp.Add(True, "locked")
              Case Else
                cTmp.Add(False, "locked")
                cTmp.Add(False, "frozen")
            End Select
          Case "62"
            If InStr(sVal, "-") = 0 Then
              cTmp.Add(True, "show")
              cTmp.Add(CInt(sVal), "color")
            Else
              cTmp.Add(False, "show")
              cTmp.Add(CInt(Replace(sVal, "-", "")), "color")
            Endif

          Case "6"
            cTmp.Add(sVal, "style")

          Case "290"
            If sVal = 0 Then
              cTmp.Add(False, "print")
            Else
              cTmp.Add(True, "print")
            Endif

          Case "370"
            cTmp.Add(CInt(sVal), "linewt")

        End Select
        If cTmp.Exist("print") = False Then
          cTmp.Add(True, "print")
        Endif

      Next

      cDeco.Add(cTmp.Copy(), slx[0])
      cTmp.Clear

    Endif

  Next

  Return cDeco

End

Private Function DXFLtypeList(sItem As String) As Collection

  Dim stx As String[]
  Dim i As Integer
  Dim sCont As String
  Dim cTmp As New Collection
  Dim cDeco As New Collection
  Dim sLay As String
  Dim slx As String[]
  Dim sTag As String
  Dim sVal As String
  Dim j As Integer

  sCont = Replace(sItem, "\t", " ")
  sCont = Replace(sCont, "LTYPE\n  5\n", "\t")
  sCont = Replace(sCont, "100\nAcDbSymbolTableRecord\n100\n", "\t")
  '
  stx = Split(sCont, "\t")

  For i = 0 To stx.Max
    If InStr(stx[i], "AcDbLinetypeTableRecord\n  2\n") > 0 Then
      sLay = Replace(stx[i], "AcDbLinetypeTableRecord\n  2\n", "")
      slx = Split(slay, "\n")

      cTmp.Add(slx[0], "Ltype")

      For j = 1 To slx.Max - 2 Step 2
        sTag = Replace(slx[j], " ", "")
        sVal = Replace(slx[j + 1], " ", "")
        Select sTag

          Case "3"
            cTmp.Add(sVal, "desc")

          Case "72"
            cTmp.Add(vag.CInt(sVal), "align")

          Case "73"
            cTmp.Add(vag.CInt(sVal), "elements")

          Case "40"
            cTmp.Add(vag.CFloat(sVal), "patern")

        End Select

      Next

      cDeco.Add(cTmp.Copy(), slx[0])
      cTmp.Clear

    Endif

  Next

  Return cDeco

End

'' Creates a list of styles from a DXF file, for this it requires the text in the STYLE section in tables.

Private Function DXFStyleList(sItem As String) As Collection

  Dim stx As String[]
  Dim i As Integer
  Dim sCont As String
  Dim cTmp As New Collection
  Dim cDeco As New Collection
  Dim sLay As String
  Dim slx As String[]
  Dim sTag As String
  Dim sVal As String
  Dim j As Integer

  sCont = Replace(sItem, "\t", " ")
  sCont = Replace(sCont, "STYLE\n  5\n", "\t")
  sCont = Replace(sCont, "100\nAcDbSymbolTableRecord\n100\n", "\t")
  '
  stx = Split(sCont, "\t")

  For i = 0 To stx.Max
    If InStr(stx[i], "AcDbTextStyleTableRecord\n  2\n") > 0 Then
      sLay = Replace(stx[i], "AcDbTextStyleTableRecord\n  2\n", "")
      slx = Split(slay, "\n")

      cTmp.Add(slx[0], "Style")

      For j = 1 To slx.Max - 2 Step 2
        sTag = Replace(slx[j], " ", "")
        sVal = Replace(slx[j + 1], " ", "")
        Select sTag
          Case "70"
            Select sVal
              Case "1"
                cTmp.Add(True, "shape")
              Case "4"
                cTmp.Add(True, "vertical")
            End Select
          Case "40"
            cTmp.Add(vag.CFloat(sVal), "fixed")

          Case "41"
            cTmp.Add(vag.CFloat(sVal), "wfactor")

          Case "50"
            cTmp.Add(vag.CFloat(sVal), "oblique")

          Case "71"
            Select sVal
              Case "2"
                cTmp.Add(True, "mirrored_x")
              Case "4"
                cTmp.Add(True, "mirrored_y")
            End Select

          Case "42"
            cTmp.Add(vag.CFloat(sVal), "last")

          Case "3"
            cTmp.Add(sVal, "font")
          Case "4"

            If sVal <> "" Then
              cTmp.Add(sVal, "fbig")
            Endif

        End Select

      Next

      cDeco.Add(cTmp.Copy(), slx[0])
      cTmp.Clear

    Endif

  Next

  Return cDeco

End

'' Creates a list of dimension styles from a DXF file, for this it requires the text in the  DIMSTYLE section in tables.

Private Function DXFDimStyleList(sItem As String) As Collection

  Dim stx As String[]
  Dim i As Integer
  Dim sCont As String
  Dim cTmp As New Collection
  Dim cDeco As New Collection
  Dim sLay As String
  Dim slx As String[]
  Dim sTag As String
  Dim sVal As String
  Dim j As Integer
  Dim code As Collection

  code = DWGDimCodes()

  sCont = Replace(sItem, "\t", " ")
  sCont = Replace(sCont, "STYLE\n  5\n", "\t")
  sCont = Replace(sCont, "100\nAcDbSymbolTableRecord\n100\n", "\t")
  '
  stx = Split(sCont, "\t")

  For i = 0 To stx.Max
    If InStr(stx[i], "AcDbDimStyleTableRecord\n  2\n") > 0 Then
      sLay = Replace(stx[i], "AcDbDimStyleTableRecord\n  2\n", "")
      slx = Split(slay, "\n")

      cTmp.Add(slx[0], "DimStyle")

      For j = 1 To slx.Max - 2 Step 2
        sTag = Replace(slx[j], " ", "")
        sVal = Replace(slx[j + 1], " ", "")
        If code.Exist(sTag) Then
          Select code[sTag][1]
            Case "string"
              cTmp.Add(sVal, code[sTag][0])
            Case "float"
              cTmp.Add(vag.CFloat(sVal), code[sTag][0])
          End Select
        Endif
      Next
      cDeco.Add(cTmp.Copy(), slx[0])
      cTmp.Clear
    Endif
  Next

  Return cDeco

End

'' Creates a list of blocks from a DXF file, for this it requires the text in the BLOCK section in tables.

Private Function DXFBLockList(sItem As String) As Collection

  Dim stx As String[]
  Dim i As Integer
  Dim sCont As String
  Dim cTmp As New Collection
  Dim cDeco As New Collection
  Dim sLay As String
  Dim slx As String[]
  Dim sTag As String
  Dim sVal As String
  Dim j As Integer

  sCont = Replace(sItem, "\t", " ")
  sCont = Replace(sCont, "BLOCK_RECORD\n  5\n", "\t")
  sCont = Replace(sCont, "100\nAcDbSymbolTableRecord\n100\n", "\t")
  '
  stx = Split(sCont, "\t")

  For i = 0 To stx.Max
    If InStr(stx[i], "AcDbBlockTableRecord\n  2\n") > 0 Then
      sLay = Replace(stx[i], "AcDbBlockTableRecord\n  2\n", "")
      slx = Split(slay, "\n")

      cTmp.Add(slx[0], "Block")

      For j = 1 To slx.Max - 2 Step 2
        sTag = Replace(slx[j], " ", "")
        sVal = Replace(slx[j + 1], " ", "")
        Select sTag

          Case "70"
            cTmp.Add(sVal, "units")

          Case "340"
            cTmp.Add(CInt(sVal), "handle")

        End Select

      Next

      cDeco.Add(cTmp.Copy(), slx[0])
      cTmp.Clear

    Endif

  Next

  Return cDeco

End

'' Create a list with all the information of a DXF entity.

Private Function DXFDecodeEntity(sItem As String) As Collection

  Dim stx As String[]
  Dim cTmp As New Collection
  Dim cTmp2 As New Collection
  Dim i As Integer
  Dim sTag As String
  Dim Entity As String
  Dim sVal As String
  Dim codes As New Collection
  Dim rep As New Collection
  Dim e As Variant
  Dim xTag As String
  Dim xOrd As String
  Dim pt As String
  Dim spt As New String[]
  Dim cp As New Collection
  Dim a0 As Float
  Dim a1 As Float
  Dim r As Float
  Dim sx As Float
  Dim sy As Float
  Dim sz As Float
  Dim tg As Variant
  Dim flo As Float
  Dim int As Integer

  stx = Split(sItem, "\n")

  If stx[0] = "  0" Then
    sTag = "entity"
    sVal = stx[1]
    cTmp.Add(sVal, sTag)
    codes = DXFEntityCodes(sVal)
  Endif

  For i = 0 To stx.Max Step 2
    If stx[i] <> "" Then
      sTag = Replace(stx[i], " ", "")
      If codes.Exist(sTag) Then
        sTag = codes[sTag]
      Endif
      If rep.Exist(sTag) = False Then
        rep.Add([1, 0], sTag)
      Else
        rep[sTag][0] = rep[sTag][0] + 1
      Endif
    Endif
  Next

  For i = 0 To stx.Max Step 2
    If stx[i] = "  0" Then
      Entity = ""
      cTmp.Clear
      sVal = stx[i + 1]
      cTmp.Add(sVal, "entity")
    Else
      If stx[i] <> "" Then
        sTag = Replace(stx[i], " ", "")
        If codes.Exist(sTag) Then
          sTag = codes[sTag]
        Endif

        sVal = stx[i + 1]

        If rep.Exist(sTag) And rep[sTag][0] > 1 Then
          rep[sTag][1] = rep[sTag][1] + 1
          cTmp.Add(sVal, sTag & "." & CStr(rep[sTag][1]))
        Else
          cTmp.Add(sVal, sTag)
        Endif

      Endif
    Endif
  Next

  If cTmp.Exist("style") = False Then
    cTmp.Add(0, "style")
  Endif

  If cTmp.Exist("linewt") = False Then
    cTmp.Add(0, "linewt")
  Endif

  If cTmp.Exist("color") = False Then
    cTmp.Add(0, "color")
  Endif

  If cTmp.Exist("x0") Or cTmp.Exist("x0.1") Then
    spt.Clear
    For Each e In cTmp
      If InStr(cTmp.Key, "x0") > 0 Or InStr(cTmp.Key, "x1") > 0 Then

        If InStr(cTmp.Key, ".") > 0 Then
          xTag = Split(cTmp.Key, ".")[0]
          xOrd = "." & Split(cTmp.Key, ".")[1]
        Else
          xTag = cTmp.Key
          xOrd = ""
        Endif

        Select xTag
          Case "x0"
            pt = cTmp[cTmp.Key]
            If cTmp.Exist("y0" & xOrd) Then
              pt &= ":" & cTmp["y0" & xOrd]
            Endif
            If cTmp.Exist("z0" & xOrd) Then
              pt &= ":" & cTmp["z0" & xOrd]
            Endif
            spt.Add(pt)
          Case "x1"
            pt = cTmp[cTmp.Key]
            If cTmp.Exist("y1" & xOrd) Then
              pt &= ":" & cTmp["y1" & xOrd]
            Endif
            If cTmp.Exist("z1" & xOrd) Then
              pt &= ":" & cTmp["z1" & xOrd]
            Endif
            spt.Add(pt)
        End Select
      Endif

      Select cTmp.Key
        Case "entity", "handle", "layer", "style", "linewt", "color", "blkid", "visible", "paper", "elev", "thick"
          cTmp2.Add(cTmp[cTmp.Key], cTmp.Key)
      End Select

    Next
    cp = GauchoEncodePoint(spt.Join(";"), "p")
    cTmp2.Add(cp.Copy(), "p")
    cp.Clear

    Select cTmp["entity"]

      Case "BLOCK"
        If cTmp.Exist("block") Then
          cTmp2.Add(cTmp["block"], "block")
        Else
          cTmp2.Add("", "block")
        Endif
        If cTmp.Exist("bdesc") Then
          cTmp2.Add(cTmp["bdesc"], "bdesc")
        Else
          cTmp2.Add("", "bdesc")
        Endif

      Case "ELLIPSE", "CIRCLE", "ARC"
        If cTmp.Exist("ratio") Then ' For ellipse
          r = vag.CFloat(cTmp["ratio"])
          cTmp2.Add(r, "ratio")
        Endif

        If cTmp.Exist("radius") Then ' For circle and arc
          r = vag.CFloat(cTmp["radius"])
          cTmp2.Add(r, "radius")
        Endif

        If cTmp.Exist("angle0") And cTmp.Exist("angle1") Then ' For ellipse and arc
          a0 = vag.CFloat(cTmp["angle0"])
          a1 = vag.CFloat(cTmp["angle1"])
          cTmp2.Add(a0, "start_angle")
          cTmp2.Add(a1, "end_angle")
        Else
          cTmp2.Add(0.0, "start_angle")
          cTmp2.Add(0.0, "end_angle")
        Endif

      Case "INSERT"

        If cTmp.Exist("block") Then
          cTmp2.Add(cTmp["block"], "block")
        Else
          cTmp2.Add("", "block")
        Endif

        If cTmp.Exist("angle") Then
          flo = vag.CFloat(cTmp["angle"])
          cTmp2.Add(flo, "angle")
        Else
          cTmp2.Add(0.0, "angle")
        Endif

        If cTmp.Exist("scalex") Then
          flo = vag.CFloat(cTmp["scalex"])
          sx = flo
        Else
          sx = 1.0
        Endif

        If cTmp.Exist("scaley") Then
          flo = vag.CFloat(cTmp["scaley"])
          sy = flo
        Else
          sy = 1.0
        Endif

        If cTmp.Exist("scalez") Then
          flo = vag.CFloat(cTmp["scalez"])
          sz = flo
        Else
          sz = 1.0
        Endif

        cTmp2.Add([sx, sy, sz], "scale")

        If cTmp.Exist("columns") Then
          cTmp2.Add(CInt(cTmp["columns"]), "co")
        Else
          cTmp2.Add(1, "co")
        Endif

        If cTmp.Exist("rows") Then
          int = vag.CInt(cTmp["rows"])
          cTmp2.Add(int, "ro")
        Else
          cTmp2.Add(1, "ro")
        Endif

        If cTmp.Exist("cspace") Then
          flo = vag.CFloat(cTmp["cspace"])
          cTmp2.Add(flo, "cs")
        Else
          cTmp2.Add(0.0, "cs")
        Endif

      Case "TEXT"
        For Each tg In cTmp

          Select cTmp.Key

            Case "texth"
              flo = vag.CFloat(tg)
              cTmp2.Add(flo, "height")
            Case "text"
              cTmp2.Add(CStr(tg), "text")
            Case "hjust"
              int = vag.CInt(tg)
              cTmp2.Add(int, "just_h")

            Case "vjust"
              int = vag.CInt(tg)
              cTmp2.Add(int, "just_v")

            Case "angle"
              flo = vag.CFloat(tg)
              cTmp2.Add(flo, "angle")

            Case "wfactor"
              flo = vag.CFloat(tg)
              cTmp2.Add(flo, "wfactor")

            Case "tstyle"
              cTmp2.Add(CStr(tg), "font")

            Case "oblique"
              flo = vag.CFloat(tg)
              cTmp2.Add(flo, "oblique")

          End Select
        Next

        If cTmp2.Exist("angle") = False Then
          cTmp2.Add(0, "angle")
        Endif

      Case "MTEXT"
        For Each tg In cTmp

          Select cTmp.Key

            Case "texth"
              flo = vag.CFloat(tg)
              cTmp2.Add(flo, "height")
            Case "text"
              If cTmp.Exist("text2") Then
                cTmp2.Add(CStr(tg) & cTmp["text2"], "text")
              Else
                cTmp2.Add(CStr(tg), "text")
              Endif

            Case "angle"
              flo = vag.CFloat(tg)
              cTmp2.Add(flo, "angle")

          End Select
        Next

        If cTmp2.Exist("angle") = False Then
          cTmp2.Add(0, "angle")
        Endif

      Case Else
        For Each tg In cTmp
          cTmp2.Add(tg, cTmp.Key)
        Next
    End Select

    cTmp2.Add(0, "linewt")

    Return cTmp2
  Else
    Return cTmp
  Endif

End

''Creates a collection With the entities that make up a block.

Private Function DXFDecodeBlock(sItem As String) As Collection

  Dim sCont As String
  Dim btx As String[]
  Dim raw As New Collection       '' List all the entities including the block and endblk at the same level
  Dim out As New Collection       '' List returned by the function that represent the block and its contents
  Dim parts As New Collection     '' List of all entities in the block
  Dim i As Integer
  Dim cTmp As Collection
  Dim cEnty As Collection
  Dim eN As Variant
  Dim rw As Variant
  Dim bl As Variant

  cEnty = DWGEntityList()

  sCont = Replace(sItem, "\t", " ")

  For Each eN In cEnty
    sCont = Replace(sCont, "  0\n" & cEnty.Key & "\n  5\n", "\t  0\n" & cEnty.Key & "\n  5\n")
  Next

  btx = Split(sCont, "\t")

  For i = 0 To btx.Max
    If InStr(btx[i], "100\nAcDbEntity") > 0 Then
      cTmp = DXFDecodeItem(btx[i])

      If cTmp.Count > 0 Then
        If cTmp.Exist("handle") Then
          raw.Add(cTmp.Copy(), cTmp["handle"])
        Endif
      Endif

      cTmp.Clear
    Endif

  Next
  cTmp.Clear
  For Each rw In raw
    Select rw["entity"]
      Case "BLOCK"
        For Each bl In rw
          out.Add(bl, rw.Key)
        Next

      Case Else

        For Each bl In rw
          cTmp.Add(bl, rw.Key)
        Next
        parts.Add(cTmp.Copy(), rw["handle"])
        cTmp.Clear

    End Select
  Next

  If parts.Count > 0 Then
    out.Add(parts.Copy(), "Entities")
  Endif

  Return out

End

'' Create a list with the information it decodes from a DXF entity.

Public Function DXFDecodeItem(sItem As String) As Collection

  Dim stx As String[]
  Dim cTmp As New Collection
  Dim i As Integer
  Dim vrt As Variant
  Dim sTag As String
  Dim codes As Collection
  Dim sVal As String
  Dim sKey As String
  Dim cPts As New Collection
  Dim p As Variant
  Dim df As Variant
  Dim defaults As New Collection
  Dim str As String

  stx = Split(sItem, "\n")

  If stx[0] = "  0" Then
    sTag = "entity"
    sVal = stx[1]
    If sVal = "LWPOLYLINE" Then
      Print "x"
    Endif
    cTmp.Add(sVal, sTag)
    codes = DXFEntityCodes(sVal)
    defaults = DXFEntityDefaults(sVal)
  Endif

  For i = 0 To stx.Max - 1 Step 2
    sKey = Replace(stx[i], " ", "")
    sTag = sKey
    Select sKey
      Case "1", "3", "5", "6", "8"
        If codes.Exist(sKey) Then
          sTag = codes[sKey]
        Endif
        vrt = stx[i + 1]
        cTmp.Add(vrt, sTag)
      Case "70", "62", "66", "370", "280", "290", "380", "90"
        If codes.Exist(sKey) Then
          sTag = codes[sKey]
        Endif
        str = Replace(stx[i + 1], " ", "")
        vrt = CInt(str)
        cTmp.Add(vrt, sTag)

      Case "40", "50", "41", "42", "43"
        If codes.Exist(sKey) Then
          sTag = codes[sKey]
        Endif
        str = Replace(stx[i + 1], " ", "")

        vrt = vag.CFloat(str)
        cTmp.Add(vrt, sTag)
      Case "10", "20", "30", "11", "21", "31" ' coordenadas habituales
        If codes.Exist(sKey) Then
          sTag = codes[sKey]
        Endif
        vrt = stx[i + 1]
        cTmp.Add(vrt, sTag)

      Case "12", "22", "32", "13", "23", "33" ' coordenadas extras
        If codes.Exist(sKey) Then
          sTag = codes[sKey]
        Endif
        vrt = stx[i + 1]
        cTmp.Add(vrt, sTag)

      Case "14", "24", "34", "15", "25", "35" ' coordenadas de dimensiones

      Case "16", "26", "36", "17", "27", "37" ' coordenadas de dimensiones

      Case "100"
        'skip

      Case Else
        If codes.Exist(sKey) Then
          sTag = codes[sKey]
        Endif

        vrt = stx[i + 1]
        cTmp.Add(vrt, sTag)

    End Select
  Next

  'Check defalults
  For Each df In defaults
    If codes.Exist(defaults.Key) Then
      sTag = codes[defaults.Key]
    Else
      sTag = defaults.Key
    Endif
    If cTmp.Exist(sTag) = False Then
      cTmp.Add(df, sTag)
    Endif

  Next

  cPts = DXFDecodeCoords(sItem)

  If cPts Then
    For Each p In cPts
      cTmp.Add(p.Copy(), cPts.Key)
    Next
  Endif

  Return cTmp

End

'' Create a list with the coords decodes from a DXF entity.

Public Function DXFDecodeCoords(sItem As String) As Collection

  Dim stx As String[]
  Dim c As New Collection
  Dim p As New Collection
  Dim i As Integer
  Dim vrt As Variant
  Dim sTag As String
  Dim codes As Collection
  Dim sVal As String
  Dim sKey As String
  Dim rep As New Collection
  Dim spt As New String[]
  Dim e As Variant
  Dim xTag As String
  Dim xOrd As String
  Dim pt As Variant
  Dim cp As Collection
  Dim ptx As New String[]
  Dim k As Integer
  Dim tp As String
  Dim str As String

  stx = Split(sItem, "\n")

  ptx = ["x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7"]

  If stx[0] = "  0" Then
    sVal = stx[1]
    codes = DXFEntityCodes(sVal)
  Endif

  For i = 0 To stx.Max - 1 Step 2
    sKey = Replace(stx[i], " ", "")
    Select sKey

      Case "10", "20", "30", "11", "21", "31", "12", "22", "32", "13", "23", "33", "14", "24", "34", "15", "25", "35", "16", "26", "36", "17", "27", "37"
        If codes.Exist(sKey) Then
          sTag = codes[sKey]
        Else
          sTag = sKey
        Endif

        str = Replace(stx[i + 1], " ", "")
        vrt = vag.CFloat(str)
        c.Add(vrt, sTag)
    End Select
  Next

  For i = 0 To stx.Max Step 2
    If stx[i] <> "" Then
      sTag = Replace(stx[i], " ", "")
      If codes.Exist(sTag) Then
        sTag = codes[sTag]
      Endif
      If rep.Exist(sTag) = False Then
        rep.Add([1, 0], sTag)
      Else
        rep[sTag][0] = rep[sTag][0] + 1
      Endif
    Endif
  Next

  For i = 0 To stx.Max Step 2
    sKey = Replace(stx[i], " ", "")
    Select sKey

      Case "10", "20", "30", "11", "21", "31", "12", "22", "32", "13", "23", "33", "14", "24", "34", "15", "25", "35", "16", "26", "36", "17", "27", "37"
        If codes.Exist(sKey) Then
          sTag = codes[sKey]
        Else
          sTag = sKey
        Endif
        str = Replace(stx[i + 1], " ", "")
        vrt = vag.CFloat(str)
        If rep.Exist(sTag) And rep[sTag][0] > 1 Then
          rep[sTag][1] = rep[sTag][1] + 1
          c.Add(vrt, sTag & "." & CStr(rep[sTag][1]))
        Else
          c.Add(vrt, sTag)
        Endif
    End Select
  Next

  If c.Exist("x0") Or c.Exist("x0.1") Then
    spt.Clear
    For Each e In c
      For Each tp In ptx
        If InStr(c.Key, tp) > 0 Then

          If InStr(c.Key, ".") > 0 Then
            xTag = Split(c.Key, ".")[0]
            xOrd = "." & Split(c.Key, ".")[1]
          Else
            xTag = c.Key
            xOrd = ""
          Endif

          If ptx.Exist(xTag) Then
            k = ptx.Find(xTag)
            pt = c[c.Key]
            If c.Exist("y" & CStr(k) & xOrd) Then
              pt &= ":" & c["y" & CStr(k) & xOrd]
            Endif
            If c.Exist("z" & CStr(k) & xOrd) Then
              pt &= ":" & c["z" & CStr(k) & xOrd]
            Endif
            spt.Add(pt)
          Endif
        Endif
      Next
    Next
    cp = GauchoEncodePoint(spt.Join(";"), "p")
    p.Add(cp.Copy(), "p")
    cp.Clear
  Endif
  Return p

End

'' Create a list with the headers decodes from a DXF entity.

Private Function DXFDecodeHeader(sItem As String) As Collection

  Dim stx As String[]
  Dim cTmp As New Collection
  Dim i As Integer
  Dim vrt As Variant
  Dim sTag As String
  Dim x As Float
  Dim y As Float
  Dim z As Float

  stx = Split(sItem, "\n")

  If stx.Count = 4 Then
    sTag = stx[0]

    If InStr(sTag, "INTERFERECOLOR") > 0 Then
      Print "milestone"
    Endif

    For i = 1 To stx.Max Step 2
      Select Replace(stx[i], " ", "")
        Case "1", "2", "3", "5", "6", "7" "8"
          vrt = vag.CFloat(stx[i] + 1)
        Case "70", "62", "370", "280", "290", "380", "390"
          vrt = vag.CInt(stx[i] + 1)
        Case "345", "346", "349"
          vrt = stx[i + 1]
        Case "40", "50"
          vrt = vag.CFloat(stx[i] + 1)

        Case "10"
          vrt = vag.CFloat(stx[i] + 1)

          If Replace(stx[i + 2], " ", "") = "20" Then
            y = vag.CFloat(stx[i] + 3)

          Endif

          If Replace(stx[i + 4], " ", "") = "30" Then
            z = vag.CFloat(stx[i] + 5)
          Endif
          vrt = [x, y, z]
      End Select
      If vrt Then
        cTmp.Add(vrt, sTag)
        Print "Ok : " & sTag
      Else
        Print "Error in : " & sTag
      Endif
    Next
  Endif

  Return cTmp

End
