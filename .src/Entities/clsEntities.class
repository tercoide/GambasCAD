' Gambas class file

' m-designer
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA

Create Static

Public inxBuffersID As New Integer[]

Public Sub DrawArrays()

    Dim iError, vOffset, nOffset, cOffset, tOffset As Integer

    If inxBuffersID.Count = 0 Then Return

    glx.glBindBuffer(glc.ARRAY_BUFFER, inxBuffersID[0])

    iError = glx.glGetError()
    If iError <> 0 Then Print "GL Error:", iError
    glx.glEnableClientState(glc.VERTEX_ARRAY)
    glx.glEnableClientState(glc.NORMAL_ARRAY)
    glx.glEnableClientState(glc.COLOR_ARRAY)

    iError = glx.glGetError()
    If iError <> 0 Then Print "GL Error:", iError

    vOffset = 0
    nOffset = glPlus.VBO_vertex.Count * SizeOf(gb.Single)
    cOffset = nOffset + glPlus.VBO_normals.Count * SizeOf(glPlus.VBO_normals.Type)
    'tOffset = cOffset + sizeof colors

    glx.glVertexPointer(3, glc.FLOAT, 0, vOffset)
    glx.glNormalPointer(glc.FLOAT, 0, nOffset)
    glx.glColorPointer(3, glc.FLOAT, 0, cOffset)

    iError = glx.glGetError()
    If iError <> 0 Then Print "GL Error:", iError

    glx.glDrawArrays(glc.LINES, 0, glPlus.VBO_vertex.Count * 3)

    glx.gldisableClientState(glc.VERTEX_ARRAY)
    glx.gldisableClientState(glc.NORMAL_ARRAY)
    glx.gldisableClientState(glc.COLOR_ARRAY)

    glx.glBindBuffer(glc.ARRAY_BUFFER, 0)

End

Public Function FIndBlockIDbyHandle(BlockHandle As String) As Block

    Dim B As Block

    For Each B In gcd.CurrentDrawing.oBlocks
        If B.handle = BlockHandle Then Return B
    Next
    Return Null

End

Public Function FIndBlock(BlockName As String) As Block

    Dim b As Block

    For Each b In gcd.CurrentDrawing.oBlocks
        If b.name = BlockName Then Return b
    Next
    Return

End

Public Function FindStyle(sName As String) As Style

    Dim b As Style

    For Each b In gcd.CurrentDrawing.oStyles
        If b.name = sName Then Return b
    Next
    Return

End

' Public Sub setEntity(e As Entity)
'
'     Try e.iParam.Resize(e.ClassHandler.iTotalParams)
'     Try e.fParam.Resize(e.ClassHandler.fTotalParams)
'     Try e.StringData.Resize(e.ClassHandler.sdaTotalParams) ' text, style
'     Try e.P.Resize(e.ClassHandler.TotalPoints * 2)
'
' End

Public Function ReconstruirBloques() As Boolean

    ' busco bloques y coloco puntos de referencias
    ' Armamos los bolques, que extraemos de las entidades
    Dim i, i2 As Integer, PartesEncontradas As Boolean, iStart As Integer
    Dim t As Float = Timer

    Print "Recostruyendo bloques"

    For i = 0 To gcd.CurrentDrawing.oEntities
        DrawingAids.HelperTrabajo = ("Loading blocks ") & Format$(i / gcd.CurrentDrawing.oEntities, "0.00%")
        Wait 0.0001
        If gcd.CurrentDrawing.oEntities[i].gender = "Block" Then
            Dim newBlock As New Block
            newBlock.name = gcd.CurrentDrawing.oEntities[i].block
            newBlock.x = gcd.CurrentDrawing.oEntities[i].p[0]
            newBlock.y = gcd.CurrentDrawing.oEntities[i].p[1]
            newBlock.entities = New Collection
            ' busco los objetos de este bloque y los reconstruyo
            For i2 = iStart To gcd.CurrentDrawing.oEntities
                If gcd.CurrentDrawing.oEntities[i2].block = newBlock.name And gcd.CurrentDrawing.oEntities[i2].gender <> "Block" Then ' sin recursividad en bloques
                    If gcd.CurrentDrawing.oEntities[i2].block = newBlock.name And gcd.CurrentDrawing.oEntities[i2].gender <> "Insert" Then 'no quiero insertarme a mi mismo
                        PartesEncontradas = True
                        Dim o2 As Entity
                        o2 = ClonEntity(gcd.CurrentDrawing.oEntities[i2])

                        o2.ClassHandler.finish(o2)
                        newBlock.entities.Add(o2)
                    End If
                Else
                    If PartesEncontradas Then ' estaba armando un bloque, pero ya termine porque esta entidad es otra cosa
                        PartesEncontradas = False
                        iStart = i2
                        Break
                    End If

                Endif
            Next
            gcd.CurrentDrawing.arrBlocks.Add(newBlock)
        End If
    Next

    Wait 0.001
    Debug "Reconstruccion finalizada en ", Str$(Timer - t)

End

Public Sub _new()

End

'' Genera las listas GL de cada entidad individual, y la version seleccionada
'' Borra la lista anterior y genera una nueva
Public Sub glGenBuffers(Optional eEntity As Entity = Null)

    Dim idDrawing As Integer ' la instancia de dibujo en la que estamos
    Dim i, iVbo As Integer, e As Entity

    If eEntity Then

        ' If Not gl.islist(eEntity.glDrwList) Then eEntity.glDrwList = gl.GenLists(1)
        ' gl.NewList(eEntity.glDrwList, gl.COMPILE)
        ' eEntity.ClassHandler.Draw(eEntity)
        ' gl.EndList
        '
        ' If Not gl.islist(eEntity.glDrwListSel) Then eEntity.glDrwListSel = gl.GenLists(1)
        ' gl.NewList(eEntity.glDrwListSel, gl.COMPILE)
        ' eEntity.ClassHandler.DrawSelected(eEntity)
        ' gl.EndList

    Else

        ' If Not gl.islist(gcd.CurrDrawing.GlListAllEntities) Then gcd.CurrDrawing.GlListAllEntities = gl.GenLists(1)
        Dim t As Float = Timer
        Dim iError As Integer
        ' listas de entidades
        glPlus.VBOFlush
        'glPlus.InmediateMode = False

        If gcd.CurrentDrawing.oEntities.Count = 0 Then Return
        For Each e In gcd.CurrentDrawing.oEntities

            'If Not gl.islist(e.glDrwList) Then e.glDrwList = gl.GenLists(1)
            'gl.NewList(e.glDrwList, gl.COMPILE)
            e.ClassHandler.Draw(e)
            'gl.EndList

        Next
        glPlus.InmediateMode = True

        Dim oneBufferID As Integer
        inxBuffersID.Resize(3)

        iError = glx.glGetError()
        If iError <> 0 Then Print "GL Error:", Hex(iError)

        'glx.glGenBuffers(1, VarPtr(oneBufferID))
        glx.glGenBuffers(3, inxBuffersID.Data)                      ' genero un buffer ID
        iError = glx.glGetError()
        If iError <> 0 Then Print "GL Error:", Hex(iError)
        glx.glBindBuffer(glc.ARRAY_BUFFER, inxBuffersID[0])      ' lo conecto como Vertex Buffer
        iError = glx.glGetError()
        If iError <> 0 Then Print "GL Error:", Hex(iError)
        Dim BytesTotales As Integer
        BytesTotales = glPlus.VBO_vertex.Count + glPlus.VBO_normals.Count + glPlus.VBO_colors.Count
        BytesTotales *= SizeOf(gb.Single)

        ' Reservo espacio. 0 significa que despues le mando la data
        glx.glBufferData(glc.ARRAY_BUFFER, BytesTotales, 0, glc.STATIC_DRAW)
        iError = glx.glGetError()
        If iError <> 0 Then Print "GL Error:", Hex(iError)
        ' mando vertices
        glx.glBufferSubData(glc.ARRAY_BUFFER, 0, glPlus.VBO_vertex.Count * SizeOf(gb.Single), glPlus.VBO_vertex.Data)

        ' mando normales
        glx.glBufferSubData(glc.ARRAY_BUFFER, glPlus.VBO_vertex.Count * SizeOf(gb.Single), glPlus.VBO_normals.Count * SizeOf(gb.Single), glPlus.VBO_normals.Data)

        ' mando colores
        glx.glBufferSubData(glc.ARRAY_BUFFER, (glPlus.VBO_vertex.Count + glPlus.VBO_normals.Count) * SizeOf(gb.Single), glPlus.VBO_colors.Count * SizeOf(gb.Single), glPlus.VBO_colors.Data)
        iError = glx.glGetError()
        If iError <> 0 Then Print "GL Error:", Hex(iError)
        glx.glBindBuffer(glc.ARRAY_BUFFER, 0)      ' finlizo transferencia de datos a la GPU

        ' ' lista de entidaes seleccionadas
        ' For Each e In gcd.CurrentDrawing.oEntities
        '     If Not gl.islist(e.glDrwListSel) Then e.glDrwListSel = gl.GenLists(1)
        '     gl.NewList(e.glDrwListSel, gl.COMPILE)
        '     e.ClassHandler.DrawSelected(e)
        '     gl.EndList
        ' Next
        '
        ' ' lista de todas las entidades
        ' t = Timer
        ' glGenDrawListLAyers
        '
        ' Debug "GLlista de todas generada en  ", Timer - t
    End If

End

'' Genera las listas GL de cada entidad individual, y la version seleccionada
'' Borra la lista anterior y genera una nueva
Public Sub glGenDrawList(Optional eEntity As Entity = Null)

    Dim idDrawing As Integer ' la instancia de dibujo en la que estamos
    Dim i As Integer, e As Entity

    If eEntity Then

        If Not gl.islist(eEntity.glDrwList) Then eEntity.glDrwList = gl.GenLists(1)
        gl.NewList(eEntity.glDrwList, gl.COMPILE)
        eEntity.ClassHandler.Draw(eEntity)
        gl.EndList

        If Not gl.islist(eEntity.glDrwListSel) Then eEntity.glDrwListSel = gl.GenLists(1)
        gl.NewList(eEntity.glDrwListSel, gl.COMPILE)
        eEntity.ClassHandler.DrawSelected(eEntity)
        gl.EndList

    Else

        ' If Not gl.islist(gcd.CurrDrawing.GlListAllEntities) Then gcd.CurrDrawing.GlListAllEntities = gl.GenLists(1)
        Dim t As Float = Timer
        ' listas de entidades
        For Each e In gcd.CurrentDrawing.oEntities

            If Not gl.islist(e.glDrwList) Then e.glDrwList = gl.GenLists(1)
            gl.NewList(e.glDrwList, gl.COMPILE)
            e.ClassHandler.Draw(e)
            gl.EndList

        Next

        ' lista de entidaes seleccionadas
        For Each e In gcd.CurrentDrawing.oEntities
            If Not gl.islist(e.glDrwListSel) Then e.glDrwListSel = gl.GenLists(1)
            gl.NewList(e.glDrwListSel, gl.COMPILE)
            e.ClassHandler.DrawSelected(e)
            gl.EndList
        Next

        ' lista de todas las entidades
        t = Timer
        glGenDrawListLAyers

        Debug "GLlista de todas generada en  ", Timer - t
    End If

End

'' Generates a GL list for the selected
'' Mode: 0=Selected version 1=Normal version
Public Sub glGenDrawListSel(Optional mode As Integer = 0)

    Dim idDrawing As Integer ' la instancia de dibujo en la que estamos
    Dim i As Integer, e As Entity

    If Not gl.islist(gcd.CurrentDrawing.GlListSelectedEntities) Then gcd.CurrentDrawing.GlListSelectedEntities = gl.GenLists(1)

    gl.NewList(gcd.CurrentDrawing.GlListSelectedEntities, gl.COMPILE)

    For Each e In gcd.CurrentDrawing.oSelected

        'If gcd.CurrentDrawing.arrEntities[i].Selected Then
        If mode = 0 Then gl.CallList(e.glDrwListSel)
        If mode = 1 Then gl.CallList(e.glDrwList)
        'End If
    Next

    gl.EndList

End

'' Generates a GL list for the selected
'' Mode: 0=Selected version 1=Normal version
Public Sub glGenDrawListAll(Optional ExcludeSelected As Boolean = False)

    Dim i As Integer, e As Entity

    gl.NewList(gcd.CurrentDrawing.GlListAllEntities, gl.COMPILE)

    For Each e In gcd.CurrentDrawing.oEntities
        If Not (e.Selected And ExcludeSelected) Then gl.CallList(e.glDrwList)

    Next

    gl.EndList

    For Each L As Layer In gcd.CurrentDrawing.oLayers
        If Not gl.islist(L.glList) Then L.glList = gl.GenLists(1)
        gl.NewList(L.glList, gl.COMPILE)
    Next
    For Each e In gcd.CurrentDrawing.oEntities
        If Not (e.Selected And ExcludeSelected) Then gl.CallList(e.glDrwList)

    Next

    gl.EndList

End

'' Generates a GL list for the selected
'' Mode: 0=Selected version 1=Normal version
Public Sub glGenDrawListLAyers(Optional aLayer As Layer)

    Dim i As Integer
    Dim e As Entity

    If aLayer Then

        If Not gl.islist(aLayer.glList) Then aLayer.glList = gl.GenLists(1)
        gl.NewList(aLayer.glList, gl.COMPILE)
        For Each e In gcd.CurrentDrawing.oEntities

            If e.pLayer = aLayer Then gl.CallList(e.glDrwList)

        Next
        gl.EndList

    Else

        For Each aLayer In gcd.CurrentDrawing.oLayers
            If Not gl.islist(aLayer.glList) Then aLayer.glList = gl.GenLists(1)
            gl.NewList(aLayer.glList, gl.COMPILE)
            For Each e In gcd.CurrentDrawing.oEntities

                If e.pLayer = aLayer Then gl.CallList(e.glDrwList)

            Next
            gl.EndList

        Next

    Endif

End

'' Generates a GL list for the selected
'' Mode: 0=Selected version 1=Normal version
Public Sub glGenDrawListLAyers2(Optional aLayer As Layer)

    Dim i As Integer
    Dim e As Entity

    If aLayer Then

        If Not gl.islist(aLayer.glList) Then aLayer.glList = gl.GenLists(1)
        gl.NewList(aLayer.glList, gl.COMPILE)
        For Each e In gcd.CurrentDrawing.oEntities

            If e.pLayer = aLayer Then gl.CallList(e.glDrwList)

        Next
        gl.EndList

    Else

        For Each aLayer In gcd.CurrentDrawing.oLayers
            If Not gl.islist(aLayer.glList) Then aLayer.glList = gl.GenLists(1)
            gl.NewList(aLayer.glList, gl.COMPILE)
            For Each e In aLayer.Entities
                gl.CallList(e.glDrwList)

            Next
            gl.EndList

        Next

    Endif

End

Public Sub DrawPoiSymbolsAll()

    Dim i, total As Integer

    For Each e As Entity In gcd.CurrentDrawing.oEntities

        If e.Selected Then

            If (e.Gender = "Insert") Then
                DrawPoiSymbols(e)
                Inc total
            End If
        End If
        If total = 100 Then Break                           ' limitamos la cantidad de enganches a un numero sensato
    Next

End

Public Sub DrawPoiSymbols(oE As Entity)

    Dim i As Integer

    For i = 0 To oe.PoiPoints.Max Step 2
        Select Case oe.PoiType[i / 2]
            Case gcd.poiEndPoint
                glPlus.Rectangle2D(oe.PoiPoints[i] - gcd.Metros(4), oe.PoiPoints[i + 1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Blue,,,, Color.Cyan, 1, 1)

            Case gcd.poiMidPoint
                glPlus.Rectangle2D(oe.PoiPoints[i] - gcd.Metros(4), oe.PoiPoints[i + 1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Cyan,,,, Color.Blue, 1, 1)

            Case gcd.poiCenter
                glPlus.Rectangle2D(oe.PoiPoints[i] - gcd.Metros(4), oe.PoiPoints[i + 1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Cyan,,,, Color.Blue, 1, 1)

            Case gcd.poiQuadrant
                glPlus.Rectangle2D(oe.PoiPoints[i] - gcd.Metros(4), oe.PoiPoints[i + 1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Blue,,,, Color.Cyan, 1, 1)

            Case gcd.poiBasePoint
                glPlus.Rectangle2D(oe.PoiPoints[i] - gcd.Metros(4), oe.PoiPoints[i + 1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Cyan,,,, Color.Blue, 1, 1)

        End Select

    Next

End

Public Sub Finish(Optional selected As Boolean = True)

    ' creo copias de cada elemento seleccionado
    Dim m As Integer, E As Entity

    For Each E In gcd.CurrentDrawing.oEntities
        If selected Then                                                    ' apply to only the selected ones
            If E.Selected Then E.ClassHandler.Finish(E)
        Else                                                                ' apply to all
            E.ClassHandler.Finish(E)
        End If

    Next

End

Public Sub ClonElements(Optional selected As Boolean = True)

    ' creo copias de cada elemento seleccionado
    Dim E As Entity
    Dim eClon As Entity

    For Each E In gcd.CurrentDrawing.oSelected
        eClon = Me.ClonEntity(e, True)
        gcd.CurrentDrawing.oEntities.Add(eClon, eClon.Handle)
        eClon.ClassHandler.finish(eClon)
        gcd.CurrentDrawing.CurrLayer.Entities.Add(eClon)

    Next

End

Public Sub ClonEntity(e As Entity, Optional GetNewHandle As Boolean = True) As Entity
    ' clona una entidad
    ' copia todos sus elementos
    ' llama a las rutinas de reconstruccion del contorno y de los POI

    Dim o As Entity

    o = e.ClassHandler.newEntity()
    CopyElemData(e, o)                              ' copy all values
    o.ClassHandler.BuildPoi(o)
    If GetNewHandle Then o.Handle = gcd.NewHandle()
    Return o

End

'' Busca elementos seleccionados y arma un array nuevo con ellos, eliminandolos del anterior
Public Function SelectArrayMake() As Integer

End

Public Function DeSelection(Optional elementos As String = "todo", Accion As String = "deseleccionar") As Integer
    ' Esta rutina analiza si los elemento seleccionados para alguna accion pueden realizarla, caso contrario los deselecciona
    ' se basa en los puntos que tengan la propiedad .Selected = True
    ' tambien puede deseleccionar todo
    ' Devuelve la cantidad de elementos que quedaron seleccionados despues de filtrar

    Dim i As Integer, c As Integer, Clase As String, iii As Integer

    ' por las dudas vengan alguna letra mayuscula
    If Accion = "" Then accion = "deseleccionar"
    accion = LCase(accion)
    elementos = LCase(elementos)

    '   primero vacio la seleccion anterior
    gcd.CurrentDrawing.oSelected.Clear

    For Each eTesting As Entity In gcd.CurrentDrawing.oEntities

        clase = eTesting.Gender

        Select Case accion

            Case "mover", "copiar", "borrar", "escalar" ' necesito que todos los puntos esten seleccionados

                If SelFull() And (elementos = "todo" Or elementos = clase) Then

                    gcd.CurrentDrawing.oSelected.Add(eTesting, eTesting.handle)
                    SelectElem(eTesting)
                    Inc i

                Else

                    DeSelectElem(eTesting)

                End If

            Case "estirar" ' necesito que dos puntos contiguos esten seleccionados

                If SelPArtial() And (elementos = "todo" Or elementos = clase) Then
                    gcd.CurrentDrawing.oSelected.Add(eTesting, eTesting.handle)
                    SelectElem(eTesting, False) ' dont touch the points
                    Inc i

                Else

                    DeSelectElem(eTesting)

                End If

            Case "deseleccionar" ' todas las acciones

                If (elementos = "todo" Or elementos = clase) Then

                    Inc i
                    DeSelectElem(eTesting)

                End If

        End Select

    Next

    Return i

End

Public Function GetSelectionCount() As Integer

    Dim e As Entity

    gcd.CurrentDrawing.oSelected.Clear
    For Each e In gcd.CurrentDrawing.oEntities
        If e.Selected Then

            gcd.CurrentDrawing.oSelected.Add(e, e.handle)
        End If
    Next
    Return gcd.CurrentDrawing.oSelected.Count

End Function

Public Function DeleteSelected() As Integer

    Dim E As Entity, c As Integer
    Dim lay As Layer

    '  Purgue will also delete those with .ForDeletion = true

    For Each E In gcd.CurrentDrawing.oEntities

        If E.Selected Then
            gcd.CurrentDrawing.oEntities.Remove(gcd.CurrentDrawing.oEntities.Key)
            Inc c
        End If

    Next

    '   we also need to regenerate the drawing list
    For Each lay In gcd.CurrentDrawing.oLayers
        If lay.Visible Then glGenDrawListLayers(lay)
    Next

    ' we also need too recalculate visible items
    Me.CollectVisibleEntities()

    ' TODO: put something in UNDO collection

    Return c

End Function

Public Function SelectFromPoint(Xr As Float, Zr As Float, Optional Autoselect As Boolean = True) As Entity

    Dim i As Integer

    For i = gcd.CurrentDrawing.oEntities To 0 Step -1
        ' last elements are drawn last so the click belongs to them
        If gcd.CurrentDrawing.oEntities[i].pointClick(Xr, Zr) Then
            If Autoselect Then
                If Not gcd.CurrentDrawing.oEntities[i].Selected Then
                    SelectElem(gcd.CurrentDrawing.oEntities[i])
                Else
                    DeSelectElem(gcd.CurrentDrawing.oEntities[i])
                End If
            End If
            Return gcd.CurrentDrawing.oEntities[i]
        End If

    Next

End

Public Sub DrawPoint(x As Float, y As Float, Optional colour As Integer = -1, Optional LargoReal As Float = 0.4)

    If colour <> -1 Then
        paint.brush = Paint.Color(colour)
    Else
        paint.brush = Paint.Color(Color.Blue)
    End If
    paint.LineWidth = 1
    paint.MoveTo(x - LargoReal / 2, y)
    paint.RelLineTo(LargoReal, 0)

    paint.MoveTo(x, y - LargoReal / 2)
    paint.RelLineTo(0, -LargoReal)
    paint.Stroke

End

Public Sub SelectElem(eEntity As Entity, Optional AndItsPoints As Boolean = True)

    Dim i, ii As Integer

    eEntity.selected = True
    If AndItsPoints Then
        For i = 0 To eEntity.Psel.Max
            eEntity.Psel[i] = True
        Next

    End If
    'End If

    ' Endif

End

Public Sub DeSelectElem(eEntity As Entity, Optional AndItsPoints As Boolean = True)

    ' deselect all points and myself

    Dim i, ii As Integer

    eEntity.selected = False
    If AndItsPoints Then
        For i = 0 To eEntity.Psel.Max
            eEntity.Psel[i] = False
        Next

    End If
    ' End If

    ' Endif

End

Public Sub CopyElemData(origen As Entity, destino As Entity)

    ' when adding stuff to the elements, it must be added here
    Dim i As Integer
    ' arrays
    destino.p.resize(origen.p.count)
    destino.fparam.resize(origen.fparam.count)
    destino.iparam.resize(origen.iparam.count)
    destino.psel.resize(origen.psel.count)
    destino.StringData.resize(origen.StringData.count)
    For i = 0 To origen.p.Max
        destino.P[i] = origen.P[i]
    Next
    For i = 0 To origen.fparam.Max
        destino.fparam[i] = origen.fparam[i]
    Next
    For i = 0 To origen.iparam.Max
        destino.iparam[i] = origen.iparam[i]
    Next
    For i = 0 To origen.StringData.Max
        destino.StringData[i] = origen.StringData[i]
    Next

    destino.Gender = origen.Gender
    destino.ClassHandler = origen.ClassHandler
    destino.pLayer = origen.pLayer
    destino.pBlock = origen.pBlock
    destino.Group = origen.Group
    destino.colour = origen.colour
    destino.LineType = origen.LineType
    destino.LineWidth = origen.LineWidth
    destino.Handle = origen.Handle
    destino.HandleOwner = origen.HandleOwner
    destino.pStyle = origen.pStyle

End

Public Sub Move(dX As Float, dY As Float, Optional OnlySelected As Boolean = False, OnlyPointSelected As Boolean = False)

    ' crea un backup de todos los puntos
    Dim e As Entity, i As Integer

    For Each e In gcd.CurrentDrawing.oEntities
        If (e.selected And OnlySelected) Or Not OnlySelected Then

            e.ClassHandler.Translate(e, dX, dY, OnlyPointSelected)

        Endif

    Next

End

Public Sub Rotate(degAngle As Float, Optional OnlySelected As Boolean = False, OnlyPointSelected As Boolean = False)

    ' crea un backup de todos los puntos
    Dim e As Entity, i As Integer

    For Each e In gcd.CurrentDrawing.oEntities
        If (e.selected And OnlySelected) Or Not OnlySelected Then

            e.ClassHandler.Rotate(e, degAngle)

        Endif

    Next

End

Public Sub Scale(sX As Float, sY As Float, Optional sZ As Float = 1, OnlySelected As Boolean = False, OnlyPointSelected As Boolean = False)

    ' crea un backup de todos los puntos
    Dim e As Entity, i As Integer

    For Each e In gcd.CurrentDrawing.oEntities
        If (e.selected And OnlySelected) Or Not OnlySelected Then

            e.ClassHandler.Scale(e, sX, sY)

        Endif

    Next

End

Public Function SelectionSquare(X1real As Float, Y1real As Float, X2real As Float, Y2real As Float, Optional NuevaSumaResta As String = "nueva", crossing As Boolean) As Integer

    ' Veo que accion estoy tomando
    Dim e As Entity, i, i2, TotalSeleccionados As Integer

    NuevaSumaResta = LCase$(NuevaSumaResta)

    If NuevaSumaResta = "nueva" Then ' nueva seleccion
        For Each e In gcd.CurrentDrawing.oEntities
            e.selected = False
            For i2 = 0 To e.Psel.max
                e.Psel[i2] = False
            Next
        Next
        TotalSeleccionados = 0
    End If

    For Each e In gcd.CurrentDrawing.oEntities
        ' cada entidad debe decidir si esta seleccionada o no
        If crossing Then
            If SelPArtial(e, X1real, Y1real, X2real, Y2real) Then
                ' el punto esta en el recuadro
                If NuevaSumaResta <> "resta" Then
                    Inc TotalSeleccionados
                    Me.SelectElem(e, False)

                Else If NuevaSumaResta = "resta" Then
                    Dec TotalSeleccionados
                    Me.DeSelectElem(e, False)

                End If

            Endif
        Else
            If SelFull(e, X1real, Y1real, X2real, Y2real) Then
                ' el punto esta en el recuadro
                If NuevaSumaResta <> "resta" Then
                    Inc TotalSeleccionados
                    Me.SelectElem(e, False)

                Else If NuevaSumaResta = "resta" Then
                    Dec TotalSeleccionados
                    Me.DeSelectElem(e, False)

                End If

            Endif

        End If
    Next
    GetSelectionCount()

    ' deprecada
    ' GetSelectionHandles(gcd.CurrentDrawing.hSelection)

    Return TotalSeleccionados

End

'' Put all visible entity refs in arrVisibleEntities[]
Public Function CollectVisibleEntities()

    Dim x0, y0, x1, y1 As Float
    Dim lay As Layer
    Dim e As Entity
    Dim i, tot As Integer

    x0 = gcd.Xreal(0)
    y1 = gcd.Yreal(0)                     ' el eje Y esta invertido en OpenGL
    x1 = gcd.Xreal(gcd.ScreenWidth())
    y0 = gcd.Yreal(gcd.ScreenHeight())

    'If gcd.CurrentDrawing.oEntities > gcd.CurrentDrawing.arrVisibleEntities.Max Then gcd.CurrentDrawing.arrVisibleEntities.Resize(gcd.CurrentDrawing.oEntities.Count)
    gcd.CurrentDrawing.oVisibleEntities.Clear
    For Each e In gcd.CurrentDrawing.oEntities
        If e.pLayer.Visible Then

            If SelPArtial(e, x0, y0, x1, y1) Then

                gcd.CurrentDrawing.oVisibleEntities.Add(e, e.Handle)

            End If
        End If
    Next

End

Public Function GetSelectionHandles(sHandles As String[]) As Integer

    Dim i As Integer
    Dim itotal As Integer

    Dim t As Float = Timer

    sHandles.Clear
    'sHandles.Resize
    For i = 0 To gcd.CurrentDrawing.oEntities
        If gcd.CurrentDrawing.oEntities[i].Selected Then
            sHandles.Add(gcd.CurrentDrawing.oEntities[i].Handle)
            Inc itotal
        End If
    Next
    Debug itotal, " en ", t - Timer, " seg"
    Return itotal

End

'Return bound limits for all verices in the array of entities
Public Sub BuildPoi(Optional entities As Collection, OnlyVisibles As Boolean = True)

    Dim e As Entity, i As Integer
    Dim entGroup As Collection

    If Not entities Then entGroup = gcd.CurrentDrawing.oEntities Else entGroup = Entities

    If entGroup.Count = 0 Then Return

    For Each e In entGroup
        If (OnlyVisibles And e.pLayer.Visible) Or Not OnlyVisibles Then
            e.ClassHandler.BuildPoi(e)
        End If
    Next

End
'Return bound limits for all verices in the array of entities

Public Function ComputeLimits(Optional entities As Collection, OnlyVisibles As Boolean = True) As Float[]

    Dim e As Entity, i As Integer
    Dim entGroup As Collection
    Dim Xmenor As Float = 1e10, Ymenor As Float = 1e10, Xmayor As Float = -1e10, Ymayor As Float = -1e10
    Dim newLimits As New Float[]
    Dim IsVisible As Boolean

    If Not entities Then entGroup = gcd.CurrentDrawing.oEntities Else entGroup = Entities

    If entGroup.Count = 0 Then Return Null

    For Each e In entGroup
        If OnlyVisibles Then
            If IsNull(e.pLayer) Then
                IsVisible = True
            Else
                IsVisible = e.pLayer.Visible
            End If

        Endif

        If IsVisible Then

            If e.Gender = "Insert" Then
                If IsNull(e.pBlock) Then Continue
                newLimits = ComputeLimits(e.pBlock.entities)
                If IsNull(newLimits) Then Continue
                puntos.Scale(newLimits, e.fParam[cadInsert.ipaEscX], e.fParam[cadInsert.ipaEscY])
                puntos.Rotate(newLimits, e.fParam[cadInsert.ipaRotacion]) ' TODO: verificar orden de esta y la siguiente linea
                puntos.Translate(newLimits, e.P[0], e.P[1])
                If Xmenor > newLimits[0] Then Xmenor = newLimits[0]
                If ymenor > newLimits[1] Then ymenor = newLimits[1]
                If Xmayor < newLimits[2] Then Xmayor = newLimits[2]
                If Ymayor < newLimits[3] Then Ymayor = newLimits[3]
                'End If

            Else If e.Gender Like "DIM*" Then

                If IsNull(e.pBlock) Then Continue
                newLimits = ComputeLimits(e.pBlock.entities)
                If IsNull(newLimits) Then Continue
                'puntos.Translate(newLimits, e.P[0], e.P[1])
                'puntos.Rotate(newLimits, e.fParam[cadInsert.ipaRotacion]) ' TODO: verificar orden de esta y la siguiente linea
                'puntos.Scale(newLimits, e.fParam[cadInsert.ipaEscX], e.fParam[cadInsert.ipaEscY])
                If Xmenor > newLimits[0] Then Xmenor = newLimits[0]
                If ymenor > newLimits[1] Then ymenor = newLimits[1]
                If Xmayor < newLimits[2] Then Xmayor = newLimits[2]
                If Ymayor < newLimits[3] Then Ymayor = newLimits[3]
                ' End If

            Else If e.Polygon.Count > 0 Then

                For i = 0 To e.Polygon.max Step 2
                    'If e.p[i] > 0 Then Debug e.gender

                    If e.Polygon[i] < Xmenor Then Xmenor = e.Polygon[i]

                    If e.Polygon[i + 1] < Ymenor Then Ymenor = e.Polygon[i + 1]

                    If e.Polygon[i] > Xmayor Then Xmayor = e.Polygon[i]

                    If e.Polygon[i + 1] > Ymayor Then Ymayor = e.Polygon[i + 1]

                Next
            Else If e.PolyLine.Count > 0 Then

                For i = 0 To e.PolyLine.max Step 2
                    'If e.p[i] > 0 Then Debug e.gender

                    If e.PolyLine[i] < Xmenor Then Xmenor = e.PolyLine[i]

                    If e.PolyLine[i + 1] < Ymenor Then Ymenor = e.PolyLine[i + 1]

                    If e.PolyLine[i] > Xmayor Then Xmayor = e.PolyLine[i]

                    If e.PolyLine[i + 1] > Ymayor Then Ymayor = e.PolyLine[i + 1]

                Next
            Else

                For i = 0 To e.p.max Step 2

                    If i > e.P.Max - 1 Then Break
                    'If e.p[i] > 0 Then Debug e.gender

                    If e.p[i] < Xmenor Then Xmenor = e.p[i]

                    If e.p[i + 1] < Ymenor Then Ymenor = e.p[i + 1]

                    If e.p[i] > Xmayor Then Xmayor = e.p[i]

                    If e.p[i + 1] > Ymayor Then Ymayor = e.p[i + 1]

                Next
            End If
        End If
        'If Xmenor < -60 Then Stop
        ' If Xmayor > 425 Then Stop

    Next

    Return [Xmenor, Ymenor, Xmayor, Ymayor]

End

'' Determines if the entity was selected by a rectanle surrounding al points
'' by default, if ALL points are selected, it can.
Public Function SelFull(eTesting As Entity, X1real As Float, Y1real As Float, X2real As Float, Y2real As Float) As Boolean

    Dim ii As Integer, puedo As Boolean

    Select Case eTesting.Gender

        Case Else

            ' Si tengo un bounding poligon, entonces verifico que todos los puntos esten dentro
            If eTesting.Polygon.Count > 0 Then

                Return puntos.IsPoligonInsideRect(eTesting.Polygon, X1real, Y1real, X2real, Y2real)

            Else    ' no tengo un poligono, entonces verifico que todos los puntos definitorios de al entidad esten dentro

                puedo = True                     ' supongamos que puedo, por ahora
                For ii = 0 To eTesting.p.max Step 2
                    If ii + 1 > eTesting.p.max Then Break
                    If Not (eTesting.p[ii] >= X1real And eTesting.p[ii] <= X2real) And (eTesting.p[ii + 1] >= Y1real And eTesting.p[ii + 1] <= Y2real) Then
                        puedo = False
                    End If
                Next

                If puedo Then
                    For ii = 0 To eTesting.PSel.Max
                        eTesting.PSel[ii] = True
                    Next

                    Return True
                Else
                    For ii = 0 To eTesting.PSel.Max
                        eTesting.PSel[ii] = False
                    Next

                    Return False
                End If
            Endif
    End Select

End
'
' '' Determines if the entity
' '' by default, if ANY point is selected, it can.

Public Function SelPartial(eTesting As Entity, X1real As Float, Y1real As Float, X2real As Float, Y2real As Float) As Boolean

    Dim ii As Integer, puedo As Boolean = False
    Dim oLoop As Boundary

    Select Case eTesting.Gender

        Case "Hatch"

            For Each oLoop In eTesting.pBlock.oBoundaryPath

                puedo = puntos.IsPoligonInsideRect(oLoop.Polyline, X1real, Y1real, X2real, Y2real)
                If puedo Then Break

                puedo = puntos.IsPoligonCrossingRect(oLoop.Polyline, X1real, Y1real, X2real, Y2real)
                If puedo Then Break
            Next

        Case Else

            ' Si tengo un bounding poligon, entonces verifico que alguna linea lo cruce
            puedo = puntos.IsPoligonCrossingRect(eTesting.Polygon, X1real, Y1real, X2real, Y2real)

            For Ii = 0 To eTesting.p.max Step 2
                If ii + 1 > eTesting.p.max Then Break
                If ii / 2 > eTesting.Psel.Max Then Break
                If (eTesting.p[iI] >= X1real And eTesting.p[Ii] <= X2real) And (eTesting.p[iI + 1] >= Y1real And eTesting.p[iI + 1] <= Y2real) Then
                    eTesting.PSel[iI / 2] = True
                    puedo = True
                End If
            Next

    End Select

    If puedo Then

        Return True
    Else
        Return False
    End If

End

' Public Function GetParentBlock(iEntity As Integer) As Integer
'
'     Dim iParent As Integer
'
'     iParent = iEntity
'     Do
'
'         If gcd.CurrDrawing.arrEntities[iParent].iInsert >= 0 Then
'             If iParent = gcd.CurrDrawing.arrEntities[iParent].iInsert Then Break
'             iParent = gcd.CurrDrawing.arrEntities[iParent].iInsert
'         Else
'             Break
'         End If
'
'     Loop
'
'     Return iParent
'
' End

'' Imports data from a collection to an entity. True if the entity is handled by m-designer at this version,
'' False if entity couldn't be created for some reason.
Public Function DXFImportToEntity(c As Collection, Optional IsDummy As Boolean = False) As Entity

    Dim clsHandler As Object
    Dim sClave As New String[]
    Dim sValue As New String[]
    Dim lpValue, lpclave As String
    Dim i As Integer
    Dim GotEntity As Boolean
    Dim e As Entity
    Dim LT As LType

    ' If Not c.Exist("entity") Then Return False
    ' If Not c "entity") Then Return False
    If IsDummy Then
        clsHandler = cadDummy
    Else
        clsHandler = Object.New("cad" & c[dxf.codEntity])  ' obtenemos el tipo de entidad y buscamos su clase. Si no manjemos esa entidad, esto de error.

    End If
    'GotEntity = True

    'Finally

    'If Not GotEntity Then Return False

    For Each lpValue In c
        lpclave = c.Key
        I = InStr(lpclave, "_")
        If i > 0 Then lpclave = Left(lpclave, i - 1)
        sClave.Add(lpclave)           ' el codigo es el tipo de variable
        sValue.Add(lpValue)

    Next
    e = clsHandler.newEntity()
    ' llenamos Common data:
    e.pLayer = GetLayerByName(c[dxf.codLayer])
    e.Handle = c[dxf.codHandle]

    ' for testing FIXME: ojo con esto!!!
    ' If e.handle <> "804AC" Then Return Null

    e.HandleOwner = c[dxf.codHandleOwner]
    Try e.colour = c[dxf.codColor]            ' no es obligatorio
    Try e.LineWidth = c[dxf.codLWht] / 100    ' por eso el try
    If e.LineWidth < 1 Then e.LineWidth = 1
    If c.Exist(dxf.codLType) Then
        LT = GetLTypeByName(c[dxf.codLType])
        If LT Then
            e.LineType = LT
        Else
            e.LineType = gcd.CurrentDrawing.oLTypes[gcd.CurrentDrawing.oLTypes.First]
        End If
    Else
        e.LineType = gcd.CurrentDrawing.oLTypes[gcd.CurrentDrawing.oLTypes.First]

    End If
    If clsHandler.ImportDXF(e, sClave, sValue) Then

        'If e.ClassHandler.gender <> "Hatch" Then e.ClassHandler.Finish(e)
        e.ClassHandler.Finish(e)

        Return e

    Else

        Return Null

    End If

    ' Catch
    'e.ClassHandler = cadDummy
    Return Null

End

Public Function GetEntityIndex(dDrawing As Drawing, sHandle As String, Optional iStart As Integer = 0) As Integer

    Dim i As Integer

    For i = iStart To dDrawing.oEntities

        If dDrawing.oEntities[i].Handle = sHandle Then Return i

    Next

    Return -1           ' no hay handle asociada a esa entidad

End

Public Sub DXFExportCommonCol(e As Entity, ByRef cExported As Collection)

    cExported.Add(UCase(e.Gender), dxf.codEntity)
    cExported.add(e.Handle, dxf.codHandle)
    cExported.add(e.HandleOwner, dxf.codHandleOwner)
    cExported.Add("AcDbEntity", "100_1")
    cExported.Add(e.pLayer.Name, dxf.codLayer)
    Try cExported.Add(e.LineType.Name, dxf.codLType)
    cExported.Add(e.colour, dxf.codColor)
    cExported.Add(CStr(e.LineWidth), dxf.codLWht)

End

'' Imports data from a collection to an entity. True if the entity is handled by GauchoCAD at this version,
'' False if entity couldn't be created for some reason.
Public Function ImportJsonToEntity(c As JSONCollection, Optional IsDummy As Boolean = False) As Entity

    Dim clsHandler As Object
    Dim e As Entity

    ' If Not c.Exist("entity") Then Return False
    ' If Not c "entity") Then Return False
    If IsDummy Then
        clsHandler = cadDummy
    Else
        clsHandler = Object.New("cad" & c["entity"])  ' obtenemos el tipo de entidad y buscamos su clase. Si no manjemos esa entidad, esto de error.

    End If

    e = clsHandler.newEntity() ' le pedimos a la clase que arme un objeto Entity para agregar al Drawing actual
    If clsHandler.ImportJSONCol(c, e) Then
        ' llenamos Common data:
        e.player = GetLayerByHandle(c["layer"][3])  ' busco el layer por nombre
        e.Handle = c["handle"][1]
        If e.pLayer = Null Then Stop
        If TypeOf(c["color"]) = gb.Object Then
            Try e.colour = c["color"]["index"]    ' FIXME: esto sigue dando error
        Else
            Try e.colour = c["color"]
        Endif
        e.LineWidth = c["linewt"] / 100
        If e.LineWidth < 1 Then e.LineWidth = 1
        e.LineType = GetLTypeByIndex(c["ltype_flags"])
        If Not e.LineType Then
            e.LineType = gcd.CurrentDrawing.oLTypes[gcd.CurrentDrawing.oLTypes.First]
        End If

        clsHandler.Finish(e)

        Return e

    Else

        Return Null

    End If

    'Catch
    'e.ClassHandler = cadDummy
    Return False

End

Public Function GetLTypeByName(sName As String) As LType

    Dim LT As LType

    For Each LT In gcd.currentDrawing.oLTYpes

        If LCase(LT.Name) = LCase(sname) Then Return LT

    Next

    Return Null

End

Public Function GetLTypeByIndex(sName As String) As LType

    Dim lt As LType

    For Each lt In gcd.CurrentDrawing.oLTypes

        If LCase(lt.Name) = LCase(sname) Then Return lt

    Next

    Return Null

End

Public Function GetLayerByHandle(sHandle As String) As Layer

    Dim Lay As Layer

    For Each Lay In gcd.CurrentDrawing.oLayers

        If Lay.handle = sHandle Then Return Lay
    Next
    Return Null

End

Public Function GetLayerByName(LayerName As String) As Layer

    Dim Lay As Layer

    For Each Lay In gcd.CurrentDrawing.oLayers

        If Lay.Name = LayerName Then Return Lay
    Next
    Return Null

End

'' Reads entities and fill arrLayers
Public Sub FillLayersWithEntities(oDrawing As Drawing)

    Dim hLay As Layer
    Dim e As Entity

    ' primero eliminamos lo q haya
    For Each hLay In oDrawing.oLayers
        hLay.Entities.Clear
    Next

    For Each e In oDrawing.oEntities
        'e.pLayer = CurrDrawing.arrLayers[gcd.FindLaIndex(e.pLayer)]
        e.pLayer.Entities.Add(e)
    Next
    ' Esto ya no es posible con Colecciones
    'currentDrawing.oVisibleEntities.Resize(CurrentDrawing.oEntities.Count)

End
