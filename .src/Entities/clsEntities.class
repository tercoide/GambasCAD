' Gambas class file

' GauchoCAD
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA

Create Static

Public Function FIndBlockIDbyHandle(BlockHandle As String) As Integer

    Dim i As Integer

    For i = 0 To gcd.CurrDrawing.arrBlocks.Max
        If gcd.CurrDrawing.arrBlocks[i].handle = BlockHandle Then Return i
    Next
    Return -1

End

Public Function FIndBlockID(BlockName As String) As Integer

    Dim i As Integer

    For i = 0 To gcd.CurrDrawing.arrBlocks.Max
        If gcd.CurrDrawing.arrBlocks[i].name = BlockName Then Return i
    Next
    Return -1

End

Public Function FIndBlock(BlockName As String) As Block

    Dim b As Block

    For Each b In gcd.CurrDrawing.arrBlocks
        If b.name = BlockName Then Return b
    Next
    Return

End

Public Function FindStyle(sName As String) As Style

    Dim b As Style

    For Each b In gcd.CurrDrawing.arrStyles
        If b.name = sName Then Return b
    Next
    Return

End

Public Sub setEntity(e As Entity)

    Try e.iParam.Resize(e.ClassHandler.iTotalParams)
    Try e.fParam.Resize(e.ClassHandler.TotalParams)
    Try e.StringData.Resize(e.ClassHandler.sdaTotalParams) ' text, style

End

Public Function ReconstruirBloques() As Boolean

    ' busco bloques y coloco puntos de referencias
    ' Armamos los bolques, que extraemos de las entidades
    Dim i, i2 As Integer, PartesEncontradas As Boolean, iStart As Integer
    Dim t As Float = Timer

    Print "Recostruyendo bloques"

    For i = 0 To gcd.CurrDrawing.arrEntities.Max
        clsDrawingAids.HelperTrabajo = ("Loading blocks ") & Format$(i / gcd.CurrDrawing.arrEntities.Max, "0.00%")
        Wait 0.0001
        If gcd.CurrDrawing.arrEntities[i].gender = "Block" Then
            Dim newBlock As New Block
            newBlock.name = gcd.CurrDrawing.arrEntities[i].block
            newBlock.x = gcd.CurrDrawing.arrEntities[i].p[0]
            newBlock.y = gcd.CurrDrawing.arrEntities[i].p[1]
            newBlock.entities = New Entity[]
            ' busco los objetos de este bloque y los reconstruyo
            For i2 = iStart To gcd.CurrDrawing.arrEntities.max
                If gcd.CurrDrawing.arrEntities[i2].block = newBlock.name And gcd.CurrDrawing.arrEntities[i2].gender <> "Block" Then ' sin recursividad en bloques
                    If gcd.CurrDrawing.arrEntities[i2].block = newBlock.name And gcd.CurrDrawing.arrEntities[i2].gender <> "Insert" Then 'no quiero insertarme a mi mismo
                        PartesEncontradas = True
                        Dim o2 As Entity
                        o2 = ClonEntity(gcd.CurrDrawing.arrEntities[i2])

                        o2.ClassHandler.finish(o2)
                        newBlock.entities.Add(o2)
                    End If
                Else
                    If PartesEncontradas Then ' estaba armando un bloque, pero ya termine porque esta entidad es otra cosa
                        PartesEncontradas = False
                        iStart = i2
                        Break
                    End If

                Endif
            Next
            gcd.CurrDrawing.arrBlocks.Add(newBlock)
        End If
    Next

    Wait 0.001
    Debug "Reconstruccion finalizada en ", Str$(Timer - t)

End

Public Sub _new()

End

Public Sub FillEntity(o As Entity)

    '  ' lets add the points, if number of points is not determined (like a poli-line) at least we need one
    '  ' make all arrays acording to param list
    Dim n As Integer

    For n = 1 To Len(o.ClassHandler.ParamType)
        Select Case UCase(Mid(o.ClassHandler.ParamType, n, 1))
            Case "P"
                o.p.add(0)
                o.p.add(0)

                o.psel.add(0)
            Case "F", "A", "M", "L", "R"
                o.fParam.Add(0)

            Case "T"
                o.StringData.Add("")

            Case "C"

        End Select

    Next

End

'' Genera las listas GL de cada entidad individual, y la version seleccionada
'' Borra la lista anterior y genera una nueva
Public Sub glGenDrawList(Optional iEntity As Integer = -1)

    Dim idDrawing As Integer ' la instancia de dibujo en la que estamos
    Dim i As Integer

    If iEntity >= 0 Then

        If Not gl.islist(gcd.CurrDrawing.arrEntities[iEntity].glDrwList) Then gcd.CurrDrawing.arrEntities[iEntity].glDrwList = gl.GenLists(1)
        gl.NewList(gcd.CurrDrawing.arrEntities[iEntity].glDrwList, gl.COMPILE)
        gcd.CurrDrawing.arrEntities[iEntity].ClassHandler.Draw(gcd.CurrDrawing.arrEntities[iEntity])
        gl.EndList

        If Not gl.islist(gcd.CurrDrawing.arrEntities[iEntity].glDrwListSel) Then gcd.CurrDrawing.arrEntities[iEntity].glDrwListSel = gl.GenLists(1)
        gl.NewList(gcd.CurrDrawing.arrEntities[iEntity].glDrwListSel, gl.COMPILE)
        gcd.CurrDrawing.arrEntities[iEntity].ClassHandler.DrawSelected(gcd.CurrDrawing.arrEntities[iEntity])
        gl.EndList

    Else

        ' If Not gl.islist(gcd.CurrDrawing.GlListAllEntities) Then gcd.CurrDrawing.GlListAllEntities = gl.GenLists(1)
        Dim t As Float = Timer
        ' listas de entidades
        For i = 0 To gcd.CurrDrawing.arrEntities.Max

            If Not gl.islist(gcd.CurrDrawing.arrEntities[i].glDrwList) Then gcd.CurrDrawing.arrEntities[i].glDrwList = gl.GenLists(1)
            gl.NewList(gcd.CurrDrawing.arrEntities[i].glDrwList, gl.COMPILE)
            gcd.CurrDrawing.arrEntities[i].ClassHandler.Draw(gcd.CurrDrawing.arrEntities[i])
            gl.EndList

        Next

        ' lista de entidaes seleccionadas
        For i = 0 To gcd.CurrDrawing.arrEntities.Max
            If Not gl.islist(gcd.CurrDrawing.arrEntities[i].glDrwListSel) Then gcd.CurrDrawing.arrEntities[i].glDrwListSel = gl.GenLists(1)
            gl.NewList(gcd.CurrDrawing.arrEntities[i].glDrwListSel, gl.COMPILE)
            gcd.CurrDrawing.arrEntities[i].ClassHandler.DrawSelected(gcd.CurrDrawing.arrEntities[i])
            gl.EndList
        Next

        ' lista de todas las entidades
        t = Timer
        glGenDrawListLAyers

        Debug "GLlista de todas generada en  ", Timer - t
    End If

End

'' Generates a GL list for the selected
'' Mode: 0=Selected version 1=Normal version
Public Sub glGenDrawListSel(Optional mode As Integer = 0)

    Dim idDrawing As Integer ' la instancia de dibujo en la que estamos
    Dim i As Integer

    If Not gl.islist(gcd.CurrDrawing.GlListSelectedEntities) Then gcd.CurrDrawing.GlListSelectedEntities = gl.GenLists(1)

    gl.NewList(gcd.CurrDrawing.GlListSelectedEntities, gl.COMPILE)

    For i = 0 To gcd.CurrDrawing.arrEntities.Max

        If gcd.CurrDrawing.arrEntities[i].Selected Then
            If mode = 0 Then gl.CallList(gcd.CurrDrawing.arrEntities[i].glDrwListSel)
            If mode = 1 Then gl.CallList(gcd.CurrDrawing.arrEntities[i].glDrwList)
        End If
    Next

    gl.EndList

End

'' Generates a GL list for the selected
'' Mode: 0=Selected version 1=Normal version
Public Sub glGenDrawListAll(Optional ExcludeSelected As Boolean = False)

    Dim i As Integer

    gl.NewList(gcd.CurrDrawing.GlListAllEntities, gl.COMPILE)

    For i = 0 To gcd.CurrDrawing.arrEntities.max
        If Not (gcd.CurrDrawing.arrEntities[i].Selected And ExcludeSelected) Then gl.CallList(gcd.CurrDrawing.arrEntities[i].glDrwList)

    Next

    gl.EndList

    For i = 0 To gcd.CurrDrawing.arrLayers.max
        If Not gl.islist(gcd.CurrDrawing.arrLayers[i].glList) Then gcd.CurrDrawing.arrLayers[i].glList = gl.GenLists(1)
        gl.NewList(gcd.CurrDrawing.arrLayers[i].glList, gl.COMPILE)
    Next
    For i = 0 To gcd.CurrDrawing.arrEntities.max
        If Not (gcd.CurrDrawing.arrEntities[i].Selected And ExcludeSelected) Then gl.CallList(gcd.CurrDrawing.arrEntities[i].glDrwList)

    Next

    gl.EndList

End

'' Generates a GL list for the selected
'' Mode: 0=Selected version 1=Normal version
Public Sub glGenDrawListLAyers(Optional aLayer As Layer)

    Dim i As Integer
    Dim e As Entity

    If aLayer Then

        If Not gl.islist(aLayer.glList) Then aLayer.glList = gl.GenLists(1)
        gl.NewList(aLayer.glList, gl.COMPILE)
        For Each e In gcd.CurrDrawing.arrEntities

            If e.pLayer = aLayer Then gl.CallList(e.glDrwList)

        Next
        gl.EndList

    Else

        For Each aLayer In gcd.CurrDrawing.arrLayers
            If Not gl.islist(aLayer.glList) Then aLayer.glList = gl.GenLists(1)
            gl.NewList(aLayer.glList, gl.COMPILE)
            For Each e In gcd.CurrDrawing.arrEntities

                If e.pLayer = aLayer Then e.ClassHandler.Draw(e)

            Next
            gl.EndList

        Next

    Endif

End

'' Generates a GL list for the selected
'' Mode: 0=Selected version 1=Normal version
Public Sub glGenDrawListLAyers2(Optional aLayer As Layer)

    Dim i As Integer
    Dim e As Entity

    If aLayer Then

        If Not gl.islist(aLayer.glList) Then aLayer.glList = gl.GenLists(1)
        gl.NewList(aLayer.glList, gl.COMPILE)
        For Each e In gcd.CurrDrawing.arrEntities

            If e.pLayer = aLayer Then gl.CallList(e.glDrwList)

        Next
        gl.EndList

    Else

        For Each aLayer In gcd.CurrDrawing.arrLayers
            If Not gl.islist(aLayer.glList) Then aLayer.glList = gl.GenLists(1)
            gl.NewList(aLayer.glList, gl.COMPILE)
            For Each e In aLayer.Entities
                e.ClassHandler.Draw(e)

            Next
            gl.EndList

        Next

    Endif

End

Public Sub DrawPoiSymbolsAll()

    Dim i, total As Integer

    For i = 0 To gcd.CurrDrawing.arrEntities.Max

        If gcd.CurrDrawing.arrEntities[i].Selected Then

            If (gcd.CurrDrawing.arrEntities[i].Gender = "Insert") Then
                DrawPoiSymbols(gcd.CurrDrawing.arrEntities[i])
                Inc total
            End If
        End If
        If total = 100 Then Break                           ' limitamos la cantidad de enganches a un numero sensato
    Next

End

Public Sub DrawPoiSymbols(oE As Entity)

    Dim i As Integer

    For i = 0 To oe.PoiPoints.Max Step 2
        Select Case oe.PoiType[i / 2]
            Case gcd.poiEndPoint
                glPlus.Rectangle2D(oe.PoiPoints[i] - gcd.Metros(4), oe.PoiPoints[i + 1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Blue,,,, Color.Cyan, 1, 1)

            Case gcd.poiMidPoint
                glPlus.Rectangle2D(oe.PoiPoints[i] - gcd.Metros(4), oe.PoiPoints[i + 1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Cyan,,,, Color.Blue, 1, 1)

            Case gcd.poiCenter
                glPlus.Rectangle2D(oe.PoiPoints[i] - gcd.Metros(4), oe.PoiPoints[i + 1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Cyan,,,, Color.Blue, 1, 1)

            Case gcd.poiQuadrant
                glPlus.Rectangle2D(oe.PoiPoints[i] - gcd.Metros(4), oe.PoiPoints[i + 1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Blue,,,, Color.Cyan, 1, 1)

            Case gcd.poiBasePoint
                glPlus.Rectangle2D(oe.PoiPoints[i] - gcd.Metros(4), oe.PoiPoints[i + 1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Cyan,,,, Color.Blue, 1, 1)

        End Select

    Next

End

Public Sub Finish(Optional selected As Boolean = True)

    ' creo copias de cada elemento seleccionado
    Dim m As Integer, i As Integer

    m = gcd.CurrDrawing.arrEntities.Max
    For i = 0 To m
        If selected Then                                                    ' apply to only the selected ones
            If gcd.CurrDrawing.arrEntities[i].Selected Then gcd.CurrDrawing.arrEntities[i].ClassHandler.Finish(gcd.CurrDrawing.arrEntities[i])
        Else                                                                ' apply to all
            gcd.CurrDrawing.arrEntities[i].ClassHandler.Finish(gcd.CurrDrawing.arrEntities[i])
        End If

    Next

End

Public Sub ClonElements(Optional selected As Boolean = True)

    ' creo copias de cada elemento seleccionado
    Dim i As Integer
    Dim iIndex As Integer

    For i = 0 To gcd.CurrDrawing.arrSelecIndex.Max
        iIndex = gcd.CurrDrawing.arrSelecIndex[i]

        ' If SkipParts Then
        '     If (gcd.CurrDrawing.arrEntities[i].iInsert < 0) Or (gcd.CurrDrawing.arrEntities[i].iInsert = i) Then
        '         gcd.CurrDrawing.arrEntities.Add(ClonEntity(gcd.CurrDrawing.arrEntities[i]))
        '         gcd.CurrDrawing.arrEntities.Last.ClassHandler.finish(gcd.CurrDrawing.arrEntities.Last)
        '     End If
        ' Else
        gcd.CurrDrawing.arrEntities.Add(ClonEntity(gcd.CurrDrawing.arrEntities[iIndex]))
        gcd.CurrDrawing.arrEntities.Last.ClassHandler.finish(gcd.CurrDrawing.arrEntities.Last)
        gcd.CurrDrawing.CurrLayer.Entities.Add(gcd.CurrDrawing.arrEntities.Last)
        ' Endif

        'End If
    Next

End

Public Sub ClonEntity(e As Entity, Optional GetNewHandle As Boolean = True) As Entity
    ' clona una entidad
    ' copia todos sus elementos
    ' llama a las rutinas de reconstruccion del contorno y de los POI

    Dim o As New Entity

    CopyElemData(e, o)                              ' copy all values
    o.ClassHandler.BuildPoi(o)
    If GetNewHandle Then o.Handle = gcd.NewHandle()
    Return o

End

'' Busca elementos seleccionados y arma un array nuevo con ellos, eliminandolos del anterior
Public Function SelectArrayMake() As Integer

End

Public Function DeSelection(Optional elementos As String = "todo", Accion As String = "deseleccionar") As Integer
    ' Esta rutina analiza si los elemento seleccionados para alguna accion pueden realizarla, caso contrario los deselecciona
    ' se basa en los puntos que tengan la propiedad .Selected = True
    ' tambien puede deseleccionar todo
    ' Devuelve la cantidad de elementos que quedaron seleccionados despues de filtrar

    Dim i As Integer, c As Integer, Clase As String, iii As Integer

    ' por las dudas vengan alguna letra mayuscula
    If Accion = "" Then accion = "deseleccionar"
    accion = LCase(accion)
    elementos = LCase(elementos)

    '   primero vacio la seleccion anterior
    gcd.CurrDrawing.arrSelecIndex.Clear

    For iii = 0 To gcd.CurrDrawing.arrEntities.Max

        clase = gcd.CurrDrawing.arrEntities[iii].Gender

        Select Case accion

            Case "mover", "copiar", "borrar", "escalar" ' necesito que todos los puntos esten seleccionados

                If SelFull() And (elementos = "todo" Or elementos = clase) Then

                    gcd.CurrDrawing.arrSelecIndex.Add(iii)
                    SelectElem(iii)
                    Inc i

                Else

                    DeSelectElem(iii)

                End If

            Case "estirar" ' necesito que dos puntos contiguos esten seleccionados

                If SelPArtial() And (elementos = "todo" Or elementos = clase) Then
                    gcd.CurrDrawing.arrSelecIndex.Add(iii)
                    SelectElem(iii, False) ' dont touch the points
                    Inc i

                Else

                    DeSelectElem(iii)

                End If

            Case "deseleccionar" ' todas las acciones

                If (elementos = "todo" Or elementos = clase) Then

                    Inc i
                    DeSelectElem(iii)

                End If

        End Select

    Next

    Return i

End

Public Function GetSelectionCount() As Integer

    Dim i, ii As Integer

    gcd.CurrDrawing.arrSelecIndex.Clear
    For i = 0 To gcd.CurrDrawing.arrEntities.Max
        If gcd.CurrDrawing.arrEntities[i].Selected Then
            Inc ii
            gcd.CurrDrawing.arrSelecIndex.Add(i)
        End If
    Next
    Return ii

End Function

Public Function DeleteSelected() As Integer

    Dim i As Integer, c As Integer
    Dim lay As Layer

    '  Purgue will also delete those with .ForDeletion = true

    For i = gcd.CurrDrawing.arrEntities.Max To 0 Step -1

        If gcd.CurrDrawing.arrEntities[i].Selected Then
            gcd.CurrDrawing.arrEntities.Remove(i)
            Inc c
        End If

    Next

    '   we also need to regenerate the drawing list
    For Each lay In gcd.CurrDrawing.arrLayers
        If lay.Visible Then glGenDrawListLayers(lay)
    Next

    ' we also need too recalculate visible items
    Me.CollectVisibleEntities()

    ' TODO: put something in UNDO collection

    Return c

End Function

Public Function SelectFromPoint(Xr As Float, Zr As Float, Optional Autoselect As Boolean = True) As Entity

    Dim i As Integer

    For i = gcd.CurrDrawing.arrEntities.Max To 0 Step -1
        ' last elements are drawn last so the click belongs to them
        If gcd.CurrDrawing.arrEntities[i].pointClick(Xr, Zr) Then
            If Autoselect Then
                If Not gcd.CurrDrawing.arrEntities[i].Selected Then
                    SelectElem(gcd.CurrDrawing.arrEntities[i])
                Else
                    DeSelectElem(gcd.CurrDrawing.arrEntities[i])
                End If
            End If
            Return gcd.CurrDrawing.arrEntities[i]
        End If

    Next

End

Public Sub DrawPoint(x As Float, y As Float, Optional colour As Integer = -1, Optional LargoReal As Float = 0.4)

    If colour <> -1 Then
        paint.brush = Paint.Color(colour)
    Else
        paint.brush = Paint.Color(Color.Blue)
    End If
    paint.LineWidth = 1
    paint.MoveTo(x - LargoReal / 2, y)
    paint.RelLineTo(LargoReal, 0)

    paint.MoveTo(x, y - LargoReal / 2)
    paint.RelLineTo(0, -LargoReal)
    paint.Stroke

End

' Public Sub SelectElem(iEntity As Integer, Optional AndItsPoints As Boolean = True)
'
'   ' select all points and myself
'
'   Dim i As Integer
'
'   If gcd.CurrDrawing.arrEntities[iEntity].iInsert >= 0 Then
'     ' es parte de un bloque, lo selecciono completo
'     i = GetParentBlock(iEntity)
'     SelectAllElemFromBlock(iEntity, AndItsPoints)
'     Return
'   Endif
'
'   If AndItsPoints Then
'     For i = 0 To gcd.CurrDrawing.arrEntities[iEntity].Psel.Max
'       gcd.CurrDrawing.arrEntities[iEntity].Psel[i] = True
'     Next
'
'   End If
'   gcd.CurrDrawing.arrEntities[iEntity].selected = True
'
' End

' Public Sub SelectAllElemFromBlock(iBlock As Integer, Optional AndItsPoints As Boolean = True)
'
'   ' select all elements from a block
'
'   Dim i, ii, iii As Integer
'
'   gcd.CurrDrawing.arrEntities[iBlock].selected = True                                                   ' seleccionamos el insert
'
'   For i = gcd.CurrDrawing.arrEntities[iBlock].iInsert + 1 To gcd.CurrDrawing.arrEntities.max             ' y sus entidades
'
'     If gcd.CurrDrawing.arrEntities[i].iInsert <> gcd.CurrDrawing.arrEntities[iBlock].iInsert Then Break
'
'     If AndItsPoints Then
'       For ii = 0 To gcd.CurrDrawing.arrEntities[i].Psel.Max
'         gcd.CurrDrawing.arrEntities[i].Psel[ii] = True                                      ' y sus puntos
'       Next
'
'     End If
'
'     gcd.CurrDrawing.arrEntities[i].selected = True
'
'   Next
'
' End

' Public Sub DeSelectAllElemFromBlock(iBlock As Integer, Optional AndItsPoints As Boolean = True)
'
'   ' deselect all elements from a block
'
'   Dim i, ii, iii As Integer
'
'   For i = iBlock + 1 To gcd.CurrDrawing.arrEntities.max             ' y sus entidades
'
'     If gcd.CurrDrawing.arrEntities[i].iInsert <> iBlock Then Break
'
'     If AndItsPoints Then
'       For ii = 0 To gcd.CurrDrawing.arrEntities[i].Psel.Max
'         gcd.CurrDrawing.arrEntities[i].Psel[ii] = False                                      ' y sus puntos
'       Next
'
'     End If
'
'     gcd.CurrDrawing.arrEntities[i].selected = False
'
'   Next
'
' End

Public Sub SelectElem(iEntity As Integer, Optional AndItsPoints As Boolean = True)

    Dim i, ii As Integer

    ' If gcd.CurrDrawing.arrEntities[iEntity].Gender = "Insert" Then          ' es un inserto
    '     If gcd.CurrDrawing.arrEntities[iEntity].iInsert >= 0 Then             ' esta dentro de otro insert?
    '         If Not gcd.CurrDrawing.arrEntities[iEntity].selected Then               ' si estaba seleccionada
    '             SelectElem(gcd.CurrDrawing.arrEntities[iEntity].iInsert, AndItsPoints)  ' llamo recursivamente
    '         End If
    '     Else                                                                ' no, deselecciono hasta encontrar un -1
    '         gcd.CurrDrawing.arrEntities[iEntity].selected = True
    '         For i = iEntity + 1 To gcd.CurrDrawing.arrEntities.max              ' y sus entidades
    '
    '             If gcd.CurrDrawing.arrEntities[i].iInsert = -1 Then Break
    '
    '             gcd.CurrDrawing.arrEntities[i].selected = True
    '
    '             If AndItsPoints Then
    '                 For ii = 0 To gcd.CurrDrawing.arrEntities[i].Psel.Max
    '                     gcd.CurrDrawing.arrEntities[i].Psel[ii] = True                                      ' y sus puntos
    '                 Next
    '
    '             End If
    '
    '         Next
    '     End If
    ' Else                                                          ' no es un inserto, pero es parte de uno?
    '
    '     If gcd.CurrDrawing.arrEntities[iEntity].iInsert >= 0 Then     ' si, llamo recursivamente
    '         If Not gcd.CurrDrawing.arrEntities[iEntity].selected Then       ' pero solo si estaba seleccionada
    '             SelectElem(gcd.CurrDrawing.arrEntities[iEntity].iInsert, AndItsPoints)
    '             Return
    '         End If
    '     Else                                                        ' no, simplemente deselecciono esta entidad

    gcd.CurrDrawing.arrEntities[iEntity].selected = True
    If AndItsPoints Then
        For i = 0 To gcd.CurrDrawing.arrEntities[iEntity].Psel.Max
            gcd.CurrDrawing.arrEntities[iEntity].Psel[i] = True
        Next

    End If
    'End If

    ' Endif

End

Public Sub DeSelectElem(iEntity As Integer, Optional AndItsPoints As Boolean = True)

    ' deselect all points and myself

    Dim i, ii As Integer

    ' If gcd.CurrDrawing.arrEntities[iEntity].Gender = "Insert" Then          ' es un inserto
    '     If gcd.CurrDrawing.arrEntities[iEntity].iInsert >= 0 Then             ' esta dentro de otro insert?
    '         If gcd.CurrDrawing.arrEntities[iEntity].selected Then               ' si estaba seleccionada
    '             DeSelectElem(gcd.CurrDrawing.arrEntities[iEntity].iInsert, AndItsPoints)  ' llamo recursivamente
    '         End If
    '     Else                                                                ' no, deselecciono hasta encontrar un -1
    '         gcd.CurrDrawing.arrEntities[iEntity].selected = False
    '         For i = iEntity + 1 To gcd.CurrDrawing.arrEntities.max              ' y sus entidades
    '
    '             If gcd.CurrDrawing.arrEntities[i].iInsert = -1 Then Break
    '
    '             gcd.CurrDrawing.arrEntities[i].selected = False
    '
    '             If AndItsPoints Then
    '                 For ii = 0 To gcd.CurrDrawing.arrEntities[i].Psel.Max
    '                     gcd.CurrDrawing.arrEntities[i].Psel[ii] = False                                      ' y sus puntos
    '                 Next
    '
    '             End If
    '
    '         Next
    '     End If
    ' Else                                                          ' no es un inserto, pero es parte de uno?
    '
    '     If gcd.CurrDrawing.arrEntities[iEntity].iInsert >= 0 Then     ' si, llamo recursivamente
    '         If gcd.CurrDrawing.arrEntities[iEntity].selected Then       ' pero solo si estaba seleccionada
    '             DeSelectElem(gcd.CurrDrawing.arrEntities[iEntity].iInsert, AndItsPoints)
    '             Return
    '         End If
    '     Else                                                        ' no, simplemente deselecciono esta entidad

    gcd.CurrDrawing.arrEntities[iEntity].selected = False
    If AndItsPoints Then
        For i = 0 To gcd.CurrDrawing.arrEntities[iEntity].Psel.Max
            gcd.CurrDrawing.arrEntities[iEntity].Psel[i] = False
        Next

    End If
    ' End If

    ' Endif

End

Public Sub CopyElemData(origen As Entity, destino As Entity)

    ' when adding stuff to the elements, it must be added here
    Dim i As Integer
    ' arrays
    destino.p.resize(origen.p.count)
    destino.fparam.resize(origen.fparam.count)
    destino.iparam.resize(origen.iparam.count)
    destino.psel.resize(origen.psel.count)
    destino.StringData.resize(origen.StringData.count)
    For i = 0 To origen.p.Max
        destino.P[i] = origen.P[i]
    Next
    For i = 0 To origen.fparam.Max
        destino.fparam[i] = origen.fparam[i]
    Next
    For i = 0 To origen.iparam.Max
        destino.iparam[i] = origen.iparam[i]
    Next
    For i = 0 To origen.StringData.Max
        destino.StringData[i] = origen.StringData[i]
    Next

    destino.Gender = origen.Gender
    destino.ClassHandler = origen.ClassHandler
    destino.pLayer = origen.pLayer
    destino.pBlock = origen.pBlock
    destino.Group = origen.Group
    destino.colour = origen.colour
    destino.ColorToPaint = origen.ColorToPaint
    destino.LineType = origen.LineType
    destino.LineWidth = origen.LineWidth
    destino.Handle = origen.Handle
    destino.HandleOwner = origen.HandleOwner
    destino.pStyle = origen.pStyle

End

Public Sub Move(dX As Float, dY As Float, Optional OnlySelected As Boolean = False, OnlyPointSelected As Boolean = False)

    ' crea un backup de todos los puntos
    Dim e As Entity, i As Integer

    For Each e In gcd.CurrDrawing.arrEntities
        If (e.selected And OnlySelected) Or Not OnlySelected Then

            e.ClassHandler.Translate(e, dX, dY, OnlyPointSelected)

        Endif

    Next

End

Public Sub Rotate(degAngle As Float, Optional OnlySelected As Boolean = False, OnlyPointSelected As Boolean = False)

    ' crea un backup de todos los puntos
    Dim e As Entity, i As Integer

    For Each e In gcd.CurrDrawing.arrEntities
        If (e.selected And OnlySelected) Or Not OnlySelected Then

            e.ClassHandler.Rotate(e, degAngle)

        Endif

    Next

End

Public Sub Scale(sX As Float, sY As Float, Optional sZ As Float = 1, OnlySelected As Boolean = False, OnlyPointSelected As Boolean = False)

    ' crea un backup de todos los puntos
    Dim e As Entity, i As Integer

    For Each e In gcd.CurrDrawing.arrEntities
        If (e.selected And OnlySelected) Or Not OnlySelected Then

            e.ClassHandler.Scale(e, sX, sY)

        Endif

    Next

End

Public Function SelectionSquare(X1real As Float, Y1real As Float, X2real As Float, Y2real As Float, Optional NuevaSumaResta As String = "nueva", crossing As Boolean) As Integer

    ' Veo que accion estoy tomando
    Dim e As Entity, i, i2, TotalSeleccionados As Integer

    NuevaSumaResta = LCase$(NuevaSumaResta)

    If NuevaSumaResta = "nueva" Then ' nueva seleccion
        For i = 0 To gcd.CurrDrawing.arrEntities.Max
            gcd.CurrDrawing.arrEntities[i].selected = False
            For i2 = 0 To gcd.CurrDrawing.arrEntities[i].Psel.max
                gcd.CurrDrawing.arrEntities[i].Psel[i2] = False
            Next
        Next
        TotalSeleccionados = 0
    End If

    For i = 0 To gcd.CurrDrawing.arrEntities.Max
        ' cada entidad debe decidir si esta seleccionada o no
        If crossing Then
            If SelPArtial(i, X1real, Y1real, X2real, Y2real) Then
                ' el punto esta en el recuadro
                If NuevaSumaResta <> "resta" Then
                    Inc TotalSeleccionados
                    Me.SelectElem(i, False)

                Else If NuevaSumaResta = "resta" Then
                    Dec TotalSeleccionados
                    Me.DeSelectElem(i, False)

                End If

            Endif
        Else
            If SelFull(i, X1real, Y1real, X2real, Y2real) Then
                ' el punto esta en el recuadro
                If NuevaSumaResta <> "resta" Then
                    Inc TotalSeleccionados
                    Me.SelectElem(i, False)

                Else If NuevaSumaResta = "resta" Then
                    Dec TotalSeleccionados
                    Me.DeSelectElem(i, False)

                End If

            Endif

        End If
    Next
    GetSelectionCount()

    GetSelectionHandles(gcd.CurrDrawing.hSelection)

    Return TotalSeleccionados

End

'' Put all visible entity refs in arrVisibleEntities[]
Public Function CollectVisibleEntities()

    Dim x0, y0, x1, y1 As Float
    Dim lay As Layer
    Dim e As Entity
    Dim i, tot As Integer

    x0 = fMain.Xreal(0)
    y1 = fMain.yreal(0)                     ' el eje Y esta invertido en OpenGL
    x1 = fMain.Xreal(fMain.GLArea1.w)
    y0 = fMain.yreal(fMain.GLArea1.h)

    If gcd.CurrDrawing.arrEntities.Max > gcd.CurrDrawing.arrVisibleEntities.Max Then gcd.currDrawing.arrVisibleEntities.Resize(gcd.CurrDrawing.arrEntities.Count)

    For i = 0 To gcd.CurrDrawing.arrEntities.Max
        If gcd.CurrDrawing.arrEntities[i].pLayer.Visible Then

            If SelPArtial(i, x0, y0, x1, y1) Then

                gcd.CurrDrawing.arrVisibleEntities[tot] = i
                Inc tot
            End If
        End If
    Next
    gcd.CurrDrawing.VisibleEntitiesMax = tot - 1

End

Public Function GetSelectionHandles(sHandles As String[]) As Integer

    Dim i As Integer
    Dim itotal As Integer

    Dim t As Float = Timer

    sHandles.Clear
    'sHandles.Resize
    For i = 0 To gcd.CurrDrawing.arrEntities.Max
        If gcd.CurrDrawing.arrEntities[i].Selected Then
            sHandles.Add(gcd.CurrDrawing.arrEntities[i].Handle)
            Inc itotal
        End If
    Next
    Debug itotal, " en ", t - Timer, " seg"
    Return itotal

End

' Public Function SelectionSquare2(X1real As Float, Y1real As Float, X2real As Float, Y2real As Float, Optional NuevaSumaResta As String = "nueva", crossing As Boolean) As Integer
'
'     ' Veo que accion estoy tomando
'     Dim e As Entity, i, i2, CurrentEntityIndex, TotalSeleccionados As Integer, Todos As Boolean
'     Dim t As Float = Timer
'
'     NuevaSumaResta = LCase$(NuevaSumaResta)
'
'     If NuevaSumaResta = "nueva" Then
'         For i = 0 To gcd.CurrDrawing.arrEntities.Max
'             gcd.CurrDrawing.arrEntities[i].selected = False
'             For i2 = 0 To gcd.CurrDrawing.arrEntities[i].Psel.max
'                 gcd.CurrDrawing.arrEntities[i].Psel[i2] = False
'             Next
'         Next
'     End If
'     Debug "Deselect time ", Timer - t
'
'     ' reviso los poligonos
'     For i = 0 To gcd.CurrDrawing.poiPoligonEntities.Max
'
'         If crossing Then
'             If puntos.IsPoligonCrossingRect(gcd.CurrDrawing.poiPoligons, X1real, Y1real, X2real, Y2real, gcd.CurrDrawing.poiPoligonStartIndex[i], gcd.CurrDrawing.poiPoligonElements[i]) Then
'                 ' el punto esta en el recuadro
'                 If NuevaSumaResta <> "resta" Then
'                     Inc TotalSeleccionados
'                     gcd.CurrDrawing.arrEntities[i].selected = True
'
'                 Else If NuevaSumaResta = "resta" Then
'                     Dec TotalSeleccionados
'                     gcd.CurrDrawing.arrEntities[i].selected = False
'
'                 End If
'
'             Endif
'         Else
'             If puntos.IsPoligonInsideRect(gcd.CurrDrawing.poiPoligons, X1real, Y1real, X2real, Y2real, gcd.CurrDrawing.poiPoligonStartIndex[i], gcd.CurrDrawing.poiPoligonElements[i]) Then
'                 ' el punto esta en el recuadro
'                 If NuevaSumaResta <> "resta" Then
'                     Inc TotalSeleccionados
'                     gcd.CurrDrawing.arrEntities[i].selected = True
'
'                 Else If NuevaSumaResta = "resta" Then
'                     Dec TotalSeleccionados
'                     gcd.CurrDrawing.arrEntities[i].selected = False
'
'                 End If
'
'             Endif
'
'         End If
'     Next
'
'     ' reviso las lineas
'     If crossing Then
'         For i = 0 To gcd.CurrDrawing.poiLines.Max Step 2                                                                                                  ' para cada punto
'             If puntos.InBetween(gcd.CurrDrawing.poiLines[i], X1real, X2real) And puntos.InBetween(gcd.CurrDrawing.poiLines[i + 1], Y1real, Y2real) Then     ' esta dentro
'                 ' el punto esta en el recuadro
'                 If NuevaSumaResta <> "resta" Then
'                     Inc TotalSeleccionados
'                     gcd.CurrDrawing.arrEntities[gcd.CurrDrawing.poiLinesEntities[i / 4]].selected = True
'                     gcd.CurrDrawing.arrEntities[gcd.CurrDrawing.poiLinesEntities[i / 4]].Psel[gcd.CurrDrawing.poiLinesRelPoint[i / 2]] = True
'                 Else If NuevaSumaResta = "resta" Then
'                     Dec TotalSeleccionados
'                     gcd.CurrDrawing.arrEntities[gcd.CurrDrawing.poiLinesEntities[i / 4]].selected = False
'                     gcd.CurrDrawing.arrEntities[gcd.CurrDrawing.poiLinesEntities[i / 4]].Psel[gcd.CurrDrawing.poiLinesRelPoint[i / 2]] = False
'
'                 End If
'
'             Endif
'
'         Next
'
'     Else    ' full selection
'         ' hago un crossing primero y luego me fijo si estan todos
'         For i = 0 To gcd.CurrDrawing.poiLines.Max Step 2                                                                                                  ' para cada punto
'             If puntos.InBetween(gcd.CurrDrawing.poiLines[i], X1real, X2real) And puntos.InBetween(gcd.CurrDrawing.poiLines[i + 1], Y1real, Y2real) Then     ' esta dentro
'                 ' el punto esta en el recuadro
'                 If NuevaSumaResta <> "resta" Then
'                     Inc TotalSeleccionados
'                     gcd.CurrDrawing.arrEntities[gcd.CurrDrawing.poiLinesEntities[i / 4]].selected = True
'                     gcd.CurrDrawing.arrEntities[gcd.CurrDrawing.poiLinesEntities[i / 4]].Psel[gcd.CurrDrawing.poiLinesRelPoint[i / 2]] = True
'                 Else If NuevaSumaResta = "resta" Then
'                     Dec TotalSeleccionados
'                     gcd.CurrDrawing.arrEntities[gcd.CurrDrawing.poiLinesEntities[i / 4]].selected = False
'                     gcd.CurrDrawing.arrEntities[gcd.CurrDrawing.poiLinesEntities[i / 4]].Psel[gcd.CurrDrawing.poiLinesRelPoint[i / 2]] = False
'
'                 End If
'
'             Endif
'
'         Next
'
'         CurrentEntityIndex = 0
'         For i = 0 To gcd.CurrDrawing.arrEntities.Max
'
'             If gcd.CurrDrawing.arrEntities[i].Selected Then 'chequeo si todos estan seleccionados
'                 todos = True
'                 For i2 = 0 To gcd.CurrDrawing.arrEntities[i].Psel.Max
'                     If gcd.CurrDrawing.arrEntities[i].Psel = False Then
'                         todos = False
'                         Break
'                     Endif
'                 Next
'
'                 If (todos And NuevaSumaResta = "resta") Or Not todos Then
'                     Dec TotalSeleccionados
'                     gcd.CurrDrawing.arrEntities[i].selected = False
'                     For i2 = 0 To gcd.CurrDrawing.arrEntities[i].Psel.Max
'                         gcd.CurrDrawing.arrEntities[i].Psel = False
'
'                     Next
'
'                 End If
'
'             Endif
'
'         Next
'
'     Endif
'
'     Return TotalSeleccionados
'
' End

'Return bound limits for all verices in the array of entities
Public Sub BuildPoi(Optional entities As Entity[], OnlyVisibles As Boolean = True)

    Dim e As Entity, i As Integer
    Dim entGroup As Entity[]

    If Not entities Then entGroup = gcd.CurrDrawing.arrEntities Else entGroup = Entities

    If entGroup.Count = 0 Then Return

    For Each e In entGroup
        If (OnlyVisibles And e.pLayer.Visible) Or Not OnlyVisibles Then
            e.ClassHandler.BuildPoi(e)
        End If
    Next

End
'Return bound limits for all verices in the array of entities

Public Function ComputeLimits(Optional entities As Entity[], OnlyVisibles As Boolean = True) As Float[]

    Dim e As Entity, i As Integer
    Dim entGroup As Entity[]
    Dim Xmenor As Float = 1e10, Ymenor As Float = 1e10, Xmayor As Float = -1e10, Ymayor As Float = -1e10
    Dim newLimits As New Float[]
    Dim IsVisible As Boolean

    If Not entities Then entGroup = gcd.CurrDrawing.arrEntities Else entGroup = Entities

    If entGroup.Count = 0 Then Return Null

    For Each e In entGroup
        If OnlyVisibles Then
            If IsNull(e.pLayer) Then
                IsVisible = True
            Else
                IsVisible = e.pLayer.Visible
            End If

        Endif

        If IsVisible Then

            If e.Gender = "Insert" Then
                If IsNull(e.pBlock) Then Continue
                newLimits = ComputeLimits(e.pBlock.entities)
                If IsNull(newLimits) Then Continue
                puntos.Translate(newLimits, e.P[0], e.P[1])
                puntos.Rotate(newLimits, e.fParam[cadInsert.ipaRotacion]) ' TODO: verificar orden de esta y la siguiente linea
                puntos.Scale(newLimits, e.fParam[cadInsert.ipaEscX], e.fParam[cadInsert.ipaEscY])
                If Xmenor > newLimits[0] Then Xmenor = newLimits[0]
                If ymenor > newLimits[1] Then ymenor = newLimits[01]
                If Xmayor > newLimits[2] Then Xmayor = newLimits[2]
                If Ymayor > newLimits[3] Then Ymayor = newLimits[3]
            End If

            If e.Gender Like "DIM*" Then

                If IsNull(e.pBlock) Then Continue
                newLimits = ComputeLimits(e.pBlock.entities)
                If IsNull(newLimits) Then Continue
                'puntos.Translate(newLimits, e.P[0], e.P[1])
                'puntos.Rotate(newLimits, e.fParam[cadInsert.ipaRotacion]) ' TODO: verificar orden de esta y la siguiente linea
                'puntos.Scale(newLimits, e.fParam[cadInsert.ipaEscX], e.fParam[cadInsert.ipaEscY])
                If Xmenor > newLimits[0] Then Xmenor = newLimits[0]
                If ymenor > newLimits[1] Then ymenor = newLimits[01]
                If Xmayor > newLimits[2] Then Xmayor = newLimits[2]
                If Ymayor > newLimits[3] Then Ymayor = newLimits[3]
            End If

            If e.Polygon.Count > 0 Then

                For i = 0 To e.Polygon.max Step 2
                    'If e.p[i] > 0 Then Debug e.gender

                    If e.Polygon[i] < Xmenor Then Xmenor = e.Polygon[i]

                    If e.Polygon[i + 1] < Ymenor Then Ymenor = e.Polygon[i + 1]

                    If e.Polygon[i] > Xmayor Then Xmayor = e.Polygon[i]

                    If e.Polygon[i + 1] > Ymayor Then Ymayor = e.Polygon[i + 1]

                Next
            Else If e.PolyLine.Count > 0 Then

                For i = 0 To e.PolyLine.max Step 2
                    'If e.p[i] > 0 Then Debug e.gender

                    If e.PolyLine[i] < Xmenor Then Xmenor = e.PolyLine[i]

                    If e.PolyLine[i + 1] < Ymenor Then Ymenor = e.PolyLine[i + 1]

                    If e.PolyLine[i] > Xmayor Then Xmayor = e.PolyLine[i]

                    If e.PolyLine[i + 1] > Ymayor Then Ymayor = e.PolyLine[i + 1]

                Next
            Else

                For i = 0 To e.p.max Step 2

                    If i > e.P.Max - 1 Then Break
                    'If e.p[i] > 0 Then Debug e.gender

                    If e.p[i] < Xmenor Then Xmenor = e.p[i]

                    If e.p[i + 1] < Ymenor Then Ymenor = e.p[i + 1]

                    If e.p[i] > Xmayor Then Xmayor = e.p[i]

                    If e.p[i + 1] > Ymayor Then Ymayor = e.p[i + 1]

                Next
            End If
        End If
        'If Xmenor < -6000 Then Stop
        'If Xmayor > 100000 Then Stop

    Next

    Return [Xmenor, Ymenor, Xmayor, Ymayor]

End

'' Determines if the entity was selected by a rectanle surrounding al points
'' by default, if ALL points are selected, it can.
Public Function SelFull(i As Integer, X1real As Float, Y1real As Float, X2real As Float, Y2real As Float) As Boolean

    Dim ii As Integer, puedo As Boolean

    Select Case gcd.CurrDrawing.arrEntities[i].Gender

        Case Else

            ' Si tengo un bounding poligon, entonces verifico que todos los puntos esten dentro
            If gcd.CurrDrawing.arrEntities[i].Polygon.Count > 0 Then

                Return puntos.IsPoligonInsideRect(gcd.CurrDrawing.arrEntities[i].Polygon, X1real, Y1real, X2real, Y2real)

            Else    ' no tengo un poligono, entonces verifico que todos los puntos definitorios de al entidad esten dentro

                puedo = True                     ' supongamos que puedo, por ahora
                For ii = 0 To gcd.CurrDrawing.arrEntities[i].p.max Step 2
                    If ii + 1 > gcd.CurrDrawing.arrEntities[i].p.max Then Break
                    If Not (gcd.CurrDrawing.arrEntities[i].p[ii] >= X1real And gcd.CurrDrawing.arrEntities[i].p[ii] <= X2real) And (gcd.CurrDrawing.arrEntities[i].p[ii + 1] >= Y1real And gcd.CurrDrawing.arrEntities[i].p[ii + 1] <= Y2real) Then
                        puedo = False
                    End If
                Next

                If puedo Then
                    For ii = 0 To gcd.CurrDrawing.arrEntities[i].PSel.Max
                        gcd.CurrDrawing.arrEntities[i].PSel[ii] = True
                    Next

                    Return True
                Else
                    For ii = 0 To gcd.CurrDrawing.arrEntities[i].PSel.Max
                        gcd.CurrDrawing.arrEntities[i].PSel[ii] = False
                    Next

                    Return False
                End If
            Endif
    End Select

End
'
' '' Determines if the entity
' '' by default, if ANY point is selected, it can.

Public Function SelPartial(i As Integer, X1real As Float, Y1real As Float, X2real As Float, Y2real As Float) As Boolean

    Dim ii As Integer, puedo As Boolean = False

    Select Case gcd.CurrDrawing.arrEntities[i].Gender

        Case Else

            ' Si tengo un bounding poligon, entonces verifico que alguna linea lo cruce
            puedo = puntos.IsPoligonCrossingRect(gcd.CurrDrawing.arrEntities[i].Polygon, X1real, Y1real, X2real, Y2real)

            For Ii = 0 To gcd.CurrDrawing.arrEntities[i].p.max Step 2
                If ii + 1 > gcd.CurrDrawing.arrEntities[i].p.max Then Break
                If ii / 2 > gcd.CurrDrawing.arrEntities[i].Psel.Max Then Break
                If (gcd.CurrDrawing.arrEntities[i].p[iI] >= X1real And gcd.CurrDrawing.arrEntities[i].p[Ii] <= X2real) And (gcd.CurrDrawing.arrEntities[i].p[iI + 1] >= Y1real And gcd.CurrDrawing.arrEntities[i].p[iI + 1] <= Y2real) Then
                    gcd.CurrDrawing.arrEntities[i].PSel[iI / 2] = True
                    puedo = True
                End If
            Next

            If puedo Then

                Return True
            Else
                Return False
            End If

    End Select

End

' Public Function GetParentBlock(iEntity As Integer) As Integer
'
'     Dim iParent As Integer
'
'     iParent = iEntity
'     Do
'
'         If gcd.CurrDrawing.arrEntities[iParent].iInsert >= 0 Then
'             If iParent = gcd.CurrDrawing.arrEntities[iParent].iInsert Then Break
'             iParent = gcd.CurrDrawing.arrEntities[iParent].iInsert
'         Else
'             Break
'         End If
'
'     Loop
'
'     Return iParent
'
' End

'' Imports data from a collection to an entity. True if the entity is handled by GauchoCAD at this version,
'' False if entity couldn't be created for some reason.
Public Function DXFImportToEntity(c As Collection, e As Entity, Optional IsDummy As Boolean = False) As Boolean

    Dim clsHandler As Object
    Dim sClave As New String[]
    Dim sValue As New String[]
    Dim lpValue, lpclave As String
    Dim i As Integer
    Dim GotEntity As Boolean

    ' If Not c.Exist("entity") Then Return False
    ' If Not c "entity") Then Return False
    If IsDummy Then
        clsHandler = cadDummy
    Else
        clsHandler = Object.New("cad" & c[dxf.codEntity])  ' obtenemos el tipo de entidad y buscamos su clase. Si no manjemos esa entidad, esto de error.

    End If
    'GotEntity = True

    'Finally

    'If Not GotEntity Then Return False

    For Each lpValue In c
        lpclave = c.Key
        I = InStr(lpclave, "_")
        If i > 0 Then lpclave = Left(lpclave, i - 1)
        sClave.Add(lpclave)           ' el codigo es el tipo de variable
        sValue.Add(lpValue)

    Next
    e.ClassHandler = clsHandler
    e.Gender = clsHandler.Gender

    ' llenamos Common data:
    e.pLayer = gcd.GetLayer(c[dxf.codLayer])
    e.Handle = c[dxf.codHandle]
    e.HandleOwner = c[dxf.codHandleOwner]
    Try e.colour = c[dxf.codColor]            ' no es obligatorio
    Try e.LineWidth = c[dxf.codLWht] / 100    ' por eso el try
    If e.LineWidth < 1 Then e.LineWidth = 1
    If c.Exist(dxf.codLType) Then e.LineType = gcd.CurrDrawing.arrLTYpes[gcd.FindLtIndex(c[dxf.codLType])] Else e.LineType = gcd.CurrDrawing.arrLTYpes.First
    If clsHandler.ImportDXF(e, sClave, sValue) Then

        e.ClassHandler.Finish(e)

        Return True

    Else

        Return False

    End If

    ' Catch
    'e.ClassHandler = cadDummy
    Return False

End

Public Function GetEntityIndex(dDrawing As ClsDrawing, sHandle As String, Optional iStart As Integer = 0) As Integer

    Dim i As Integer

    For i = iStart To dDrawing.arrEntities.Max

        If dDrawing.arrEntities[i].Handle = sHandle Then Return i

    Next

    Return -1           ' no hay handle asociada a esa entidad

End

Public Sub DXFExportCommonCol(e As Entity, ByRef cExported As Collection)

    cExported.Add(UCase(e.Gender), dxf.codEntity)
    cExported.add(e.Handle, dxf.codHandle)
    cExported.add(e.HandleOwner, dxf.codHandleOwner)
    cExported.Add("AcDbEntity", "100_1")
    cExported.Add(e.pLayer.Name, dxf.codLayer)
    Try cExported.Add(e.LineType.Name, dxf.codLType)
    cExported.Add(e.colour, dxf.codColor)
    cExported.Add(CStr(e.LineWidth), dxf.codLWht)

End

' importing

Public Function AddLine(obxContainer As Entity[], Points As Float[], Optional colour As Integer = 0, LineWidth As Float = 1, Linetype As String, pLayer As Layer, Block As String) As Boolean

    ' points are in x,y,x,y,x,y....
    Dim oEntity As New Entity

    oEntity.ClassHandler = cadLine
    oEntity.Gender = oEntity.ClassHandler.gender
    oEntity.P.insert(points)                    ' recibimos los dos vertices de la linea x1,y1,x2,y2
    oEntity.pLayer = pLayer
    oEntity.colour = colour
    oEntity.LineWidth = 1 'LineWidth               ' datos CAD

    obxContainer.Add(oEntity)
    oEntity.ClassHandler.finish(oEntity)
    oEntity = Null                  ' free entity

End

Public Function AddPoint(obxContainer As Entity[], Points As Float[], Optional colour As Integer = 0, LineWidth As Float = 1, Linetype As String, pLayer As Layer, Block As String) As Boolean

    ' points are in x,y,x,y,x,y....
    Dim oEntity As New Entity

    oEntity.ClassHandler = cadPoint
    oEntity.Gender = oEntity.ClassHandler.gender
    oEntity.P.insert(points)                    ' recibimos los dos vertices de la linea x1,y1,x2,y2
    oEntity.pLayer = pLayer
    oEntity.colour = colour
    oEntity.LineWidth = 1 'LineWidth               ' datos CAD

    obxContainer.Add(oEntity)
    oEntity.ClassHandler.finish(oEntity)
    oEntity = Null                  ' free entity

End

Public Function AddPolyLine(obxContainer As Entity[], Points As Float[], Optional iClosed As Integer = 0, Optional colour As Integer = 0, LineWidth As Float = 1, Optional Linetye As String, pLayer As Layer, Block As String) As Boolean

    ' points are in x,y,x,y,x,y....

    Dim oEntity As New Entity

    oEntity.ClassHandler = cadLWPolyline
    oEntity.Gender = oEntity.ClassHandler.gender
    oEntity.P.insert(points)                    ' recibimos los dos vertices de la linea x1,y1,x2,y2
    oEntity.fParam.Add(iClosed)                 ' cerrada o abierta
    oEntity.pLayer = pLayer
    oEntity.colour = colour
    oEntity.LineWidth = 1 ' LineWidth               ' datos CAD

    obxContainer.Add(oEntity)
    oEntity.ClassHandler.finish(oEntity)
    oEntity = Null                  ' free entity

End

Public Function AddSolid(obxContainer As Entity[], Points As Float[], Optional colour As Integer = 0, LineWidth As Float = 1, Optional Linetye As String, pLayer As Layer, Block As String) As Boolean

    ' points are in x,y,x,y,x,y....
    ' points are in x,y,x,y,x,y....
    Dim oEntity As New Entity

    oEntity.ClassHandler = cadSolid             ' create the new entity of proper class
    oEntity.Gender = oEntity.ClassHandler.gender
    oEntity.P.insert(points)                    ' recibimos los dos vertices de la linea x1,y1,x2,y2

    oEntity.pLayer = pLayer
    oEntity.colour = colour
    oEntity.LineWidth = LineWidth               ' datos CAD

    obxContainer.Add(oEntity)
    oEntity.ClassHandler.finish(oEntity)
    oEntity = Null                  ' free entity

End

Public Function AddSPLine(obxContainer As Entity[], Points As Float[], Optional iClosed As Integer = 0, Optional colour As Integer = 0, LineWidth As Float = 1, Optional Linetye As String, pLayer As Layer, Block As String) As Boolean

    ' points are in x,y,x,y,x,y....
    Dim oEntity As New Entity

    oEntity.ClassHandler = cadSPLine
    oEntity.Gender = oEntity.ClassHandler.gender
    oEntity.P.insert(points)                    ' recibimos los dos vertices de la linea x1,y1,x2,y2
    oEntity.fParam.Add(iClosed)                 ' cerrada o abierta
    oEntity.pLayer = pLayer
    oEntity.colour = colour
    oEntity.LineWidth = LineWidth               ' datos CAD

    obxContainer.Add(oEntity)
    oEntity.ClassHandler.finish(oEntity)
    oEntity = Null                  ' free entity

End

Public Function AddCircle(obxContainer As Entity[], Points As Float[], radious As Float, Optional colour As Integer = 0, LineWidth As Float = 1, Optional Linetye As String, pLayer As Layer, Block As String) As Boolean

    ' points are in x,y,x,y,x,y....
    Dim oEntity As New Entity

    oEntity.ClassHandler = cadCircle
    oEntity.Gender = oEntity.ClassHandler.gender
    oEntity.P.insert(points)                    ' centro x1,y1
    oEntity.fParam.Add(radious)                 ' radio
    oEntity.pLayer = pLayer
    oEntity.colour = colour
    oEntity.LineWidth = LineWidth               ' datos CAD

    obxContainer.Add(oEntity)
    oEntity.ClassHandler.finish(oEntity)
    oEntity = Null                  ' free entity

End

Public Function AddArc(obxContainer As Entity[], Points As Float[], r As Float, angle1 As Float, angle2 As Float, Optional colour As Integer = 0, LineWidth As Float = 1, Optional Linetye As String, pLayer As Layer, Block As String) As Boolean

    ' points are in x,y,x,y,x,y....
    Dim oEntity As New Entity

    oEntity.ClassHandler = cadArc
    oEntity.Gender = oEntity.ClassHandler.gender
    oEntity.P.insert(points)                    ' centro x1,y1
    oEntity.fParam.Add(r)                      ' radio
    oEntity.fParam.Add(angle1)                   ' angulo
    oEntity.fParam.Add(angle2)                   ' angulo
    oEntity.pLayer = pLayer
    oEntity.colour = colour
    oEntity.LineWidth = LineWidth               ' datos CAD

    obxContainer.Add(oEntity)
    oEntity.ClassHandler.finish(oEntity)
    oEntity = Null                  ' free entity

End

Public Function AddEllipse(obxContainer As Entity[], Points As Float[], r As Float, angle1 As Float, angle2 As Float, Optional colour As Integer = 0, LineWidth As Float = 1, Optional Linetye As String, pLayer As Layer, Block As String) As Boolean

    ' points are in x,y,x,y,x,y....
    Dim oEntity As New Entity

    oEntity.ClassHandler = cadEllipse
    oEntity.Gender = oEntity.ClassHandler.gender
    oEntity.P.insert(points)                    ' centro x1,y1
    oEntity.p[2] += oEntity.p[0]                ' un pequeo truco porque gaucho usa los puntos de manera diferente a DXF
    oEntity.p[3] += oEntity.p[1]
    oEntity.fParam.Add(r)                      ' ratio minor/major
    oEntity.fParam.Add(angle1 * 180 / Pi)     ' start angle
    oEntity.fParam.Add(angle2 * 180 / Pi)      ' end angle
    oEntity.pLayer = pLayer
    oEntity.colour = colour
    oEntity.LineWidth = LineWidth               ' datos CAD

    obxContainer.Add(oEntity)
    oEntity.ClassHandler.finish(oEntity)
    oEntity = Null                  ' free entity

End

Public Function AddText(obxContainer As Entity[], Points As Float[], angle As Float, height As Float, _Text As String, Optional colour As Integer = Color.Blue, LineWidth As Float = 1, Optional Linetye As String, pLayer As Layer, Block As String) As Boolean

    Dim oEntity As New Entity

    oEntity.ClassHandler = cadText
    oEntity.Gender = oEntity.ClassHandler.gender
    oEntity.P.insert(points)                    ' recibimos position x1,y1
    oEntity.fParam.Add(angle)                   ' grados
    oEntity.fParam.Add(height)                  ' alto letras
    oEntity.stringdata.Add(_text)                  ' el texto
    oEntity.pLayer = pLayer
    oEntity.colour = colour
    oEntity.LineWidth = LineWidth               ' datos CAD

    obxContainer.Add(oEntity)
    oEntity.ClassHandler.finish(oEntity)
    oEntity = Null                  ' free entity

End

Public Function AddMText(obxContainer As Entity[], Points As Float[], angle As Float, height As Float, _Text As String, Optional colour As Integer = Color.Blue, LineWidth As Float = 1, Optional Linetye As String, pLayer As Layer, Block As String) As Boolean

    Dim oEntity As New Entity

    oEntity.ClassHandler = cadMText
    oEntity.Gender = oEntity.ClassHandler.gender
    setEntity(oentity)
    oEntity.P.insert(points)                    ' recibimos position x1,y1 pero tal vez venga un recuadro
    oEntity.fParam[cadMText.ipaTextAngle] = angle                  ' GRADOS
    oEntity.fParam[cadMText.ipaTextHeight] = height                  ' alto letras
    oEntity.stringdata[cadMText.sdaText] = _text                  ' el texto
    oEntity.pLayer = pLayer
    oEntity.colour = colour
    oEntity.LineWidth = LineWidth               ' datos CAD

    obxContainer.Add(oEntity)
    oEntity.ClassHandler.finish(oEntity)
    oEntity = Null                  ' free entity

End

Public Function AddCurve(obxContainer As Entity[], Points As Float[], Optional colour As Integer = 0, LineWidth As Float = 1, Optional Linetye As String, pLayer As Layer, Block As String) As Boolean

    ' points are in x,y,x,y,x,y....
    Dim oEntity As New Entity

    oEntity.Gender = oEntity.ClassHandler.gender

End

Public Function AddInsert(obxContainer As Entity[], Points As Float[], scaleX As Float, scaleY As Float, angulo As Float, Optional colour As Integer = Color.Blue, Optional Linetye As String, pLayer As Layer, Block As String) As Boolean

    Dim oEntity As New Entity

    oEntity.ClassHandler = cadInsert
    oEntity.Gender = oEntity.ClassHandler.gender
    oEntity.P.insert(points)                    ' recibimos position x1,y1
    oEntity.fParam.Add(scaleX)
    oEntity.fParam.Add(scaleY)
    oEntity.fParam.Add(angulo)                  ' GRADOS
    oEntity.pLayer = pLayer
    oEntity.colour = colour

    obxContainer.Add(oEntity)
    oEntity.ClassHandler.finish(oEntity)

    oEntity = Null                  ' free entity

End

' Public Function AddBlock(Points As Float[], Block As String) As Entity[]
'
'   Dim newBlock As New ArrBlockSt
'
'   newBlock.entities = New Entity[]
'   newBlock.name = block
'   newBlock.x = Points[0]
'   newBlock.y = Points[1]
'   gcd.CurrDrawing.arrBlocks.Add(newBlock)
'
'   Return newBlock.entities
'
' End
