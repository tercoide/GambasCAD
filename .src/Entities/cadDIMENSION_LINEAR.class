' Gambas class file

' GambasCAD
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
Create Static
Inherits CadDimension

Public Const Gender As String = "Dimension_Linear"
Public Const DrawingOrder As Integer = 100 ' 1 a 32.724 esto debe Drawse primero y ser sobreescrito por el resto
Public Const PointsToDraw As Integer = 1             ' minimal point requered for drawing something usefull
Public Const HelperTrabajo As String = ("Insert a linear acotation")
Public Const ParamType As String = "PPP"
Public Const ParamHelper As String = "Start point;End point;extension"
Public Const ParamDefault As String = " "

Public Function ImportDXF(e As Entity, sClaves As String[], sValues As String[]) As Boolean

    Dim i As Integer
    Dim AfterSubclassmarker As Boolean
    ' ' revisamos lo que viene del importador comun
    e.P[4] = e.P[0]
    e.P[5] = e.P[1]
    '
    e.P[6] = e.P[2]
    e.P[7] = e.P[3]

    For i = 0 To sClaves.Max
        If sClaves[i] = "100" And sValues[i] = "AcDbAlignedDimension" Then AfterSubclassmarker = True
        If AfterSubclassmarker Then ' los siguientes codigos
            If sClaves[i] = "12" Then e.P[8] = CFloat(sValues[i])
            If sClaves[i] = "22" Then e.P[9] = CFloat(sValues[i])

            'If sClaves[i] = "13" Then e.P[0] = CFloat(sValues[i])
            'If sClaves[i] = "23" Then e.P[1] = CFloat(sValues[i])

            If sClaves[i] = "14" Then e.P[2] = CFloat(sValues[i])
            If sClaves[i] = "24" Then e.P[3] = CFloat(sValues[i])

            ' este parametro determina el angulo de la dimension, y no los puntos
            If sClaves[i] = "50" Then e.iParam[cadDimension.iiiMode] = 1000 * CFloat(sValues[i])

            If sClaves[i] = "52" Then e.fParam[cadDimension.ipaObliqueExtension] = CFloat(sValues[i])

        End If

    Next

    ' Equivalencias
    ' DXF       Entity P[]
    ' 10-20     4-5
    ' 11-21     6-7
    ' 12-22     no se usa
    ' 13-23     0-1
    ' 14-24     2-3

    e.fParam[cadDimension.ipaExtension] = -puntos.distancia(Me.pointDefPoint0.x, Me.pointDefPoint0.y, Me.pointDefPoint2.x, Me.pointDefPoint2.y)

    ' TODO: cuando este terminada la entidad, sacar eso
    ' tengo q presuponer que las escalas son = 1
    e.fParam[Me.ipaEscX] = 1    ' esc X
    e.fParam[Me.ipaEscY] = 1    ' esc Y
    e.fParam[Me.ipaEscZ] = 1    ' esc Z
    e.pBlock.AbsoluteCoords = True

    ' y poner esto
    ' e.pBlock = Me.ReBuildBlock(e)

    Return True

    ' catch

    Return False

End

Public Function NewParameter(eBuild As Entity, vParam As Variant[], Optional Definitive As Boolean = False) As Boolean

    ' la linea solo recibe puntos

    If vParam[0] <> "point" Then Return False

    If Me.StepsDone = 0 Then
        Me.DimType = gcd.dimAligned
        ' supongo que marca el punto de derecha a izq
        ' el primero es P3 o P67
        Try eBuild.p[0] = vParam[1]
        Try eBuild.p[1] = vParam[2]
        eBuild.p[2] = eBuild.P[0]
        eBuild.p[3] = eBuild.P[1]
        eBuild.p[4] = eBuild.p[2]
        eBuild.p[5] = eBuild.P[3]
        ' Me.pointDefPoint2.x = Me.pointDefPoint1.x
        ' Me.pointDefPoint2.y = Me.pointDefPoint1.y
        If definitive Then Return True
    Else If Me.StepsDone = 1 Then

        Try eBuild.p[2] = vParam[1]
        Try eBuild.p[3] = vParam[2]
        eBuild.p[4] = eBuild.p[2]
        eBuild.p[5] = eBuild.P[3]

        ' Try Me.pointDefPoint2.x = vParam[1]
        ' Try Me.pointDefPoint2.y = vParam[2]
        eBuild.pBlock = ReBuildBlock(eBuild)
        If definitive Then Return True
    Else If Me.StepsDone = 2 Then   ' el tercer punto sera la posicion del texto

        ' return the angle from horizontal to us
        'eBuild.fParam[Me.ipaExtension] = -puntos.PointToLineDistance([vParam[1], vParam[2]], [eBuild.p[0], eBuild.p[1], eBuild.p[2], eBuild.p[3]]) ' / puntos.distancia(eBuild.p[0], eBuild.p[1], eBuild.p[2], eBuild.p[3]
        Try eBuild.p[4] = vParam[1]
        Try eBuild.p[5] = vParam[2]

        ' Try Me.pointDefPoint0.x = vParam[1]
        ' Try Me.pointDefPoint0.y = vParam[2]
        eBuild.pBlock = ReBuildBlock(eBuild)
        If definitive Then
            'Stop
            Return True
        End If
    Endif

End

Public Sub ReBuildBlock(E As Entity) As Block

    ' esta rutina no sabe si el bloque a reconstruir es desde EntityBuilder o desde
    ' DXF o JSON

    Dim d As Float, flxTextExt As Float[]
    Dim fRotXY As Float[]

    Dim newBlock As New Block
    Dim f1, f2 As New Float[]
    Dim a1 As Float
    Dim sDim As String
    Dim invertida As Integer = 1

    newBlock.entities = New Collection

    ' ' verifico el armado
    ' If E.P[2] < E.P[0] Then
    '   ' Swap elem.P[2], elem.P[0]
    '   ' Swap elem.p[3], elem.P[1]
    '   invertida = -1
    '
    ' Endif
    '
    ' If E.P[2] = E.P[0] Then
    '   If E.P[1] > E.P[3] Then
    '     ' Swap elem.P[2], elem.P[0]
    '     ' Swap elem.p[3], elem.P[1]
    '     invertida = -1
    '
    '   End If
    ' Endif

    ' para definir este bloque necesito 6 entidades
    Dim eLineaPpal As Entity
    Dim eOblique1 As Entity       ' tambien pueden ser flechas Solid
    Dim eOblique2 As Entity
    Dim eExtension1 As Entity
    Dim eExtension2 As Entity
    Dim eText As Entity
    Dim ePoint1 As Entity
    Dim ePoint2 As Entity

    ' vemos los estilos
    If E.fParam[Me.ipaStyleTextHeigth] > 0 Then Me.DimTextHeight = E.fParam[Me.ipaStyleTextHeigth] Else Me.DimTextHeight = E.pStyle.DIMTXT
    If E.fParam[Me.ipaStyleArrowSize] > 0 Then Me.DimArrowSize = E.fParam[Me.ipaStyleArrowSize] Else Me.DimArrowSize = E.pStyle.DIMASZ
    Me.DimArrowWidth = Me.DimArrowSize / 3

    'newBlock.AbsoluteCoords = True

    ' linea principal
    eLineaPpal = cadLine.NewEntity([e.P[0], e.P[1], 0.0, 0.0])  ' el 2do punto lo tengo que determinar, el primero esta en la posicion final

    ' lineas de demarcacion
    eExtension1 = cadLine.NewEntity([0, Me.DimExtension, 0, -Me.DimExtension])
    eExtension2 = cadLine.NewEntity([0, Me.DimExtension, 0, -Me.DimExtension])

    ' puntos base, ya en las ubicaciones finales (coinciden con los clicks)
    ePoint1 = cadPoint.NewEntity([e.P[6], e.P[7]])
    ePoint2 = cadPoint.NewEntity([e.P[8], e.P[9]])

    ' flechas
    eOblique1 = cadSolid.NewEntity([0, 0, Me.DimArrowSize, Me.DimArrowWidth, Me.DimArrowSize, -Me.DimArrowWidth, 0, 0])
    eOblique2 = cadSolid.NewEntity([0, 0, -Me.DimArrowSize, Me.DimArrowWidth, -Me.DimArrowSize, -Me.DimArrowWidth, 0, 0])

    ' texto
    eText = cadMText.NewEntity([e.P[2], e.P[3]])  ' si leo un archivo, esta es la posicion final
    eText.fParam[cadMText.ipaAttchmPoint] = 8

    ' agrego todo al bloque
    newBlock.entities.Add(eLineaPpal, gcd.NewHandle())
    newBlock.entities.Add(eExtension1, gcd.NewHandle())
    newBlock.entities.Add(eExtension2, gcd.NewHandle())
    newBlock.entities.Add(ePoint1, gcd.NewHandle())
    newBlock.entities.Add(ePoint2, gcd.NewHandle())
    newBlock.entities.Add(eText, gcd.NewHandle())

    ' -> el bloque
    E.fParam[cadInsert.ipaEscX] = 1      ' ScaleX del inserto
    E.fParam[cadInsert.ipaEscY] = 1      ' ScaleY del inserto
    E.fParam[cadInsert.ipaEscZ] = 1      ' ScaleY del inserto
    E.Visible = True

    E.fParam[cadInsert.ipaRotacion] = CFloat(E.iParam[Me.iiiMode]) / 1000

    ' el largo de la linea principal viene dado por la distancia entre ambos puntos
    ' pero como es una dimension alineada, se multiplica por la diferencia de angulos
    ' entre P1-P2 y el angulo de la dimension a medir
    a1 = Ang(E.p[2] - E.P[0], E.p[3] - E.P[1]) * 180 / Pi
    a1 -= E.fParam[cadInsert.ipaRotacion]  ' esto viene en grados *1000
    a1 = Abs(a1) / 180 * Pi
    d = Cos(a1) * puntos.distancia(E.P[0], E.P[1], E.P[2], E.P[3])

    ' ' verifico el armado
    ' If E.P[2] < E.P[0] Then
    '   ' Swap elem.P[2], elem.P[0]
    '   ' Swap elem.p[3], elem.P[1]
    '   invertida = -1
    '
    ' Endif
    '
    ' If E.P[2] = E.P[0] Then
    '   If E.P[1] > E.P[3] Then
    '     ' Swap elem.P[2], elem.P[0]
    '     ' Swap elem.p[3], elem.P[1]
    '     invertida = -1
    '
    '   End If
    ' Endif
    '
    ' la primer entidad del bloque es la linea principal
    eLineaPpal.P[2] = d '* invertida           ' X1
    eLineaPpal.P[3] = 0           ' Y1

    ePoint2.P[0] = d '* invertida

    ' la segunda es la primer linea de demarcacion (sin cambios)
    ' eExtension1.P[0] = 0           ' X0
    ' eExtension1.P[1] = 0           ' Y0
    '
    ' eExtension1.P[2] = 0           ' X1
    ' eExtension1.P[3] = 0           ' Y1

    ' la tercera es la segunda linea de demarcacion
    eExtension2.P[0] = d '* invertida           ' X0

    eExtension2.P[2] = d '* invertida          ' X1

    E.fParam[cadDimension.ipaRealMeasure] = Abs(d)
    If E.StringData[Me.sdaTextOverride] <> "" Then
        sDim = E.StringData[Me.sdaTextOverride]
    Else
        sDim = Format(Abs(d), Me.DimFormat)
    Endif
    ' el texto
    eText.StringData[cadMText.sdaText] = "\\A1;" & sDim
    flxTextExt = glPlus.TextExtends(sDim, 0, 0, eText.fParam[cadMText.ipaTextHeight])

    ' la cuarta y quinta son las flechas , tengo que verificar si entran, o el texto
    If flxTextExt[2] * 1.1 > Abs(d) Then                      ' no entra

        eOblique1.P[0] = d '* invertida           ' X0
        eOblique1.P[2] = (Me.DimArrowSize + d) '* invertida            ' X0
        eOblique1.P[4] = (Me.DimArrowSize + d) '* invertida           ' X0
        eOblique1.P[6] = d '* invertida    ' X0

        eOblique2.P[0] = 0           ' X0
        eOblique2.P[2] = -Me.DimArrowSize '* invertida
        eOblique2.P[4] = -Me.DimArrowSize '* invertida
        eOblique2.P[6] = 0           ' X0

        ' el texto va afuera
        eText.P[0] = (d + Me.DimArrowSize / 2) '* invertida
        eText.P[1] = Me.DimArrowWidth

    Else                                                                ' entra
        eOblique1.P[0] = 0 * invertida ' X0
        eOblique1.P[2] = Me.DimArrowSize * invertida
        eOblique1.P[4] = Me.DimArrowSize * invertida
        eOblique1.P[6] = 0 * invertida ' X0

        eOblique2.P[0] = d '* invertida ' X0
        eOblique2.P[2] = -Me.DimArrowSize * invertida + d            ' X0
        eOblique2.P[4] = -Me.DimArrowSize * invertida + d            ' X0
        eOblique2.P[6] = d '* invertida            ' X0

        ' el texto va adentro
        eText.P[0] = (d / 2 - flxTextExt[2] / 2) '* invertida
        eText.P[1] = Me.DimArrowWidth

    End If

    ' En esta parte ubico las cosas segun la extension, o sea la distancia a los puntos de demarcacion
    E.fParam[Me.ipaExtension] = puntos.PointToLineDistance([E.P[4], E.P[5]], [E.p[0], E.p[1], E.p[2], E.p[3]]) ' / puntos.distancia(eBuild.p[0],
    'Me.extension = puntos.distancia(elem.P[2], elem.P[3], elem.P[4], elem.P[5])
    Me.extension = E.fParam[cadDimension.ipaExtension]
    Me.extension *= Sin(puntos.Angle2([E.P[2] - E.P[0], E.P[3] - E.P[1]], [E.P[4] - E.P[2], E.P[5] - E.P[3]]))

    ' linea principal
    eLineaPpal.P[1] = Me.extension           ' Y0
    eLineaPpal.P[3] = Me.extension           ' Y1

    ' linea de demarcacion
    eExtension1.P[1] = Me.DimExtension + Me.extension           ' Y0
    eExtension1.P[3] = -Me.DimExtension + Me.extension           ' Y1

    ' segunda linea de demarcacion
    eExtension2.P[1] = Me.DimExtension + Me.extension           ' Y0
    eExtension2.P[3] = -Me.DimExtension + Me.extension           ' Y1

    ' texto
    eText.P[1] = Me.DimArrowWidth + Me.extension

    ' flechas
    eOblique1.P[1] = Me.extension           ' X0
    eOblique1.P[3] = Me.extension + Me.DimArrowWidth
    eOblique1.P[5] = Me.extension - Me.DimArrowWidth
    eOblique1.P[7] = Me.extension           ' X0

    eOblique2.P[1] = Me.extension           ' X0
    eOblique2.P[3] = Me.extension + Me.DimArrowWidth
    eOblique2.P[5] = Me.extension - Me.DimArrowWidth
    eOblique2.P[7] = Me.extension           ' X0

    ' End If

    ' ' Traslado todo
    ' For Each e As Entity In newBlock.entities
    '     e.classhandler.translate(dX, dY)
    ' Next

    Return newBlock

End
