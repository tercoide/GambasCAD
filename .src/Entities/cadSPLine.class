' Gambas class file

' Represents a poli line
' Element maintained by Terco

' Usando partes de la informacion de
' http://devmag.org.za/2011/04/05/bzier-curves-a-tutorial/

Create Static

Public Const Gender As String = "SPLine"
Public Const PointsToDraw As Integer = 0             ' minimal point requered for drawing something usefull
Public Const HelperTrabajo As String = "SPLine"
Public Const ParamType As String = "P+"                             ' that is Point, Point, Float could be Color Text, etc
Public Const ParamHelper As String = ("Next Point")      ' a little text that is shown at the prompt waiting for user input during build
Public Const ParamDefault As String = "Close/Undo"
Public Const GAMBASCADENTITY As String = "EntityBase"
Public Const USEWITH As String = "EntityBuilder"
Public Const DrawingOrder As Integer = 0        ' 1 = draws first
Public Const OrthogonalIgnored As Boolean = False
Public Const OrthogonalForced As Boolean = False
Public Const StretchAble As Boolean = True           ' Si lo puedo deformar

' otras const
Public Const TypeControls As Integer = 0
Public Const TypeTangent As Integer = 1

Public Selected As Boolean

Public DrawAble As Boolean = False          ' True si durante la construccion ya tiene suficientes elementos para poder hacer una representacion digna
Public Visible As Boolean = True            ' si esta entidad puede ser mostrada independientmente
Public Finished As Boolean = False          ' colocar en true cuando se llegue a completar
Public StepsDone As Integer                 ' esto lo cambia cls ElementBuilder durante la construccion
Public drawingPoints As New Float[]

Public numDrawingPoints As Integer = 100

' DXF Read/Export

Public Const DXF_Reading As Boolean = False
Public Const DXF_Export As Boolean = False

' fParam helpers
Public Const TotalParams As Integer = 10
Public Const ipaDegree As Integer = 0
Public Const ipaTotalKnots As Integer = 1
Public Const ipaTotalControlPoints As Integer = 2
Public Const ipaTotalFitPoints As Integer = 3
Public Const ipaKnotTolerance As Integer = 4
Public Const ipaControlTolerance As Integer = 5
Public Const ipaFitTolerance As Integer = 6
Public Const ipaFlag As Integer = 7
Public Const ipaTang1 As Integer = 8
Public Const ipaTang2 As Integer = 9

' nuevas mar/21
Public g_num_cvs As Integer
Public g_degree As Integer
Public g_order As Integer
Public LOD As Integer = 200

Public g_points As New Float[]
Public Knots As New Float[]

'' Creates a new LWpolyline entity and prepares arrays
Public Function NewEntity() As Entity

    Dim e As New Entity

    e.Gender = Me.Gender
    e.ClassHandler = Me
    e.fParam.Insert([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
    e.P.Insert([0, 0])

    ' this may fails on some scopes, but we should Try
    Try e.pLayer = gcd.CurrDrawing.CurrLayer
    Try e.colour = gcd.CurrDrawing.CurrColor
    Try e.LineType = gcd.CurrDrawing.CurrLineType
    Try e.LineWidth = gcd.CurrDrawing.CurrLineWt

    Return e

End

Public Function NewParameter(eBuild As Entity, vParam As Variant[], Optional Definitive As Boolean = False) As Boolean

    Dim fKnots As New Float[]

    Dim i As Integer

    If eBuild.fParam.Count = 0 Then

    Endif
    eBuild.fParam[Me.ipaFlag] = 8
    ' 70' Spline flag(bit coded):
    ' 1 = Closed spline
    ' 2 = Periodic spline
    ' 4 = Rational spline
    ' 8 = Planar
    ' 16 = Linear(planar bit Is Also set)
    eBuild.fParam[Me.ipaDegree] = 2 'quadrtic; 3 = cubic
    eBuild.fParam[Me.ipaKnotTolerance] = 0.0000001
    eBuild.fParam[Me.ipaControlTolerance] = 0.0000001
    eBuild.fParam[Me.ipaFitTolerance] = 0.0000000001

    If vParam[0] = "point" Then
        eBuild.DrawAble = True

        eBuild.P[eBuild.P.Max - 1] = vParam[1]
        eBuild.P[eBuild.P.Max] = vParam[2]
        GoSub DoKnots
        If definitive Then

            eBuild.P.Insert(eBuild.P.Copy(eBuild.P.Max - 1, 2))
            GoSub DoKnots
            Return True
        End If
    Else If vParam[0] = "close" Then
        If eBuild.P.Count > 4 Then eBuild.P.Remove(eBuild.P.Max - 1, 2)

        Return True

    Else If vParam[0] = "undo" Then
        If eBuild.P.Count > 4 Then
            eBuild.P.Remove(eBuild.P.Max - 1, 2)
            GoSub DoKnots
        End If

        Return True

    Endif

DoKnots:

    fKnots.Clear

    fKnots.Add(0)
    fKnots.Add(0)
    fKnots.Add(0)

    If eBuild.P.Count / 2 > 3 Then
        For i = 1 To eBuild.P.count / 2 - 3
            fKnots.Add(i / ((eBuild.P.count / 2 - 2)))
        Next
    End If
    fKnots.Add(1)
    fKnots.Add(1)
    fKnots.Add(1)

    eBuild.fParam.Remove(Me.TotalParams, eBuild.fParam.Count - Me.TotalParams)
    eBuild.fParam.Insert(fKnots.Copy(), Me.TotalParams)

    eBuild.fParam[Me.ipaTotalKnots] = fKnots.Count

    Return

End

Public Sub Translate(e As Entity, dX As Float, dY As Float, Optional OnlySelected As Boolean = False)

    Dim i As Integer

    If OnlySelected Then

        For i = 0 To e.Psel.Max
            If e.Psel[i] Then

                e.P[i * 2] += dx
                e.P[i * 2 + 1] += dy

            Endif
        Next

    Else

        puntos.Translate(e.p, dx, dy)
    Endif

End

Public Sub Rotate(e As Entity, radians As Float)

    puntos.Rotate(e.P, radians)

End

Public Sub Scale(e As Entity, sX As Float, sY As Float)

    Dim i As Integer

    For i = 0 To e.p.max Step 2

        e.P[i] = e.P[i] * sX
        e.P[i + 1] = e.P[i + 1] * sY

    Next

End

' Public Sub Draw(oE As Entity)
'
'     If Not oE.Visible Then Return
'
'     drawingPoints.Clear
'
'     'oe.P.Clear
'     'oe.P.Insert([10, 10, 70, 310, 210, 210, 210, 10])
'     oE.ColorToPaint = gcd.GetGBColor(oE.colour, oE.pLayer)
'     If oe.fParam.Count < Me.TotalParams Then oe.fParam.Resize(Me.TotalParams)
'     oe.fParam[Me.ipaDegree] = 2
'     ' La Spline de grado 2 es la que va a traves de Fit Points
'     If oe.fParam[Me.ipaDegree] = 2 Then
'         calculateDrawingPoints(oe.p)
'         'SplineTroughFitPoints(oe.p)
'     Else  ' a traves de control points (no los toca)
'
'         'calculateDrawingPointsWithTangents2(oe.p, oe.fParam[me.ipaTang1] = 1, oe.fParam[me.ipaTang2] = 1)
'
'         SplineTroughControlPoints(oe.p, oe.fParam[Me.ipaTang1] = 1, oe.fParam[Me.ipaTang2] = 1)
'     Endif
'
'     GLplus.PolyLines(drawingPoints, oE.ColorToPaint, oE.LineWidth, oE.LineType.index)
'
' End

'' A fat version of the entity
Public Sub DrawSelected(oE As Entity)

    GLplus.PolyLines(oE.PolyLine, gcd.flgWindowBackColor, oE.LineWidth, gcd.stiDashed)
    GLplus.PolyLines(oE.PolyLine, gcd.ColorForSelected, oE.LineWidth, oE.LineType.index)

End

'' A fat version of the line
Public Sub DrawRemark(oE As Entity)

    If Not oE.Visible Then Return

    '  GLplus.PolyLines(oE.p, gcd.flgWindowBackColor, oE.LineWidth, gcd.stiDashed)
    '  GLplus.PolyLines(oE.p, oE.ColorToPaint, oE.LineWidth + 2, oE.LineType)
    If oe.Selected Then
        GLplus.PolyLines(oE.PolyLine, gcd.flgWindowBackColor, oE.LineWidth + 2, gcd.stiDashed)
        GLplus.PolyLines(oE.PolyLine, gcd.ColorForSelected, oE.LineWidth + 2, oe.linetype.index)
    Else
        GLplus.PolyLines(oE.PolyLine, gcd.flgWindowBackColor, oE.LineWidth, gcd.stiDashed)
        GLplus.PolyLines(oE.PolyLine, oE.ColorToPaint, oE.LineWidth + 2, oe.linetype.index)
    Endif

End

Public Sub Draw2(oE As Entity)

End
'' Creo los puntos de interes
'' Build point of interest

Public Function BuildPOI(oE As Entity, Optional arrIndex As Integer = -1) As Integer

    cadLWPolyline.BuildPOI(oe)

End

' This function will return False if the element couldn't be created for some reason: bad or incomple user input
' True means all is good, False will instruct the clsEntityBuilder to delete it
Public Sub Finish(oE As Entity) As Boolean

    'Print "Finish en EntityBase"
    'CreatePolygon(oe)
    '  BuildPOI(oe)

    ' busco el tipo de linea, si hace falta

    ' tareas finales de armado del objeto

    oE.psel.resize(oE.p.count / 2)

    oE.DrawAble = True
    oE.Selected = False
    oE.Finished = True

End

' Public Function calculateDrawingPointsWithTangents(points As Float[])
'
'     ' points es una copia de P
'
'     ' En este caso, los Fit points no se proveeen, por lo que se calculan como el punto medio entre puntos de tangente
'
'     Dim interval As Float = 1 / numDrawingPoints
'     Dim t As Float = interval
'     Dim i, segments, iPoints, sobran, i2, faltan As Integer
'     Dim p0, p1, p2, p3 As New Float[]
'
'     ' Tengo que ver cuantos puntos tengo, casos basicos
'     If points.Count / 2 <= 2 Then ' es una recta
'
'         drawingPoints.Insert(points.Copy())
'         Return
'
'     Else If points.Count / 2 = 3 Then
'         ' es una curva quadratica
'         ' para no generar otra formula, puedo engañarme generando un nuevo punto tangente igual al unico que tengo
'         ' con esto, transformo la curva en cubica, que es la curva que siempre tendre
'         p0.Insert(points.Copy(i, 2))
'         p1.Insert(points.Copy(i + 2, 2))
'         p2.Insert(points.Copy(i + 4, 2))
'         p3.Insert(points.Copy(i + 4, 2))
'         For iPoints = 0 To numDrawingPoints - 1
'             drawingPoints.insert(CalculateBezierPoint2D(t, p0, p1, p2, p3))
'             t += interval
'         Next
'         Return
'     Else If points.Count / 2 = 4 Then
'
'         p0.Insert(points.Copy(i, 2))
'         p1.Insert(points.Copy(i + 2, 2))
'         p2.Insert(points.Copy(i + 4, 2))
'         p3.Insert(points.Copy(i + 6, 2))
'         For iPoints = 0 To numDrawingPoints - 1
'             drawingPoints.insert(CalculateBezierPoint2D(t, p0, p1, p2, p3))
'             t += interval
'         Next
'         Return
'
'     Else ' tengo 4 o mas puntos, voy a dibujar lo que pueda
'
'         '   01 23 45 67 89 1011 1213 1415 1617 1819 Max = 19 Count=20
'         '    1  2  3  4  5    6    7    8    9   10
'         '    F  T  nTangentes.............   T    F
'         i = 0
'         Do
'
'             ' veo cuantos puntos me quedan
'             If (i = 0) And (points.count - i >= 8) Then   ' primer tramo
'
'                 p0.Insert(points.Copy(i, 2))                ' PUNTO INICIAL
'                 p1.Insert(points.Copy(i + 2, 2))            ' TANGENTE
'                 p2.Insert(points.Copy(i + 4, 2))            ' TANGENTE
'
'                 p3.Add((points[i + 6] + points[i + 4]) / 2) ' ESTE PUNTO DEBE SER CALCULADO
'                 p3.Add((points[i + 7] + points[i + 5]) / 2)
'
'                 i += 4
'
'             Else If points.count - i > 8 Then             ' tramos intermedios
'
'                 p0.Add((points[i] + points[i + 2]) / 2)     ' PUNTO INICIAL, se calcula
'                 p0.Add((points[i + 1] + points[i + 3]) / 2)
'
'                 p1.Insert(points.Copy(i + 2, 2))            ' TANGENTE
'                 p2.Insert(points.Copy(i + 2, 2))            ' TANGENTE, igual al anterior
'
'                 p3.Add((points[i + 4] + points[i + 2]) / 2) ' ESTE PUNTO DEBE SER CALCULADO
'                 p3.Add((points[i + 5] + points[i + 3]) / 2)
'
'                 i += 2
'
'             Else If points.count - i = 8 Then             ' tramos intermedios
'
'                 p0.Add((points[i] + points[i + 2]) / 2)     ' PUNTO INICIAL, se calcula
'                 p0.Add((points[i + 1] + points[i + 3]) / 2)
'
'                 p1.Insert(points.Copy(i + 2, 2))            ' TANGENTE
'
'                 p2.Insert(points.Copy(i + 4, 2))            ' TANGENTE, igual al anterior
'
'                 p3.Insert(points.Copy(i + 6, 2))            ' PUNTO FINAL,
'
'                 i += 6
'
'             End If
'
'             t = 0
'             For iPoints = 0 To numDrawingPoints - 1
'
'                 drawingPoints.insert(CalculateBezierPoint2D(t, p0, p1, p2, p3))
'                 t += interval
'             Next
'
'             p0.Clear
'             p1.Clear
'             p2.Clear
'             p3.Clear
'
'         Loop Until I = points.Count - 2
'     End If
'
' End
'
' Public Function SplineTroughControlPoints(points As Float[], Tang1 As Boolean, Tang2 As Boolean)
'
'     ' points es una copia de P
'
'     ' En este caso, los Fit points no se proveeen, por lo que se calculan como el punto medio entre puntos de tangente
'
'     Dim interval As Float = 1 / numDrawingPoints
'     Dim t As Float = interval
'     Dim i, segments, iPoints, sobran, i2, faltan As Integer
'     Dim p0, p1, p2, p3 As New Float[]
'     Dim fdis As Float
'
'     ' Tengo que ver cuantos puntos tengo, casos basicos
'     If points.Count / 2 <= 2 Then ' es una recta
'
'         drawingPoints.Insert(points.Copy())
'         Return
'
'     Else If points.Count / 2 = 3 Then
'         ' es una curva quadratica
'         ' para no generar otra formula, puedo engañarme generando un nuevo punto tangente igual al unico que tengo
'         ' con esto, transformo la curva en cubica, que es la curva que siempre tendre
'         p0.Insert(points.Copy(i, 2))
'         p1.Insert(points.Copy(i + 2, 2))
'         p2.Insert(points.Copy(i + 4, 2))
'         p3.Insert(points.Copy(i + 4, 2))
'         For iPoints = 0 To numDrawingPoints - 1
'             drawingPoints.insert(CalculateBezierPoint2D(t, p0, p1, p2, p3))
'             t += interval
'         Next
'         Return
'     Else If points.Count / 2 = 4 Then
'
'         p0.Insert(points.Copy(i, 2))
'         p1.Insert(points.Copy(i + 2, 2))
'         p2.Insert(points.Copy(i + 4, 2))
'         p3.Insert(points.Copy(i + 6, 2))
'         For iPoints = 0 To numDrawingPoints - 1
'             drawingPoints.insert(CalculateBezierPoint2D(t, p0, p1, p2, p3))
'             t += interval
'         Next
'         Return
'
'     Else ' tengo 4 o mas puntos, voy a dibujar lo que pueda
'
'         '   01 23 45 67 89 1011 1213 1415 1617 1819 Max = 19 Count=20
'         '    1  2  3  4  5    6    7    8    9   10
'         '    F  T  nTangentes.............   T    F
'         i = 0
'         Do
'
'             ' veo cuantos puntos me quedan
'             If i = 0 Then   ' primer tramo
'
'                 If tang1 Then ' la tangente es 01
'                     fdis = puntos.distancia(points[2], points[3], points[4], points[5])
'
'                     p0.Insert(points.Copy(2, 2))                ' PUNTO INICIAL
'
'                     p1.Add(p0[0] + fdis * points[0])            ' TANGENTE
'                     p1.Add(p0[1] + fdis * points[1])
'
'                     p2.Insert(points.Copy(i + 4, 2))            ' TANGENTE
'
'                     p3.Add((points[i + 6] + points[i + 4]) / 2) ' ESTE PUNTO DEBE SER CALCULADO
'                     p3.Add((points[i + 7] + points[i + 5]) / 2)
'
'                     i += 4
'
'                 Else
'
'                     p0.Insert(points.Copy(i, 2))     ' PUNTO INICIAL, se calcula
'
'                     p1.Insert(points.Copy(i + 2, 2))            ' TANGENTE
'                     p2.Insert(points.Copy(i + 2, 2))            ' TANGENTE, igual al anterior
'
'                     p3.Add((points[i + 4] + points[i + 2]) / 2) ' ESTE PUNTO DEBE SER CALCULADO
'                     p3.Add((points[i + 5] + points[i + 3]) / 2)
'
'                     i += 2
'
'                 End If
'
'             Else If points.count - i > 8 Then             ' tramos intermedios
'
'                 p0.Add((points[i] + points[i + 2]) / 2)     ' PUNTO INICIAL, se calcula
'                 p0.Add((points[i + 1] + points[i + 3]) / 2)
'
'                 p1.Insert(points.Copy(i + 2, 2))            ' TANGENTE
'                 p2.Insert(points.Copy(i + 2, 2))            ' TANGENTE, igual al anterior
'
'                 p3.Add((points[i + 4] + points[i + 2]) / 2) ' ESTE PUNTO DEBE SER CALCULADO
'                 p3.Add((points[i + 5] + points[i + 3]) / 2)
'
'                 i += 2
'
'             Else If points.count - i = 8 Then             ' tramos final
'
'                 p0.Add((points[i] + points[i + 2]) / 2)     ' PUNTO INICIAL, se calcula
'                 p0.Add((points[i + 1] + points[i + 3]) / 2)
'
'                 p1.Insert(points.Copy(i + 2, 2))            ' TANGENTE
'
'                 p2.Insert(points.Copy(i + 4, 2))            ' TANGENTE, igual al anterior
'
'                 p3.Insert(points.Copy(i + 6, 2))            ' PUNTO FINAL,
'
'                 i += 6
'
'             End If
'
'             t = 0
'             For iPoints = 0 To numDrawingPoints - 1
'
'                 drawingPoints.insert(CalculateBezierPoint2D(t, p0, p1, p2, p3))
'                 t += interval
'             Next
'
'             p0.Clear
'             p1.Clear
'             p2.Clear
'             p3.Clear
'
'         Loop Until I = points.Count - 2
'     End If
'
' End
'
' Public Function SplineTroughFitPoints(points As Float[]) ' points es una copia de P
'
'     Dim interval As Float = 1 / numDrawingPoints
'     Dim t As Float = interval
'     Dim i, segments, iPoints, sobran, i2, faltan As Integer
'     Dim p0, p1, p2, p3 As New Float[]
'
'     ' Tengo que ver cuantos puntos tengo, casos basicos
'     If points.Count / 2 <= 2 Then ' es una recta
'
'         drawingPoints.Insert(points.Copy())
'         Return
'
'     Else If points.Count / 2 = 3 Then
'         ' es una curva quadratica
'         ' para no generar otra formula, puedo engañarme generando un nuevo punto tangente igual al unico que tengo
'         ' con esto, transformo la curva en cubica, que es la curva que siempre tendre
'         p0.Insert(points.Copy(i, 2))                ' Fit point , la curva debe pasar por aca
'         p1.Insert(points.Copy(i + 2, 2))            ' se calcula
'
'         p2.Insert(points.Copy(i + 2, 2))            ' fit point
'         p3.Insert(points.Copy(i + 4, 2))            ' tangente, el mouse esta aqui
'         For iPoints = 0 To numDrawingPoints - 1
'             drawingPoints.insert(CalculateBezierPoint2D(t, p0, p1, p2, p3))
'             t += interval
'         Next
'         Return
'     Else If points.Count / 2 = 4 Then
'
'         p0.Insert(points.Copy(i, 2))
'         p1.Insert(points.Copy(i + 2, 2))
'         p2.Insert(points.Copy(i + 4, 2))
'         p3.Insert(points.Copy(i + 6, 2))
'         For iPoints = 0 To numDrawingPoints - 1
'             drawingPoints.insert(CalculateBezierPoint2D(t, p0, p1, p2, p3))
'             t += interval
'         Next
'         Return
'
'     Else ' tengo 4 o mas puntos, voy a dibujar lo que pueda
'         ' La curva necesita  Fit-Control-Control-Fit
'         ' Casos mas complejos
'         ' A - Si tengo 4 puntos, tengo la curva cubica perfecta.
'         ' B - Si tengo 5 puntos, estiro la curva moviendo el ultimo fit al ultimo control:
'         '       Fit - Control - Control - Fit - > Control
'         ' C - Si tengo 6 puntos, creo un Control q me de la misma tangente al 4to Fit, y agrego otro Fit en el ultimo Control:
'         '       Fit0 - Control1 - Control2- Fit3- Control4 (creado, tang al 2) - Control5 (marcado) - Fit6 (creado = 5)
'
'         ' el primer punto de control lo espejo del segmento anterior
'         ' y lo inserto directamente en el array de los puntos
'         ' pero en la anteultima posicion
'
'         '   01 23 45 67 89 1011 1213 1415 1617 1819 Max = 19 Count=20
'         '    1  2  3  4  5    6    7    8    9   10
'
'         For i = 0 To points.max Step 6
'             If points.count - i >= 8 Then  ' caso A -> mando a dibujar
'                 p0.Insert(points.Copy(i, 2))
'                 p1.Insert(points.Copy(i + 2, 2))
'                 p2.Insert(points.Copy(i + 4, 2))
'                 p3.Insert(points.Copy(i + 6, 2))
'
'             Else If points.count - i = 6 Then  ' caso B: Tengo Fit+Control+Control
'
'                 p0.Insert(points.Copy(i, 2))
'                 p1.Insert(points.Copy(i + 2, 2))
'                 p2.Insert(points.Copy(i + 2, 2))
'                 p3.Insert(points.Copy(i + 4, 2))
'
'             Else If points.count - i = 4 Then  ' caso C: Tengo Fit+Control (nuevo)
'
'                 '   01 23 45 67 89  Max = 9 Count=10
'                 '    1  2  3  4  5
'                 '    F  C  C  F  C
'
'                 ' duplico el ultimo Control point
'                 points.Add(0)
'                 points.Add(0)
'                 points[points.max - 1] = points[points.max - 3]
'                 points[points.max] = points[points.max - 2]
'
'                 ' tengo q engañar a clsEntityBuilder
'                 'clsEntityBuilder.iPoints = points.Count / 2
'                 'clsEntityBuilder.MoveOn()
'
'                 '   01 23 45 67 89 1011 Max = 11 Count=12
'                 '    1  2  3  4  5    6
'                 '    F  C  C  F  C    C
'                 '          ^-----|
'                 ' el control point agregado es correlativo al de la curva anterior
'                 points[points.max - 3] = 2 * points[points.max - 5] - points[points.Max - 7]
'                 points[points.max - 2] = 2 * points[points.max - 4] - points[points.Max - 6]
'
'                 ' ahora la tomo como un tipo B
'
'                 p0.Insert(points.Copy(i, 2))
'                 p1.Insert(points.Copy(i + 2, 2))
'                 p2.Insert(points.Copy(i + 4, 2))
'                 p3.Insert(points.Copy(i + 4, 2))
'
'             Else If points.count - i = 2 Then  ' no hay nada q dibujar
'                 p0.Insert(points.Copy(i, 2))
'                 p1.Insert(points.Copy(i, 2))
'                 p2.Insert(points.Copy(i, 2))
'                 p3.Insert(points.Copy(i, 2))
'
'             End If
'
'             t = 0
'             For iPoints = 0 To numDrawingPoints - 1
'
'                 drawingPoints.insert(CalculateBezierPoint2D(t, p0, p1, p2, p3))
'                 t += interval
'             Next
'
'             p0.Clear
'             p1.Clear
'             p2.Clear
'             p3.Clear
'
'         Next
'     End If
'
' End
'
' Public Function calculateDrawingPoints(points As Float[]) ' points es una copia de P
'
'     Dim interval As Float = 1 / numDrawingPoints
'     Dim t As Float = interval
'     Dim i, segments, iPoints, sobran, i2, faltan As Integer
'     Dim p0, p1, p2, p3 As New Float[]
'
'     ' Tengo que ver cuantos puntos tengo, casos basicos
'     If points.Count / 2 <= 2 Then ' es una recta
'
'         drawingPoints.Insert(points.Copy())
'         Return
'
'     Else If points.Count / 2 = 3 Then
'         ' es una curva quadratica
'         ' para no generar otra formula, puedo engañarme generando un nuevo punto tangente igual al unico que tengo
'         ' con esto, transformo la curva en cubica, que es la curva que siempre tendre
'         p0.Insert(points.Copy(i, 2))
'         p1.Insert(points.Copy(i + 2, 2))
'         p2.Insert(points.Copy(i + 4, 2))
'         p3.Insert(points.Copy(i + 4, 2))
'         For iPoints = 0 To numDrawingPoints - 1
'             drawingPoints.insert(CalculateBezierPoint2D(t, p0, p1, p2, p3))
'             t += interval
'         Next
'         Return
'     Else If points.Count / 2 = 4 Then
'
'         p0.Insert(points.Copy(i, 2))
'         p1.Insert(points.Copy(i + 2, 2))
'         p2.Insert(points.Copy(i + 4, 2))
'         p3.Insert(points.Copy(i + 6, 2))
'         For iPoints = 0 To numDrawingPoints - 1
'             drawingPoints.insert(CalculateBezierPoint2D(t, p0, p1, p2, p3))
'             t += interval
'         Next
'         Return
'
'     Else ' tengo 4 o mas puntos, voy a dibujar lo que pueda
'         ' La curva necesita  Fit-Control-Control-Fit
'         ' Casos mas complejos
'         ' A - Si tengo 4 puntos, tengo la curva cubica perfecta.
'         ' B - Si tengo 5 puntos, estiro la curva moviendo el ultimo fit al ultimo control:
'         '       Fit - Control - Control - Fit - > Control
'         ' C - Si tengo 6 puntos, creo un Control q me de la misma tangente al 4to Fit, y agrego otro Fit en el ultimo Control:
'         '       Fit0 - Control1 - Control2- Fit3- Control4 (creado, tang al 2) - Control5 (marcado) - Fit6 (creado = 5)
'
'         ' el primer punto de control lo espejo del segmento anterior
'         ' y lo inserto directamente en el array de los puntos
'         ' pero en la anteultima posicion
'
'         '   01 23 45 67 89 1011 1213 1415 1617 1819 Max = 19 Count=20
'         '    1  2  3  4  5    6    7    8    9   10
'
'         For i = 0 To points.max Step 6
'             If points.count - i >= 8 Then  ' caso A -> mando a dibujar
'                 p0.Insert(points.Copy(i, 2))
'                 p1.Insert(points.Copy(i + 2, 2))
'                 p2.Insert(points.Copy(i + 4, 2))
'                 p3.Insert(points.Copy(i + 6, 2))
'
'             Else If points.count - i = 6 Then  ' caso B: Tengo Fit+Control+Control
'
'                 p0.Insert(points.Copy(i, 2))
'                 p1.Insert(points.Copy(i + 2, 2))
'                 p2.Insert(points.Copy(i + 4, 2))
'                 p3.Insert(points.Copy(i + 4, 2))
'
'             Else If points.count - i = 4 Then  ' caso C: Tengo Fit+Control (nuevo)
'
'                 '   01 23 45 67 89  Max = 9 Count=10
'                 '    1  2  3  4  5
'                 '    F  C  C  F  C
'
'                 ' duplico el ultimo Control point
'                 points.Add(0)
'                 points.Add(0)
'                 points[points.max - 1] = points[points.max - 3]
'                 points[points.max] = points[points.max - 2]
'
'                 ' tengo q engañar a clsEntityBuilder
'                 'clsEntityBuilder.iPoints = points.Count / 2
'                 'clsEntityBuilder.MoveOn()
'
'                 '   01 23 45 67 89 1011 Max = 11 Count=12
'                 '    1  2  3  4  5    6
'                 '    F  C  C  F  C    C
'                 '          ^-----|
'                 ' el control point agregado es correlativo al de la curva anterior
'                 points[points.max - 3] = 2 * points[points.max - 5] - points[points.Max - 7]
'                 points[points.max - 2] = 2 * points[points.max - 4] - points[points.Max - 6]
'
'                 ' ahora la tomo como un tipo B
'
'                 p0.Insert(points.Copy(i, 2))
'                 p1.Insert(points.Copy(i + 2, 2))
'                 p2.Insert(points.Copy(i + 4, 2))
'                 p3.Insert(points.Copy(i + 4, 2))
'
'             Else If points.count - i = 2 Then  ' no hay nada q dibujar
'                 p0.Insert(points.Copy(i, 2))
'                 p1.Insert(points.Copy(i, 2))
'                 p2.Insert(points.Copy(i, 2))
'                 p3.Insert(points.Copy(i, 2))
'
'             End If
'
'             t = 0
'             For iPoints = 0 To numDrawingPoints - 1
'
'                 drawingPoints.insert(CalculateBezierPoint2D(t, p0, p1, p2, p3))
'                 t += interval
'             Next
'
'             p0.Clear
'             p1.Clear
'             p2.Clear
'             p3.Clear
'
'         Next
'     End If
'
' End
'
' '=======================================================================================================
' ' Nuevo metodo
' '=======================================================================================================
'
' '' Calculates a point in a Cubic Bezier curve
' '' if P1=P2 this turn into a Quadratic curve
' Public Function CalculateBezierPoint2D(t As Float, p0 As Float[], p1 As Float[], p2 As Float[], p3 As Float[]) As Float[]
'
'     Dim u As Float = 1 - t    ' t va de 0 a 1
'     Dim tt As Float = t * t
'     Dim uu As Float = u * u
'     Dim uuu As Float = uu * u
'     Dim ttt As Float = tt * t
'     Dim pr As New Float[]
'
'     pr.Insert([0.0, 0.0])
'
'     pr[0] = uuu * p0[0]            ' first term
'     pr[0] += 3 * uu * t * p1[0]    ' second term
'     pr[0] += 3 * u * tt * p2[0]    ' third term
'     pr[0] += ttt * p3[0]           ' fourth term
'
'     pr[1] = uuu * p0[1]            ' first term
'     pr[1] += 3 * uu * t * p1[1]    ' second term
'     pr[1] += 3 * u * tt * p2[1]    ' third term
'     pr[1] += ttt * p3[1]           ' fourth term
'
'     ' para 3D agregar [2]
'
'     Return pr
'
' End

' Public Sub ExportDXF(e As Entity, hFile As File)
'
'     Dim i As Integer
'
'     Print #hFIle, "  0"                       ' Entity type
'     Print #hFIle, "SPLINE"
'     clsEntities.DXFExportCommon(e, hFile)
'     Print #hFIle, "100"                     ' Subclass marker
'     Print #hFIle, "AcDbSpline"
'     Print #hFIle, "210"                     ' vector normal
'     Print #hFIle, "  0"
'     Print #hFIle, "220"
'     Print #hFIle, "  0"
'     Print #hFIle, "230"
'     Print #hFIle, "  0"
'     Print #hFIle, " 70"                      ' Spline flag (bit coded):1 = Closed spline 2 = Periodic spline 4 = Rational spline 8 = Planar 16 = Linear(planar bit Is Also set)
'     Print #hFIle, e.fParam[Me.ipaFlag]
'     Print #hFIle, " 71"                      ' grado de la ecuacion
'     Print #hFIle, e.fParam[Me.ipaDegree]
'     Print #hFIle, " 72"                      ' cantidad de nudos
'     Print #hFIle, e.fParam[Me.ipaTotalKnots]
'     Print #hFIle, " 73"                      ' cantidad de puntos de control ?????????????
'     Print #hFIle, e.fParam[Me.ipaTotalControlPoints]
'     Print #hFIle, " 74"                      ' cantidad de fit points
'     Print #hFIle, e.fParam[Me.ipaTotalFitPoints]
'     Print #hFIle, " 42"                      ' Knot tolerance (default = 0.0000001)
'     Print #hFIle, e.fParam[Me.ipaKnotTolerance]
'     Print #hFIle, " 43"                      ' Control-point tolerance (default = 0.0000001)
'     Print #hFIle, e.fParam[Me.ipaControlTolerance]
'     Print #hFIle, " 44"                      ' Fit tolerance (default = 0.0000000001)
'     Print #hFIle, e.fParam[Me.ipaFitTolerance]
'     For i = 0 To e.p.Max Step 2
'         Print #hFIle, "40"                      ' Knot value ???
'         Print #hFIle, "0"
'     Next
'     For i = 0 To e.p.Max Step 2
'         Print #hFIle, " 10"                      ' Xi
'         Print #hFIle, CStr(e.p[i])
'         Print #hFIle, " 20"                      ' Yi
'         Print #hFIle, CStr(e.p[i + 1])
'         Print #hFIle, " 30"                      ' Zi
'         Print #hFIle, "  0"
'
'     Next
'
' End

Public Sub ExportDXFCol(e As Entity, ByRef cExport As Collection) As Boolean

    Dim i As Integer

    cExport.Add("SPLINE", dxf.codEntity)
    clsEntities.DXFExportCommonCol(e, cExport)
    cExport.Add("AcDbSpline", "100")
    cExport.Add(CStr(e.fParam[Me.ipaFlag]), "70")
    ' 70' Spline flag(bit coded):
    ' 1 = Closed spline
    ' 2 = Periodic spline
    ' 4 = Rational spline
    ' 8 = Planar
    ' 16 = Linear(planar bit Is Also set)
    cExport.Add(CStr(e.fParam[Me.ipaDegree]), "71")                 ' 2 = quadrtic; 3 = cubic
    cExport.Add(CStr(e.fParam[Me.ipaTotalKnots]), "72")
    cExport.Add(CStr(e.fParam[Me.ipaTotalControlPoints]), "73")
    cExport.Add(CStr(e.fParam[Me.ipaTotalFitPoints]), "74")
    cExport.Add(CStr(e.fParam[Me.ipaKnotTolerance]), "42")          ' 0.0000001
    cExport.Add(CStr(e.fParam[Me.ipaControlTolerance]), "43")       ' 0.0000001
    cExport.Add(CStr(e.fParam[Me.ipaFitTolerance]), "44")           ' 0.0000000001
    For i = 1 To e.fParam[Me.ipaTotalKnots]
        cExport.Add(CStr(e.fParam[Me.TotalParams + i - 1]), "40" & "_" & CStr(i))
    Next
    For i = 0 To e.p.Max Step 2
        cExport.Add(CStr(e.p[i]), dxf.codX0 & "_" & CStr(i / 2))
        cExport.Add(CStr(e.p[i + 1]), dxf.codY0 & "_" & CStr(i / 2))
        cExport.Add("0", dxf.codZ0 & "_" & CStr(i / 2))
    Next

End

Public Function ImportDXF(e As Entity, sClaves As String[], sValues As String[]) As Boolean

    Dim i As Integer
    Dim Pbase As New Float[]
    Dim Ptang1 As New Float[]
    Dim Ptang2 As New Float[]

    e.P.Clear
    For i = 0 To sClaves.Max

        If sClaves[i] = "70" Then e.fParam[Me.ipaFlag] = CInt(sValues[i])
        If sClaves[i] = "71" Then e.fParam[Me.ipaDegree] = CInt(sValues[i])
        If sClaves[i] = "72" Then e.fParam[Me.ipaTotalKnots] = CInt(sValues[i])
        If sClaves[i] = "73" Then e.fParam[Me.ipaTotalControlPoints] = CInt(sValues[i])
        If sClaves[i] = "74" Then e.fParam[Me.ipaTotalFitPoints] = CInt(sValues[i])
        If sClaves[i] = "42" Then e.fParam[Me.ipaKnotTolerance] = CFloat(sValues[i])
        If sClaves[i] = "43" Then e.fParam[Me.ipaControlTolerance] = CFloat(sValues[i])
        If sClaves[i] = "44" Then e.fParam[Me.ipaFitTolerance] = CFloat(sValues[i])

        ' Los Knots estan en el indice me.TotalParams en adelante
        If sClaves[i] = "40" Then e.fParam.Add(CFloat(sValues[i]))

        ' por lo general hay fit points o controls points, pero no ambos, cargo lo que sea en P
        ' Control points
        If sClaves[i] = "10" Then Pbase.Add(CFloat(sValues[i]))
        If sClaves[i] = "20" Then Pbase.Add(CFloat(sValues[i]))

        ' Estos Fitting points no se usan en la construccion, tengo que verificar si los necesitan otros programas para guardarlos y reescribirlos
        'If sClaves[i] = "11" Then Pbase.Add(CFloat(sValues[i]))
        'If sClaves[i] = "21" Then Pbase.Add(CFloat(sValues[i]))

        ' tangentes, no se usan DXF
        If sClaves[i] = "12" Then Ptang1.Add(CFloat(sValues[i]))
        If sClaves[i] = "22" Then Ptang1.Add(CFloat(sValues[i]))

        If sClaves[i] = "13" Then Ptang2.Add(CFloat(sValues[i]))
        If sClaves[i] = "23" Then Ptang2.Add(CFloat(sValues[i]))

    Next

    ' con todos los datos recabados, armo el array

    ' If Ptang1.Count > 0 Then
    '     e.fParam[Me.ipaTang1] = 1
    '     e.P.Add(Ptang1[0])
    '     e.P.Add(Ptang1[1])
    ' End If
    e.P.Insert(Pbase.Copy(), e.P.Max)
    '
    ' If Ptang2.Count > 0 Then
    '
    '     e.fParam[Me.ipaTang2] = 1
    '     e.P.Add(Ptang2[0])
    '     e.P.Add(Ptang2[1])
    ' End If

    ' If e.fParam.Count = 0 Then e.fParam.Add(0)
    ' If e.fParam[0] = 1 And e.p.Count > 0 Then ' agrego el primer punto de nuevo
    '   e.p.Add(e.p[0])
    '   e.p.Add(e.p[1])
    ' End IfPtang
    Return True

    ' catch

    Return False

End

Private Function CoxDeBoor(u As Float, i As Float, k As Float) As Float

    Dim Eq1, Eq2 As Float
    Dim Den1, Den2 As Float

    If (k = 1) Then

        If ((Knots[i] <= u) And (u <= Knots[i + 1])) Then
            Return 1.0
        Else
            Return 0.0
        End If
    End If
    Den1 = Knots[i + k - 1] - Knots[i]
    Den2 = Knots[i + k] - Knots[i + 1]

    If (Den1 > 0) Then
        Eq1 = ((u - Knots[i]) / Den1) * CoxDeBoor(u, i, k - 1)
    End If
    If (Den2 > 0) Then
        Eq2 = (Knots[i + k] - u) / Den2 * CoxDeBoor(u, i + 1, k - 1)
    End If
    Return Eq1 + Eq2

End

' - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -GetOutpoint()
'
Public Sub GetOutpoint(t As Float, OutPoint As Float[])

    ' sum the effect Of all CV 's on the curve at this point to
    ' get the evaluated curve point
    Dim i As Integer
    Dim fVal As Float

    For i = 0 To g_num_cvs - 1

        ' calculate the effect Of this point On the curve

        fVal = CoxDeBoor(t, i, g_order)

        If (fVal > 0.001) Then

            ' sum effect Of CV On this part Of the curve
            OutPoint[0] += fVal * g_Points[i * 2 + 0]
            OutPoint[1] += fVal * g_Points[i * 2 + 1]
            OutPoint[2] += 0 'fVal * g_Points[i * 3 + 2] ' Para 3D el array g_points deberia ser 3D
        End If
    Next

End

Public Sub Draw(oE As Entity)

    ' This routine is based on the work of:
    ' Rob Bateman
    ' Date 9 - feb - 2005
    ' This Is A very simple example Of a bezier curve
    ' Thank you! - Martin

    Dim OutPoint As New Float[]
    Dim i As Integer
    Dim t As Float

    If oe.P.Count = 2 Then Return

    If oe.P.Count = 4 Then
        cadLine.Draw(oe)
        Return
    End If
    oe.PolyLine.Clear
    g_degree = oe.fParam[Me.ipaDegree] ' 2 o 3
    g_order = g_degree + 1

    OutPoint.Insert([0.0, 0.0, 0.0])
    ' rearmo los pesos de los nudos
    Knots.Clear
    Knots.Insert(oe.fParam.Copy(Me.TotalParams, oe.fParam.Count - Me.TotalParams))

    ' rearmo los control points
    g_points.Clear
    g_points.Insert(oe.p.Copy())

    g_num_cvs = g_points.Count / 2

    'gl.Begin(GL.LINE_STRIP)
    For i = 0 To LOD - 1    ' LOD es el nummero de tramos

        t = Knots[Knots.Max] * i / (LOD - 1)

        If (i = LOD - 1) Then t -= 0.001

        GetOutpoint(t, Outpoint)

        'gl.Vertex3f(Outpoint[0], Outpoint[1], Outpoint[2])

        oe.PolyLine.Add(Outpoint[0])
        oe.PolyLine.Add(Outpoint[1])

        OutPoint[0] = 0
        OutPoint[1] = 0
    Next
    'gl.End()

    oE.ColorToPaint = gcd.GetGBColor(oE.colour, oE.pLayer)
    glPlus.PolyLines(oe.PolyLine, oe.ColorToPaint, oE.LineWidth, oE.LineType.index)

    ' This is to draw the Control Points

    ' gl.Color3f(1, 0, 0)
    ' gl.PointSize(3)
    ' gl.Begin(GL.POINTS)
    ' For i = 0 To g_num_cvs - 1
    '     gl.Vertex3f(g_Points[i], g_Points[i + 1], 0)
    ' Next
    ' gl.End()

End
