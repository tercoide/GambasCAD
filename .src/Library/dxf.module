' Gambas module file

Public LoadingPercent As Single
Private LoadLastPercent As Single
Private LoadTotalBytes As Integer
Private LoadedBytes As Integer

Private fp As File
Private hFile As File

Private lpCode As String
Private lpValue As String

Private LastCodeReadIndex As Integer = 0
Private eExports As Boolean
Private Block_REcord As New Collection
Private hContainers As New Collection
Private ReadTimes As New Collection
Private ReadEntities As New Collection
Public cEntitiesUnread As Collection
Public nEntitiesUnread As Integer
Public nEntitiesRead As Integer
Private iLastid As Integer = 0
Private iTableid As Integer = 0

' Codigos del DXF
Public Const codEntity As String = "0"
Public Const codid As String = "5"
Public Const codidContainer As String = "330"
Public Const codColor As String = "62"
Public Const codLType As String = "6"
Public Const codLayer As String = "8"
Public Const codLWht As String = "370"
Public Const codName As String = "2"
Public Const codX0 As String = "10"
Public Const codY0 As String = "20"
Public Const codZ0 As String = "30"
Public Const codX1 As String = "11"
Public Const codY1 As String = "21"
Public Const codZ1 As String = "31"
Public Const codX2 As String = "12"
Public Const codY2 As String = "22"
Public Const codZ2 As String = "32"
Public Const codX3 As String = "13"
Public Const codY3 As String = "23"
Public Const codZ3 As String = "33"
Public Const codCenterX As String = "10"
Public Const codCenterY As String = "20"
Public Const codCenterZ As String = "30"
Public Const codRadius As String = "40"
Public Const codAngleStart As String = "50"
Public Const codAngleEnd As String = "51"

Public Function DWGtoDXF(sDwgFile As String) As String

    Dim str, tmpfile As String
    ' elimino el archivo temporal que hubiese creado
    tmpfile = sDwgFile & ".tmp"
    If Exist(tmpfile) Then Kill tmpfile
    ' convierte DWG a DXF version 2010
    Shell "/usr/local/bin/dwgread '" & sDwgFile & "' -O DXF -a r2010 -o '" & tmpfile & "'" Wait To str
    gcd.debuginfo("Resultados de la conversion DWG a DXF " & Str)
    Return tmpfile

End

'' Carga el DXF y lo mete en cModel del dibujo actual
' Verbose=0 nada, 1=minimo, 2=grupos, 3=todo
Public Function LoadFile(sFile As String, drw As Drawing, Optional IgnoreTables As Boolean = False, IgnoreBlocks As Boolean = False, IgnoreHeader As Boolean = False, VerboseLevel As Integer = 0, UpdateGraphics As Boolean = True, ReadObjects As Boolean = True) As Boolean

    Dim t As Float = Timer
    Dim cLlaveActual, cSectionActual, cTable As Collection
    Dim cToFill As New Collection

    iLastid = 0

    fp = Open sFile For Read

    If Not fp Then Error.Raise("Error !")

    LoadedBytes = 0
    LoadTotalBytes = Lof(fp)

    cEntitiesUnread = New Collection
    nEntitiesUnread = 0
    nEntitiesRead = 0
    hContainers = New Collection

    While Not Eof(fp)
        'Wait 0.0001
        ReadData
        If lpCode = "0" And lpValue = "SECTION" Then

            ' vemos que seccion es
            ReadData
            If lpCode = "2" And lpValue = "HEADER" And Not IgnoreHeader Then
                ' creo la llave, pero solo si es necesario
                If Not cToFill.Exist("HEADER") Then
                    cLlaveActual = New Collection
                    cToFill.Add(cLlaveActual, "HEADER")
                Else
                    cLlaveActual = cToFill["HEADER"]
                End If

                Load1HeadersDirect(drw.Headers)
                gcd.debugInfo("Leidos Headers",,, True)

            End If

            If lpCode = "2" And lpValue = "CLASSES" Then

                Load2Classes(drw)
                gcd.debugInfo("Leidas Classes",,, True)

            End If

            If lpCode = "2" And lpValue = "TABLES" And Not IgnoreTables Then
                If Not cToFill.Exist("TABLES") Then
                    cLlaveActual = New Collection
                    cToFill.Add(cLlaveActual, "TABLES")
                Else
                    cLlaveActual = cToFill["TABLES"]
                End If
                Load3Tables(cLlaveActual)
                gcd.debugInfo("Leidos Tables",,, True)

                ' con las tablas cargadas, llenamoslas colecciones de objetos
                ReadViewports(cToFill, drw)
                ReadLTypes(cToFill, drw)
                ReadStyles(cToFill, drw)
                ReadLayers(cToFill, drw)
                gcd.debugInfo("Tables al Drawing",,, True)

            End If

            '
            If lpCode = "2" And lpValue = "BLOCKS" And Not IgnoreBlocks Then
                ' creo la llave
                cLlaveActual = New Collection
                cToFill.Add(cLlaveActual, "BLOCKS")
                Load4Blocks(cLlaveActual)
                gcd.debugInfo("Leidos Blocks",,, True)

            End If

            If lpCode = "2" And lpValue = "ENTITIES" Then
                ' creo la llave
                cLlaveActual = New Collection
                cToFill.Add(cLlaveActual, "ENTITIES")

                Load5Entities(cLlaveActual)
                gcd.debugInfo("Leidas Entidades",,, True)

            End If
            '
            If lpCode = "2" And lpValue = "OBJECTS" Then

                If Not cToFill.Exist("OBJECTS") Then
                    cLlaveActual = New Collection
                    cToFill.Add(cLlaveActual, "OBJECTS")
                Else
                    cLlaveActual = cToFill["OBJECTS"]
                End If

                Load6Objects(cLlaveActual)
                gcd.debugInfo("Leidos Objetos",,, True)

            End If

            If lpCode = "2" And lpValue = "THUMBNAILIMAGE" Then

                If Not cToFill.Exist("THUMBNAILIMAGE") Then
                    cLlaveActual = New Collection
                    cToFill.Add(cLlaveActual, "THUMBNAILIMAGE")
                Else
                    cLlaveActual = cToFill["THUMBNAILIMAGE"]
                End If

                Load7Thumbnail(cLlaveActual)

            End If

        Endif
    Wend
    gcd.debugInfo("Leidos el DXF",,, True)

    If ReadObjects Then ReadObjectsFromDXF(cToFill, drw)
    If UpdateGraphics Then
        ImportBlocksFromDXF(cToFill, drw)
        clsEntities.BuildPoi()
        DXFtoEntity(cToFill["ENTITIES"], cToFill, drw)
        'gcd.DigestInserts()
        SetViewports(cToFill, drw)
    End If

    For Each ft As Float In ReadTimes
        gcd.debugInfo(ReadEntities[ReadTimes.Key] & " " & gb.Tab & ReadTimes.Key & gb.Tab & gb.Tab & gb.Tab & " total time: " & Format(fT, "0.0000"))
    Next

    If VerboseLevel > 1 Then
        If VerboseLevel > 2 Then
            gcd.debuginfo("DXF: Leidas " & nEntitiesread & " entidades")
            If cEntitiesUnread.Count > 0 Then
                gcd.debuginfo("DXF: Un total de" & nEntitiesUnread & " entidades no pudieron ser leidas:")
                For Each unread As String In cEntitiesUnread
                    Print unread
                Next
            Endif
            Print
        End If
        gcd.debuginfo("DXF: fin lectura en " & Str(Timer - t))
    End If
    gcd.debuginfo("DXF: fin lectura en " & Str(Timer - t))
    Return False

End

Private Sub ReadData()

    Line Input #fp, lpcode
    Line Input #fp, lpValue

    LoadedBytes += Len(lpcode)
    LoadedBytes += Len(lpvalue)

    If Right(lpcode, 1) = gb.Cr Then lpcode = Left(lpcode, -1)
    If Right(lpvalue, 1) = gb.cr Then lpvalue = Left(lpvalue, -1)

    lpcode = Trim$(lpcode)
    lpvalue = Trim$(lpvalue)

    ' updating percentage

    LoadingPercent = LoadedBytes / LoadTotalBytes

    If LoadingPercent - LoadLastPercent > 0.01 Then
        gcd.debugInfo("Loging file " & CInt(LoadingPercent * 100) & "%", True, True)
        LoadLastPercent = LoadingPercent
    End If

End

Private Sub Load1HeadersDirect(Headers As Headers)

    ' Los header se guardan asi
    '   9                     Indica que es una variable
    ' $EXTMAX                 Nombre de la variable
    '  10                     Tipo de dato1
    ' 198.0411690635561       Dato1
    '  20                     Tipo de dato2
    ' 178.7767572407179       Dato2
    '  30                     etc
    '   0

    ' Yo usare dos colecciones

    Dim sVarName As String
    Dim cVariable As Variant[]
    Dim v As Variant
    Dim slx As New Single[]
    Dim inx As New Integer[]
    Dim i As Integer

    ReadData
    Do

        If lpCode = "0" And lpValue = "ENDSEC" Then Break

        If lpcode = "9" Then ' nueva variable
            cVariable = New Variant[]
            sVarName = Mid(lpvalue, 2)

            Do                          ' este bucle es por si la variable es un array
                ReadData
                If lpcode = "0" Or lpCode = "9" Then Break
                cVariable.Add(lpvalue)
            Loop
            If Not Headers.SetValues(sVarName, cVariable) Then gcd.debugInfo("Var " & sVarName & " not found.")
            Inc i

        Endif

    Loop

    gcd.debuginfo("DXF: Leidas " & i & " variables de ambiente")

End

Private Sub Load2Classes(drwLoading As Drawing)

    Dim cClass As CadClass

    Do

        If lpValue = "CLASSES" Then ReadData
        If lpValue = "ENDSEC" Then Return

        cClass = New CadClass
        drwLoading.CadClasses.Add(cClass)

        ReadData

        While (lpcode <> "0") And Not Eof(fp)
            If lpcode = "0" Then cClass.recordtype = lpValue
            If lpcode = "1" Then cClass.recordname = lpValue
            If lpcode = "2" Then cClass.CPPName = lpValue
            If lpcode = "3" Then cClass.AppName = lpValue
            If lpcode = "90" Then cClass.ProxyCapp = CInt(lpValue)
            If lpcode = "91" Then cClass.InstanceCount = CInt(lpValue)
            If lpcode = "280" Then cClass.ProxyFlag = CInt(lpValue)
            If lpcode = "281" Then cClass.EntityFlag = CInt(lpValue)

            ReadData

        Wend

    Loop

End

Private Sub Load3Tables(cTables As Collection)

    Dim sTableName As String
    Dim sTableid As String  ' in hex
    Dim sTableContainer As String   ' in hex , 0 = nobody
    Dim iTableEntries As Integer
    Dim cTable As Collection

    ' creamos una table inicial con los handles de las tables
    cTable = New Collection
    cTables.Add(cTable, "__AuxData__")

    ReadData
    Do
        If Eof(fp) Then Break

        If lpCode = "0" And lpValue = "ENDSEC" Then Break

        If lpCode = "0" And lpValue = "TABLE" Then

            ' OBTENGO DATOS DE LA TABLA
            ' -1 APP: entity name(changes Each Time a drawing Is Opened)
            ' 0 Object type(TABLE)
            ' 2 Table name
            ' 5 Handle
            ' 330 Soft - pointer ID / handle To owner object
            ' 100 Subclass marker(AcDbSymbolTable)
            ' 70 Maximum number Of entries In table
            ReadData
            While lpcode <> "0"

                If lpcode = "5" Then sTableid = lpvalue

                If lpcode = "2" Then sTableName = lpvalue
                If lpcode = "330" Then sTableContainer = lpvalue

                'If sTableName = "VIEW" Then Stop

                ' WARNING: este dato no es valido para todas las versiones de DXF
                ' en algunos archivos hay mas tablas que lo que indica este numero
                ' No hay que darle importancia a este numero!!!
                If lpcode = "70" Then iTableEntries = CInt(lpvalue)

                ReadData
            Wend

            ' agrego datos a la tabla auxiliar del dibujo
            cTables["__AuxData__"].Add(sTableid, sTableName)

            cTable = New Collection

            cTables.Add(cTable, sTableName)

            ' verifico que la tabla no tenga entradas, lo que me altera la carga
            If lpvalue <> "ENDTAB" Then
                'NewObject(cTable, sTableHandle)
                Load31Table(cTable, iTableEntries)
            End If
        End If
        ReadData
    Loop

End
'' Lee todas las tables de esta table

Private Sub Load31Table(cVars As Collection, iEntries As Integer)

    ' Yo usare dos colecciones

    Dim sTableName, sid As String
    Dim cTable As Collection
    Dim i As Integer

    Dim iCode As Integer, NewKey As String

    ' Tengo q leer iEntries
    'For i = 1 To iEntries
    Do
        Inc i
        cTable = New Collection
        sTableName = ""
        iCode = 0

        ReadData

        ' esto lee todas las tables en la table

        'If lpCode = "0" Then Break

        While lpcode <> "0"
            NewKey = lpcode
            If cTable.Exist(NewKey) Then
                Do
                    iCode += 1
                    NewKey = lpcode & "_" & CStr(iCode)

                    If Not cTable.Exist(NewKey) Then Break
                Loop
            Endif
            cTable.Add(lpvalue, NewKey)

            If lpcode = Me.codid Then sTableName = lpvalue
            ReadData

        Wend
        'If cTable.Count = 1 Then Stop
        If cTable.Count > 0 Then
            If sTableName = "" Then sTableName = CStr(i)
            cVars.Add(cTable, sTableName)

        Endif

        If lpcode = "0" And lpValue = "ENDTAB" Then Break

    Loop

    If cTable.Exist("5") Then
        sid = cTable["5"]
    Else If cTable.Exist("105") Then
        sid = cTable["105"]
    Else If cTable.Exist("2") Then
        sid = cTable["2"]
    Else
        sid = gcd.Newid()

    Endif
    'NewObject(cTable, sHandle)

    'gcd.JSONtoLayers

    Try gcd.debuginfo("DXF: Leidas" & cTable.count & " tablas")

End

Private Sub Load4Blocks(cBlocks As Collection)

    Dim mBlock As Block
    Dim unread As Variant
    Dim i As Integer

    Dim sTableName As String

    Dim cTable, cEntities As Collection

    Dim iCode As Integer, NewKey As String

    ReadData
    Do

        mBlock = New Block

        If lpCode = "0" And lpValue = "ENDSEC" Then Break

        If (lpcode = "0") And (lpvalue = "BLOCK") Then
            Inc i
            cTable = New Collection

            ReadData

            If lpcode = "" Then Break

            While lpcode <> "0"
                NewKey = lpcode
                If cTable.Exist(NewKey) Then
                    Do
                        iCode += 1
                        NewKey = lpcode & "_" & CStr(iCode)

                        If Not cTable.Exist(NewKey) Then Break
                    Loop
                Endif

                If lpcode = Me.codid Then sTableName = lpvalue
                cTable.Add(lpvalue, NewKey)
                ReadData

            Wend    ' fin del encabezado del Block, siguen sus entidades
            'NewObject(cTable, cTable["5"])
            ' si estoy leyendo bloques, significa que estoy abriendo un plano
            cEntities = New Collection
            cTable.Add(cEntities, "entities")

            Load5Entities(cEntities)

            If sTableName = "" Then sTableName = CStr(i)

            cBlocks.Add(cTable, sTableName)

        Endif
    Loop

    gcd.debuginfo("DXF: Leidos " & cBlocks.Count & " bloques")

End

Private Sub Load5Entities(cEntities As Collection)

    Dim sClave As String[]
    Dim sValue As String[]
    Dim sEntidad, sKey As String
    Dim clsidr As Object
    Dim eNueva As Entity
    Dim Reads As Boolean

    Dim cEntity As Collection
    Dim iEntity As Integer

    Dim iCode As Integer, NewKey As String

    Do
        'Debug lpcode, lpvalue
        sClave = New String[]

        sValue = New String[]

        If lpValue = "ENTITIES" Then ReadData
        If lpValue = "ENDSEC" Then Return

        sEntidad = lpValue
        Inc iEntity
        cEntity = New Collection

        cEntity.Add(sEntidad, "0")
        iCode = 0

        ' Leo descentralizadamente las entidades
        ReadData

        'If sEntidad = "HATCH" Then Stop
        While (lpcode <> "0") And Not Eof(fp)

            NewKey = lpcode
            If cEntity.Exist(NewKey) Then
                Do
                    iCode += 1
                    NewKey = lpcode & "_" & CStr(iCode)

                    If Not cEntity.Exist(NewKey) Then Break
                Loop
            Endif

            If sEntidad <> "ENDSEC" Then cEntity.Add(lpvalue, NewKey)
            ReadData

        Wend

        'NewObject(cEntity, cEntity[dxf.codHandle])

        If cEntity.Exist(dxf.codid) Then
            sKey = cEntity[dxf.codid]
        End If
        If sKey = "" Then

            sKey = CStr(iLastid)
            Inc iLastid

        End If

        cEntities.Add(cEntity, sKey)

        If sEntidad = "ENDBLK" Or sEntidad = "ENDSEC" Then Return

    Loop Until Eof(fp)

End

Private Sub Load6Objects(cObjects As Collection)

    Dim sClave As String[]
    Dim sValue As String[]
    Dim sEntidad, h As String
    Dim clsidr As Object
    Dim eNueva As Entity
    Dim Reads As Boolean

    Dim cObject As Collection
    Dim iObject As Integer

    Dim iCode As Integer, NewKey As String

    Do
        'Debug lpcode, lpvalue
        sClave = New String[]

        sValue = New String[]

        If lpValue = "OBJECTS" Then ReadData
        If lpValue = "ENDSEC" Then Return

        sEntidad = lpValue
        Inc iObject
        cObject = New Collection

        cObject.Add(sEntidad, "0")
        iCode = 0

        ' Leo descentralizadamente las entidades
        ReadData

        'If sEntidad = "HATCH" Then Stop
        While (lpcode <> "0") And Not Eof(fp)

            NewKey = lpcode
            If cObject.Exist(NewKey) Then
                Do
                    iCode += 1
                    NewKey = lpcode & "_" & CStr(iCode)

                    If Not cObject.Exist(NewKey) Then Break
                Loop
            Endif
            cObject.Add(lpvalue, NewKey)
            ReadData

        Wend
        'NewObject(cObject, cObject["5"])
        If cObject.Exist("5") Then
            h = cObject["5"]
        Else
            h = CStr(iObject)
        Endif
        cObjects.Add(cObject, h)

        If sEntidad = "ENDBLK" Or sEntidad = "" Then Return

    Loop

End

Private Sub Load7Thumbnail(cThumbnail As Collection)

    Dim iCode As Integer, NewKey As String

    Do

        If lpValue = "ENDSEC" Then Return

        ' Leo descentralizadamente las entidades
        ReadData

        While (lpcode <> "0") And Not Eof(fp)

            NewKey = lpcode
            If cThumbnail.Exist(NewKey) Then
                Do
                    iCode += 1
                    NewKey = lpcode & "_" & CStr(iCode)

                    If Not cThumbnail.Exist(NewKey) Then Break
                Loop
            Endif
            cThumbnail.Add(lpvalue, NewKey)
            ReadData

        Wend

    Loop

End

Public Function SaveFile(sName As String, drwToSAve As Drawing, Optional LoadMinimal As Boolean = False, SaveHeader As Boolean = True, SaveTables As Boolean = True, SaveBlocks As Boolean = True, SaveThumbnail As Boolean = True) As Integer

    hFile = Open sName For Write Create

    iLastid = 0          ' creamos las handles desde cero

    ' Las HANDLES
    ' 0 -> Es el Drawing
    ' 1 -> Es el Block_Record
    ' 2 -> Es la entrada en el Block_Record del model view
    ' Las TABLES tiene su entrada y su owner es el 0=Drawing
    ' Los BLOCKS tienen su handle y su owner es la entrada en el Block_Record
    ' Las entidades tienen su handle y su owner es un BLOCK o el MODEL o algun PAPER, que son bloques tambien

    If SaveHeader Then
        If Save1HeadersAndVarsDirect(drwToSAve.Headers) Then Goto Error1

        If Save2Classes(drwToSAve) Then Goto Error1
    End If
    If SaveTables Then
        If Save3TablesDirect(drwToSAve) Then Goto Error1
    End If
    If SaveBlocks Then
        If Save4BlocksDirect(drwToSAve.Blocks) Then Goto Error1

    End If

    If Save5EntitiesDirect(drwToSAve.Entities) Then Goto Error1
    'If Save6Objects(cData["OBJECTS"]) Then Return False
    If SaveThumbnail Then
        Save7ThumbNail(Null)
    End If

    hFile.Close
    Return drwToSAve.Entities.Count
    'Catch
Error1:
    hFile.Close

    Message.Error(("Error saving file"))
    Return -1

End

Private Function Save1HeadersAndVarsDirect(Headers As Headers) As Integer

    Dim sValues As String
    Dim stxHeaders As String[]

    Print #hFIle, "999"
    Print #hFIle, "GauchoCAD"
    Print #hFIle, "  0"
    Print #hFIle, "SECTION"
    Print #hFIle, "2"
    Print #hFIle, "HEADER"

    stxHeaders = Headers.ExportDXF()

    For Each sValues In stxHeaders
        Print #hFile, sValues
    Next
    Print #hFIle, "  0"
    Print #hFIle, "ENDSEC"

End

' Las classes de cad no las usamos. En teoria, no tienen ninguna utilidad fuera de AutoCAD.
' Abriendo un DXF, se guadaran todas las classes a efectos de recosntruir el DXF.
Private Function Save2Classes(drwSaving As Drawing) As Integer

    Dim cClass As CadClass

    ' Dim i As Integer

    Print #hFIle, "  0"
    Print #hFIle, "SECTION"
    Print #hFIle, "  2"
    Print #hFIle, "CLASSES"

    ' here go all entities
    For Each cClass In drwSaving.CadClasses
        Print #hFIle, "  0"
        Print #hFIle, "CLASS"

        Print #hFile, "  1"
        Print #hFIle, cClass.RecordName

        Print #hFile, "  2"
        Print #hFIle, cClass.CPPName

        Print #hFile, "  3"
        Print #hFIle, cClass.AppName

        Print #hFile, " 90"
        Print #hFIle, CStr(cClass.ProxyCapp)

        Print #hFile, " 91"
        Print #hFIle, CStr(cClass.InstanceCount)

        Print #hFile, "280"
        Print #hFIle, CStr(cClass.ProxyFlag)

        Print #hFile, "281"
        Print #hFIle, CStr(cClass.EntityFlag)

    Next
    ' end section code
    Print #hFIle, "  0"
    Print #hFIle, "ENDSEC"

End

' Private Function Save3Tables(cTables As Collection, drw As Drawing) As Integer
'
'   Dim cTable, cTableEntry, cVar, cVars As Collection
'   Dim sValues, lpclave As String
'   Dim sTableName As String
'   Dim i As Integer
'
'   Print #hFIle, "  0"
'   Print #hFIle, "SECTION"
'   Print #hFIle, "2"
'   Print #hFIle, "TABLES"
'   For Each cTable In cTables
'     sTableName = cTables.Key
'     If sTableName = "__AuxData__" Then Continue
'
'     Print #hFIle, "  0"
'     Print #hFIle, "TABLE"
'     Print #hFIle, "  2"
'     Print #hFIle, sTableName
'     Print #hFIle, "  5"         ' handle
'     ' Else
'     '   Print #hFIle, "105"         ' handle
'     ' End If
'     Print #hFIle, cTables["__AuxData__"][sTableName]           ' valor de la handle
'     Print #hFIle, "  330"
'     Print #hFIle, "0"
'     Print #hFIle, "  100"
'     Print #hFIle, "AcDbSymbolTable"
'     Print #hFIle, "  70"
'     Print #hFIle, CStr(cTable.Count)
'     ' otra particularidad
'     If sTableName = "DIMSTYLE" Then
'       Print #hFIle, "  100"
'       Print #hFIle, "AcDbDimStyleTable"
'       Print #hFIle, "  71"
'       Print #hFIle, CStr(cTable.Count)
'     End If
'     If sTableName = "BLOCK_RECORD" Then
'       save31BlockRecord(drw.oBlocks)
'
'     Else
'
'       If cTable.Count > 0 Then
'         For Each cTableEntry In cTable
'           Print #hFIle, "  0"
'           Print #hFIle, sTableName
'           ' Print #hFIle, "  2"
'           ' Print #hFIle, cTable.Key
'           For Each sValues In cTableEntry
'             lpclave = cTableEntry.Key
'             I = InStr(lpclave, "_")
'             If i > 0 Then lpclave = Left(lpclave, i - 1)
'             Print #hFile, lpclave
'             Print #hFIle, sValues
'           Next
'         Next
'       Endif
'     End If
'     Print #hFIle, "  0"
'     Print #hFIle, "ENDTAB"
'   Next
'   Print #hFIle, "  0"
'   Print #hFIle, "ENDSEC"
'
' End

Private Function Save3TablesDirect(drw As Drawing) As Integer

    Dim cTable, cTableEntry, cVar, cVars As Collection
    Dim sValues, lpclave As String
    Dim sTableid As String
    Dim i As Integer
    ' Empiezo la seccion tables
    Print #hFIle, "  0"
    Print #hFIle, "SECTION"
    Print #hFIle, "2"
    Print #hFIle, "TABLES"

    save31BlockRecord(drw)
    Save3TableViewPorts(drw)
    Save3TableViews(drw)
    Save3TableLineTypes(drw)
    Save3TableLayers(drw)
    Save3TableTextStyles(drw)
    Save3TableUCSs(drw)
    Save3TableAppID(drw)
    Save3TableDimStyles(drw)

    Print #hFIle, "  0"
    Print #hFIle, "ENDSEC"

End

Private Function Save3TableAppID(drw As Drawing) As Integer

    Inc iLastid
    iTableid = iLastid

    Print #hFIle, "  0"
    Print #hFIle, "TABLE"
    Print #hFIle, "  2"
    Print #hFIle, "APPID"
    Print #hFIle, "  5"         ' handle
    Print #hFIle, iLastid
    Print #hFIle, "  330"   ' handle al padre de esta tabla, que es 0 porque pertenece al drawing
    Print #hFIle, "0"
    Print #hFIle, "  100"
    Print #hFIle, "AcDbSymbolTable"
    Print #hFIle, "  70"
    Print #hFIle, CStr(drw.AppIDs.Count)

    ' APPID
    Dim oneAppid As APPID
    For Each oneAppid In drw.AppIDs
        Inc iLastid
        Print #hFIle, "  0"
        Print #hFIle, "APPID"
        Print #hFIle, "  5"                     ' handle propio
        Print #hFIle, iLastid
        Print #hFIle, "  330"                   ' handle del padre
        Print #hFIle, iTableid
        Print #hFIle, "  100"
        Print #hFIle, "AcDbSymbolTableRecord"
        Print #hFIle, "  100"
        Print #hFIle, "AcDbRegAppTableRecord"
        Print #hFIle, "  2"
        Print #hFIle, oneAppid.APPName_2
        Print #hFIle, " 70"
        Print #hFIle, CStr(oneAppid.Flags_70)
    Next
    Print #hFIle, "  0"
    Print #hFIle, "ENDTAB"

End

Private Function Save3TableLayers(drw As Drawing) As Integer

    Inc iLastid
    iTableid = iLastid

    Print #hFIle, "  0"
    Print #hFIle, "TABLE"
    Print #hFIle, "  2"
    Print #hFIle, "LAYER"
    Print #hFIle, "  5"         ' handle
    Print #hFIle, iLastid
    Print #hFIle, "  330"   ' handle al padre de esta tabla, que es 0 porque pertenece al drawing
    Print #hFIle, "0"
    Print #hFIle, "  100"
    Print #hFIle, "AcDbSymbolTable"
    Print #hFIle, "  70"
    Print #hFIle, CStr(drw.Layers.Count)

    Dim oneLayer As Layer
    For Each oneLayer In drw.Layers
        Inc iLastid
        Print #hFIle, "  0"
        Print #hFIle, "LAYER"
        Print #hFIle, "  5"                     ' handle propio
        Print #hFIle, iLastid
        Print #hFIle, "  330"                   ' handle del padre
        Print #hFIle, iTableid
        Print #hFIle, "  100"
        Print #hFIle, "AcDbSymbolTableRecord"
        Print #hFIle, "  100"
        Print #hFIle, "AcDbLayerTableRecord"
        Print #hFIle, "  2"
        Print #hFIle, oneLayer.Name
        Print #hFIle, " 70"                       ' layer flags, bit coded
        Print #hFIle, CStr(-oneLayer.Frozen - oneLayer.Locked * 4)
        Print #hFIle, " 62"
        Print #hFIle, oneLayer.Colour * IIf(oneLayer.Visible, 1, -1)
        Print #hFIle, "  6"
        Print #hFIle, oneLayer.LineType
        Print #hFIle, "290"                   ' plotting flag
        Print #hFIle, IIf(oneLayer.Printable, "1", "0")
        Print #hFIle, "370"                   ' linewt
        Print #hFIle, CStr(oneLayer.LineWt)
        Print #hFIle, "390"                   ' plotstyle object
        Print #hFIle, " "
        Print #hFIle, "347"                   ' material
        Print #hFIle, " "

    Next
    Print #hFIle, "  0"
    Print #hFIle, "ENDTAB"

End

Private Function Save3TableTextStyles(drw As Drawing) As Integer

    Inc iLastid
    iTableid = iLastid

    Print #hFIle, "  0"
    Print #hFIle, "TABLE"
    Print #hFIle, "  2"
    Print #hFIle, "STYLE"
    Print #hFIle, "  5"         ' handle
    Print #hFIle, iLastid
    Print #hFIle, "  330"   ' handle al padre de esta tabla, que es 0 porque pertenece al drawing
    Print #hFIle, "0"
    Print #hFIle, "  100"
    Print #hFIle, "AcDbSymbolTable"
    Print #hFIle, "  70"
    Print #hFIle, CStr(drw.TextStyles.Count)

    Dim oneTextStyle As TextStyle
    For Each oneTextStyle In drw.TextStyles
        Inc iLastid
        Print #hFIle, "  0"
        Print #hFIle, "STYLE"
        Print #hFIle, "  5"                     ' handle propio
        Print #hFIle, iLastid
        Print #hFIle, "  330"                   ' handle del padre
        Print #hFIle, iTableid
        Print #hFIle, "  100"
        Print #hFIle, "AcDbSymbolTableRecord"
        Print #hFIle, "  100"
        Print #hFIle, "AcDbTextStyleTableRecord"
        Print #hFIle, "  2"
        Print #hFIle, oneTextStyle.name
        Print #hFIle, " 70"                       ' flags, bit coded
        Print #hFIle, oneTextStyle.Flags
        Print #hFIle, " 40"
        Print #hFIle, CStr(oneTextStyle.FixedH_40)
        Print #hFIle, " 41"
        Print #hFIle, CStr(oneTextStyle.WidthFactor)
        Print #hFIle, " 50"
        Print #hFIle, CStr(oneTextStyle.ObliqueAngle)
        Print #hFIle, " 71"
        Print #hFIle, CStr(oneTextStyle.iDirection)
        Print #hFIle, " 42"
        Print #hFIle, CStr(oneTextStyle.fLastHeightUsed_42)
        Print #hFIle, "  3"
        Print #hFIle, oneTextStyle.sFont_3
        Print #hFIle, "  4"
        Print #hFIle, oneTextStyle.sBigFont_4

    Next
    Print #hFIle, "  0"
    Print #hFIle, "ENDTAB"

End

Private Function Save3TableDimStyles(drw As Drawing) As Integer

    Inc iLastid
    iTableid = iLastid

    Print #hFIle, "  0"
    Print #hFIle, "TABLE"
    Print #hFIle, "  2"
    Print #hFIle, "DIMSTYLE"
    Print #hFIle, "  5"         ' handle
    Print #hFIle, iLastid
    Print #hFIle, "  330"   ' handle al padre de esta tabla, que es 0 porque pertenece al drawing
    Print #hFIle, "0"
    Print #hFIle, "  100"
    Print #hFIle, "AcDbSymbolTable"
    Print #hFIle, "  70"
    Print #hFIle, CStr(drw.DimStyles.Count)

    Dim oneDimtStyle As DimStyle
    For Each oneDimtStyle In drw.DimStyles
        Inc iLastid
        Print #hFIle, "  0"
        Print #hFIle, "DIMSTYLE"
        Print #hFIle, " 105"                     ' handle propio
        Print #hFIle, iLastid
        Print #hFIle, " 330"                   ' handle del padre
        Print #hFIle, iTableid
        Print #hFIle, " 100"
        Print #hFIle, "AcDbSymbolTableRecord"
        Print #hFIle, " 100"
        Print #hFIle, "AcDbDimStyleTableRecord"
        Print #hFIle, "  2"
        Print #hFIle, oneDimtStyle.name
        Print #hFIle, " 70"                       ' flags, bit coded
        Print #hFIle, "0"                         ' no lo usamos
        SaveCode(3, oneDimtStyle.DIMPOST)
        SaveCode(4, oneDimtStyle.DIMAPOST)
        SaveCode(5, oneDimtStyle.DIMBLK)
        SaveCode(6, oneDimtStyle.DIMBLK1)
        SaveCode(7, oneDimtStyle.DIMBLK2)
        SaveCode(40, oneDimtStyle.DIMSCALE)
        SaveCode(41, oneDimtStyle.DIMASZ)
        SaveCode(42, oneDimtStyle.DIMEXO)
        SaveCode(43, oneDimtStyle.DIMDLI)
        SaveCode(44, oneDimtStyle.DIMEXE)
        SaveCode(45, oneDimtStyle.DIMRND)
        SaveCode(46, oneDimtStyle.DIMDLE)
        SaveCode(47, oneDimtStyle.DIMTP)
        SaveCode(48, oneDimtStyle.DIMTM)
        SaveCode(140, oneDimtStyle.DIMTXT)
        SaveCode(141, oneDimtStyle.DIMCEN)
        SaveCode(142, oneDimtStyle.DIMTSZ)
        SaveCode(143, oneDimtStyle.DIMALTF)
        SaveCode(144, oneDimtStyle.DIMLFAC)
        SaveCode(145, oneDimtStyle.DIMTVP)
        SaveCode(146, oneDimtStyle.DIMTFAC)
        SaveCode(147, oneDimtStyle.DIMGAP)
        SaveCode(148, oneDimtStyle.DIMALTRND)
        SaveCode(71, oneDimtStyle.DIMTOL)
        SaveCode(72, oneDimtStyle.DIMLIM)
        SaveCode(73, oneDimtStyle.DIMTIH)
        SaveCode(74, oneDimtStyle.DIMTOH)
        SaveCode(75, oneDimtStyle.DIMSE1)
        SaveCode(76, oneDimtStyle.DIMSE2)
        SaveCode(77, oneDimtStyle.DIMTAD)
        SaveCode(78, oneDimtStyle.DIMZIN)
        SaveCode(79, oneDimtStyle.DIMAZIN)
        SaveCode(170, oneDimtStyle.DIMALT)
        SaveCode(171, oneDimtStyle.DIMALTD)
        SaveCode(172, oneDimtStyle.DIMTOFL)
        SaveCode(173, oneDimtStyle.DIMSAH)
        SaveCode(174, oneDimtStyle.DIMTIX)
        SaveCode(175, oneDimtStyle.DIMSOXD)
        SaveCode(176, oneDimtStyle.DIMCLRD)
        SaveCode(177, oneDimtStyle.DIMCLRE)
        SaveCode(178, oneDimtStyle.DIMCLRT)
        SaveCode(179, oneDimtStyle.DIMADEC)
        SaveCode(270, oneDimtStyle.DIMUNIT)
        SaveCode(271, oneDimtStyle.DIMDEC)
        SaveCode(272, oneDimtStyle.DIMTDEC)
        SaveCode(273, oneDimtStyle.DIMALTU)
        SaveCode(274, oneDimtStyle.DIMALTTD)
        SaveCode(275, oneDimtStyle.DIMAUNIT)
        SaveCode(276, oneDimtStyle.DIMFRAC)
        SaveCode(277, oneDimtStyle.DIMLUNIT)
        SaveCode(278, oneDimtStyle.DIMDSEP)
        SaveCode(279, oneDimtStyle.DIMTMOVE)
        SaveCode(280, oneDimtStyle.DIMJUST)
        SaveCode(281, oneDimtStyle.DIMSD1)
        SaveCode(282, oneDimtStyle.DIMSD2)
        SaveCode(283, oneDimtStyle.DIMTOLJ)
        SaveCode(284, oneDimtStyle.DIMTZIN)
        SaveCode(285, oneDimtStyle.DIMALTZ)
        SaveCode(286, oneDimtStyle.DIMALTTZ)
        SaveCode(287, oneDimtStyle.DIMFIT)
        SaveCode(288, oneDimtStyle.DIMUPT)
        SaveCode(289, oneDimtStyle.DIMATFIT)
        SaveCode(340, oneDimtStyle.DIMTXSTY)
        SaveCode(341, oneDimtStyle.DIMLDRBLK)
        SaveCode(342, oneDimtStyle.DIMBLK)
        SaveCode(343, oneDimtStyle.DIMBLK1)
        SaveCode(344, oneDimtStyle.DIMBLK2)
        SaveCode(371, oneDimtStyle.DIMLWD)
        SaveCode(372, oneDimtStyle.DIMLWE)

    Next
    Print #hFIle, "  0"
    Print #hFIle, "ENDTAB"

End

Private Function Save3TableLineTypes(drw As Drawing) As Integer

    Inc iLastid
    iTableid = iLastid

    Print #hFIle, "  0"
    Print #hFIle, "TABLE"
    Print #hFIle, "  2"
    Print #hFIle, "LTYPE"
    Print #hFIle, "  5"         ' handle
    Print #hFIle, iLastid
    Print #hFIle, "  330"   ' handle al padre de esta tabla, que es 0 porque pertenece al drawing
    Print #hFIle, "0"
    Print #hFIle, "  100"
    Print #hFIle, "AcDbSymbolTable"
    Print #hFIle, "  70"
    Print #hFIle, CStr(drw.LineTypes.Count)

    Dim oneLtype As LineType
    For Each oneLtype In drw.LineTypes
        Inc iLastid
        Print #hFIle, "  0"
        Print #hFIle, "LTYPE"
        Print #hFIle, "  5"                     ' handle propio
        Print #hFIle, iLastid
        Print #hFIle, "  330"                   ' handle del padre
        Print #hFIle, iTableid
        Print #hFIle, "  100"
        Print #hFIle, "AcDbSymbolTableRecord"
        Print #hFIle, "  100"
        Print #hFIle, "AcDbLinetypeTableRecord"
        SaveCode(2, oneLtype.Name)
        SaveCode(70, oneLtype.Flags)
        SaveCode(3, oneLtype.Description)
        SaveCode(72, 65)                    ' para compatibilidad
        SaveCode(73, oneLtype.nTrames)
        SaveCode(40, CStr(oneLtype.Length))
        For Each fLenght As Float In oneLtype.TrameLength
            SaveCode(49, CStr(fLenght))
        Next

        ' Hay tipos de linea mas complejos, que se generan con codigos que GauchoCAD no maneja de momento

    Next
    Print #hFIle, "  0"
    Print #hFIle, "ENDTAB"

End

Private Function Save3TableUCSs(drw As Drawing) As Integer

    Inc iLastid
    iTableid = iLastid

    Print #hFIle, "  0"
    Print #hFIle, "TABLE"
    Print #hFIle, "  2"
    Print #hFIle, "UCS"
    Print #hFIle, "  5"         ' handle
    Print #hFIle, iLastid
    Print #hFIle, "  330"   ' handle al padre de esta tabla, que es 0 porque pertenece al drawing
    Print #hFIle, "0"
    Print #hFIle, "  100"
    Print #hFIle, "AcDbSymbolTable"
    Print #hFIle, "  70"
    Print #hFIle, CStr(drw.UCSs.Count)

    Dim oneUCS As UCS
    For Each oneUCS In drw.UCSs
        Inc iLastid
        Print #hFIle, "  0"
        Print #hFIle, "UCS"
        Print #hFIle, "  5"                     ' handle propio
        Print #hFIle, iLastid
        Print #hFIle, "  330"                   ' handle del padre
        Print #hFIle, iTableid
        Print #hFIle, "  100"
        Print #hFIle, "AcDbSymbolTableRecord"
        Print #hFIle, "  100"
        Print #hFIle, "AcDbUCSTableRecord"
        SaveCode(2, oneUCS.Name_2)
        SaveCode(70, oneUCS.Flags_70)
        SaveCode(10, oneUCS.OriginX_10)
        SaveCode(20, oneUCS.OriginY_20)
        SaveCode(30, oneUCS.OriginZ_30)

        SaveCode(11, oneUCS.XAxisX_11)
        SaveCode(21, oneUCS.XAxisY_21)
        SaveCode(31, oneUCS.XAxisZ_31)

        SaveCode(12, oneUCS.YAxisX_12)
        SaveCode(22, oneUCS.YAxisY_22)
        SaveCode(32, oneUCS.YAxisZ_32)

        SaveCode(79, 0)

        SaveCode(146, oneUCS.Elevation_146)
        SaveCode(346, oneUCS.BaseUCS_346)

        SaveCode(13, oneUCS.OriginForThisOrthographicTypeX_13)
        SaveCode(23, oneUCS.OriginForThisOrthographicTypeY_23)
        SaveCode(33, oneUCS.OriginForThisOrthographicTypeZ_33)

    Next
    Print #hFIle, "  0"
    Print #hFIle, "ENDTAB"

End

Private Function Save3TableViews(drw As Drawing) As Integer

    Inc iLastid
    iTableid = iLastid

    Print #hFIle, "  0"
    Print #hFIle, "TABLE"
    Print #hFIle, "  2"
    Print #hFIle, "VIEW"
    Print #hFIle, "  5"         ' handle
    Print #hFIle, iLastid
    Print #hFIle, "  330"   ' handle al padre de esta tabla, que es 0 porque pertenece al drawing
    Print #hFIle, "0"
    Print #hFIle, "  100"
    Print #hFIle, "AcDbSymbolTable"
    Print #hFIle, "  70"
    Print #hFIle, CStr(drw.Views.Count)

    Dim oneView As View, sData As String
    For Each oneView In drw.Views
        Inc iLastid
        Print #hFIle, "  0"
        Print #hFIle, "VIEW"
        Print #hFIle, "  5"                     ' handle propio
        Print #hFIle, iLastid
        Print #hFIle, "  330"                   ' handle del padre
        Print #hFIle, iTableid
        Print #hFIle, "  100"
        Print #hFIle, "AcDbSymbolTableRecord"
        Print #hFIle, "  100"
        Print #hFIle, "AcDbViewTableRecord"
        For Each sData In oneView.Datos
            Print #hFIle, sData
        Next

    Next
    Print #hFIle, "  0"
    Print #hFIle, "ENDTAB"

End

Private Function Save3TableViewPorts(drw As Drawing) As Integer

    Inc iLastid
    iTableid = iLastid

    Print #hFIle, "  0"
    Print #hFIle, "TABLE"
    Print #hFIle, "  2"
    Print #hFIle, "VPORT"
    Print #hFIle, "  5"         ' handle
    Print #hFIle, iLastid
    Print #hFIle, "  330"   ' handle al padre de esta tabla, que es 0 porque pertenece al drawing
    Print #hFIle, "0"
    Print #hFIle, "  100"
    Print #hFIle, "AcDbSymbolTable"
    Print #hFIle, "  70"
    Print #hFIle, CStr(drw.Viewports.Count)

    Dim oneViewport As Viewport, sData As String
    For Each oneViewport In drw.Viewports
        Inc iLastid
        Print #hFIle, "  0"
        Print #hFIle, "VPORT"
        Print #hFIle, "  5"                     ' handle propio
        Print #hFIle, iLastid
        Print #hFIle, "  330"                   ' handle del padre
        Print #hFIle, iTableid
        Print #hFIle, "  100"
        Print #hFIle, "AcDbSymbolTableRecord"
        Print #hFIle, "  100"
        Print #hFIle, "AcDbViewportTableRecord"
        For Each sData In oneViewport.Datos
            Print #hFIle, sData
        Next

    Next
    Print #hFIle, "  0"
    Print #hFIle, "ENDTAB"

End

Private Function save31BlockRecord(drw As Drawing) As Integer

    Dim eBlock As Block

    Inc iLastid ' deberia ser = 1 aqui
    iTableid = iLastid

    Block_Record = New Collection

    Print #hFIle, "  0"
    Print #hFIle, "TABLE"
    Print #hFIle, "  2"
    Print #hFIle, "BLOCK_RECORD"
    Print #hFIle, "  5"         ' handle
    Print #hFIle, iLastid
    Print #hFIle, "  330"   ' handle al padre de esta tabla, que es 0 porque pertenece al drawing
    Print #hFIle, "0"
    Print #hFIle, "  100"
    Print #hFIle, "AcDbSymbolTable"
    Print #hFIle, "  70"
    Print #hFIle, CStr(drw.Blocks.Count)

    For Each eBlock In drw.Blocks
        Inc iLastid
        Block_Record.Add(iLastid, eBlock.name)
        Print #hFIle, "  0"
        Print #hFIle, "BLOCK_RECORD"
        Print #hFIle, "  5"         ' handle
        Print #hFIle, iLastid
        Print #hFIle, " 330"
        Print #hFIle, iTableid
        Print #hFIle, " 100"
        Print #hFIle, "AcDbSymbolTableRecord"
        Print #hFIle, " 100"
        Print #hFIle, "AcDbBlockTableRecord"
        Print #hFIle, "  2"
        Print #hFIle, eBlock.name
        Print #hFIle, " 340"
        Print #hFIle, "0" 'eBlock.HandleAsociatedLayout
        Print #hFIle, "  70"
        Print #hFIle, eBlock.InsertUnits
        Print #hFIle, " 280"
        Print #hFIle, eBlock.Explotability
        Print #hFIle, " 281"
        Print #hFIle, eBlock.Scalability

    Next
    Print #hFIle, "  0"
    Print #hFIle, "ENDTAB"

End

Private Function Save4BlocksDirect(eBlocks As Collection) As Integer

    Dim i As Integer, bCan As Boolean
    Dim iii As Integer
    Dim eBlock As Block, stxEnty As New String[], eEnty As Entity
    Dim sValues, lpclave As String

    Print #hFIle, "  0"
    Print #hFIle, "SECTION"
    Print #hFIle, "2"
    Print #hFIle, "BLOCKS"
    For Each eBlock In eBlocks
        Inc iLastid
        Print #hFIle, "  0"
        Print #hFIle, "BLOCK"
        Print #hFIle, "  5"         ' handle
        Print #hFIle, iLastid 'eBlock.handle          ' valor de la handle
        Print #hFIle, "  330"
        Print #hFIle, Block_Record[eBlock.name]
        Print #hFIle, "  100"
        Print #hFIle, "AcDbEntity"
        Print #hFIle, " 8"          ' layer name
        Print #hFIle, eBlock.layer
        Print #hFIle, "100"
        Print #hFIle, "AcDbBlockBegin"
        Print #hFIle, "  2"
        Print #hFIle, eBlock.name
        Print #hFIle, "  70"
        Print #hFIle, eBlock.Flags
        Print #hFIle, codX0
        Print #hFIle, eBlock.x0
        Print #hFIle, cody0
        Print #hFIle, eBlock.y0
        Print #hFIle, codz0
        Print #hFIle, eBlock.z0
        Print #hFIle, "  3"
        Print #hFIle, eBlock.name
        Print #hFIle, "  1"
        Print #hFIle, ""            ' X ref path
        If eBlock.entities.Count > 0 Then

            For Each eEnty In eBlock.entities
                stxEnty = New String[]

                If Gcd.CCC[eEnty.gender].DXF_export Then
                    clsEntities.DXFExportCommonCol(eEnty, stxEnty)
                    Gcd.CCC[eEnty.gender].ExportDXFCol(eEnty, stxEnty)
                Else    ' trato de exportar como vino

                    gcd.debugInfo(("No puedo guardar este tipo de entidades ") & eEnty.Gender,,, True)
                End If
                For i = 0 To stxEnty.max Step 2
                    lpclave = stxEnty[i + 1]
                    sValues = stxEnty[i]
                    If lpclave = "330" Then lpvalue = iLastid
                    Print #hFile, lpclave
                    Print #hFIle, sValues
                Next
            Next

            ' que pasa con el ENDBLK?
            ' Al leer, lo guardo como una entidad y, por lo tanto lo tengo en el bloque, pero...corresponde?
            ' no seria mejor generarlo? al fin y al cabo es solo una seÃ±al para el lector de archivos (como el SEQEND)

        Endif

    Next
    Print #hFIle, "  0"
    Print #hFIle, "ENDSEC"

End

Private Function Save5EntitiesDirect(eEntys As Collection) As Integer

    Dim stxEnty As String[]
    Dim eEnty As Entity
    Dim sValues, lpclave As String
    Dim i As Integer, bCan As Boolean

    Print #hFIle, "  0"
    Print #hFIle, "SECTION"
    Print #hFIle, "  2"
    Print #hFIle, "ENTITIES"

    ' here go all entities
    For Each eEnty In eEntys
        stxEnty = New String[]
        ' veo si lo tengo

        bCan = Gcd.CCC[eEnty.gender].DXF_export
        If bCan Then
            clsEntities.DXFExportCommonCol(eEnty, stxEnty)
            Gcd.CCC[eEnty.gender].ExportDXFCol(eEnty, stxEnty)
        Else    ' trato de exportar como vino

            gcd.debugInfo(("No puedo guardar este tipo de entidades ") & eEnty.Gender,,, True)
        End If
        For i = 0 To stxEnty.max Step 2
            lpclave = stxEnty[i + 1]
            sValues = stxEnty[i]
            Print #hFile, lpclave
            Print #hFIle, sValues
        Next

    Next
    ' end section code
    Print #hFIle, "  0"
    Print #hFIle, "ENDSEC"

End

Private Function Save6Objects(cObjects As Collection) As Integer

    Dim sValues, lpclave As String
    Dim i As Integer

    Dim cObject As Collection

    Print #hFIle, "  0"
    Print #hFIle, "SECTION"
    Print #hFIle, "2"
    Print #hFIle, "OBJECTS"
    For Each cObject In cObjects
        For Each sValues In cObject
            lpclave = cObject.Key
            I = InStr(lpclave, "_")
            If i > 0 Then lpclave = Left(lpclave, i - 1)
            Print #hFile, lpclave
            Print #hFIle, sValues
        Next
    Next
    ' end section code
    Print #hFIle, "  0"
    Print #hFIle, "ENDSEC"

End

Private Function Save7ThumbNail(imgGLArea As Image) As Integer

    Dim sValues, lpclave As String
    Dim i As Integer
    Dim cThumbs As Collection

    Print #hFIle, "  0"
    Print #hFIle, "SECTION"
    Print #hFIle, "2"
    Print #hFIle, "THUMBNAILIMAGE"
    ' cThumbs = cData["THUMBNAILIMAGE"]
    ' If Not IsNull(cThumbs) Then
    '   For Each sValues In cThumbs
    '     lpclave = cThumbs.Key
    '     I = InStr(lpclave, "_")
    '     If i > 0 Then lpclave = Left(lpclave, i - 1)
    '     Print #hFile, lpclave
    '     Print #hFIle, sValues
    '   Next
    ' End If
    ' ' end section code
    Print #hFIle, "  0"
    Print #hFIle, "ENDSEC"

    ' end file code
    Print #hFIle, "  0"
    Print #hFIle, "EOF"

End

'   Helper para leer DXF: retorna la posicion en la que encontro la clave o -1 si no la encontro
'   iCode = el codigo DXF
'   stxClaves = array de claves DXF
'   stxValues = array de valores DXF
'   RetValue = el valor a retornar, pasado por referencia
'   iStartPos = la posivion inicial en los array para la busqueda (def = 0)
'   ExactPos = si se busca solo en la posicion inicial (def = false)
Public Function ReadCode(iCode As Integer, stxClaves As String[], stxValues As String[], ByRef RetValue As Variant, Optional iStartPos As Integer = 0, ExactPos As Boolean = False) As Integer

    Dim i, iMax As Integer

    If stxClaves.max <> stxValues.max Then
        Debug "ReadCode: error, bad lists"
        Return -1
    Endif
    If ExactPos Then iMax = iStartPos Else imax = stxClaves.Max
    For i = iStartPos To iMax
        If CInt(stxClaves[i]) = iCode Then
            Select Case TypeOf(RetValue)
                Case gb.Integer
                    RetValue = CInt(stxValues[i])
                    Return i
                Case gb.Float
                    RetValue = CFloat(stxValues[i])
                    Return i
                Case gb.String
                    RetValue = stxValues[i]
                    Return i
            End Select

        Endif
    Next
    Return -1

End
'   Helper para leer DXF: retorna la posicion en la que encontro la clave, -posicion si encotro el escape o 0 si no la encontro
'   iCode = el codigo DXF
'   stxClaves = array de claves DXF
'   stxValues = array de valores DXF
'   RetValue = el valor a retornar, pasado por referencia
'   iStartPos = la posicion inicial en los array para la busqueda (def = 0)
'   iEscapeCode = si encuentra este codigo, sale

Public Function ReadCodePlus(iExpectedCode As Integer, stxClaves As String[], stxValues As String[], ByRef RetValue As Variant, Optional iStartPos As Integer = 0, iEscapeCode As Integer = -1) As Integer

    Dim i, iMax As Integer

    If stxClaves.max <> stxValues.max Then
        Debug "ReadCode: error, bad lists"
        Return -1
    Endif
    'If ExactPos Then iMax = iStartPos Else imax = stxClaves.Max
    For i = iStartPos To stxClaves.max
        If CInt(stxClaves[i]) = iExpectedCode Then
            Select Case TypeOf(RetValue)
                Case gb.Integer
                    RetValue = CInt(stxValues[i])

                Case gb.Float
                    RetValue = CFloat(stxValues[i])

                Case gb.String
                    RetValue = stxValues[i]

            End Select

            Return i + 1
        Else If CInt(stxClaves[i]) = iEscapeCode Then
            Select Case TypeOf(RetValue)
                Case gb.Integer
                    RetValue = 0

                Case gb.Float
                    RetValue = 0

                Case gb.String
                    RetValue = ""

            End Select

            Return -i
        Else If iEscapeCode = -1 Then
            Select Case TypeOf(RetValue)
                Case gb.Integer
                    RetValue = 0

                Case gb.Float
                    RetValue = 0

                Case gb.String
                    RetValue = ""

            End Select

            Return -i

        Endif
    Next
    Return 0

End

'' Lee el codigo de la coleccion que se importa del DXF, puede ignorar lo que esta entre llaves {} que es info de ACAD privativa y puede empezar desde el ultimo leido antes
Public Function ReadCodeFromCol(cDxfEntityData As Collection, iCode As Integer, Optional ReadNext As Boolean = False, IgnoreAcadData As Boolean = True, vDefaultValue As Variant = "") As String

    Dim s, sKey As String, i, p As Integer, valid, OpenedSection As Boolean

    For Each s In cDxfEntityData
        Inc i

        If ReadNext Then
            If i < LastCodeReadIndex Then
                valid = False
            Else
                valid = True
            Endif
        Else
            valid = True

        End If

        If Left(s, 1) = "{" Then
            OpenedSection = True

        End If

        If Left(s, 1) = "}" And OpenedSection Then
            OpenedSection = False

        End If

        If valid And Not OpenedSection Then
            sKey = cDxfEntityData.Key
            ' elimino el posible _
            p = InStr(sKey, "_")
            If p > 0 Then
                sKey = Left(sKey, p - 1)
            Endif
            If CInt(skey) = iCode Then
                LastCodeReadIndex = i
                Return s
            End If
        End If

    Next

    Return CStr(vDefaultValue)

End

Private Sub SaveCode(sCode As Variant, sValue As Variant)

    Dim sToPrint As String

    Print #hFIle, Format(sCode, "###0")
    ' If IsFloat(sValue) Then
    '   sToPrint = CStr(svalue)
    ' Else
    '   sToPrint = svalue
    ' Endif
    Print #hFIle, CStr(svalue)

End Sub

' '' Adds a new object to object by handle collection
' Private Sub NewObject(drw As Drawing, oNew As Variant, sHandle As String)
'
'     If sHandle = "" Then Return
'
'     If drw.Handles.Exist(sHandle) Then
'         gcd.debugInfo("WARNING: Handle repedida " & sHandle)
'     Else
'
'         drw.handles.Add(oNew, sHandle)
'     End If
'
' End

'' Reads layers collection and puts data in oLayers
Public Sub ReadViewports(cVptData As Collection, drw As Drawing)

    Dim vNew As Viewport

    ' ' primero eliminamos lo q haya
    If Not cVptData["TABLES"].Exist("VPORT") Then Return
    Drw.Viewports.Clear
    For Each cViewp As Collection In cVptData["TABLES"]["VPORT"]
        vNew = New Viewport
        ' hLay.Name = cLay[dxf.codName]
        ' hLay.Visible = CInt(cLay[dxf.codColor]) >= 0
        ' hLay.Colour = Abs(CInt(cLay[dxf.codColor]))
        ' hLay.handle = cLay[dxf.codHandle]
        ' If hLay.handle = "" Then hLay.handle = gcd.NewHandle()
        ' Drw.oLayers.Add(hLay, hLay.handle)
    Next

    ' ' es inaceptable no tener al menos un layrr
    ' If drw.oLayers.Count = 0 Then
    '     hLay = New Layer
    '     hLay.Name = "0"
    '     hLay.Visible = True
    '     hLay.Colour = 0
    '     hLay.handle = gcd.NewHandle()
    '     Drw.oLayers.Add(hLay, hLay.handle)
    ' Endif
    '
    ' ' aprovecho para setear el layer actual
    ' Drw.CurrLayer = Drw.oLayers[Drw.oLayers.First]

End

'' Reads layers collection and puts data in oLayers
Public Sub ReadLayers(cLaydata As Collection, drw As Drawing)

    Dim hLay As Layer

    ' ' primero eliminamos lo q haya
    Drw.Layers.Clear
    For Each cLay As Collection In cLayData["TABLES"]["LAYER"]
        hLay = New Layer
        hLay.Name = cLay[dxf.codName]
        hLay.id = cLay[dxf.codid]
        hLay.Visible = CInt(cLay[dxf.codColor]) >= 0
        hLay.Colour = Abs(CInt(cLay[dxf.codColor]))
        hLay.LineType = drw.LineTypes[cLay[Me.codLType]]
        'depre hLay.handle = cLay[dxf.codHandle]
        ' If hLay.handle = "" Then hLay.handle = gcd.NewHandle()
        Drw.Layers.Add(hLay, hLay.Name)
    Next

    ' es inaceptable no tener al menos un layrr
    If drw.Layers.Count = 0 Then
        hLay = New Layer
        hLay.Name = "0"
        hLay.Visible = True
        hLay.Colour = 0
        hLay.LineType = drw.LineTypes[drw.LineTypes.First]
        'depre hLay.handle = gcd.NewHandle()
        Drw.Layers.Add(hLay, hLay.Name)
    Endif

    ' aprovecho para setear el layer actual
    Drw.CurrLayer = Drw.Layers[Drw.Layers.First]

End

'' Reads Styles and DimStyles collection and puts data in arrStyles
Public Sub ReadStyles(cData As Collection, drw As Drawing)

    Dim hlty As TextStyle
    Dim t, i As Integer
    Dim fTrameLength As Float
    Dim sH2, sNextKey As String
    Dim RefStyle As TextStyle
    Dim hdim As DimStyle
    Dim n As String

    ' primero eliminamos lo q haya
    Drw.TextStyles.Clear
    ' Leo los styles de texto
    For Each c As Collection In cData["TABLES"]["STYLE"]
        hlty = New TextStyle

        hlty.Name = c[dxf.codName]
        'hlty.handle = c[dxf.codHandle]

        hlty.sFont_3 = c["3"]

        hlty.FixedH_40 = CFloat(c["40"])

        ' Esto no puede usarse asi, LastHeightUsed_2 es solo un dato de historial
        ' If hlty.FixedH_40 = 0 Then hlty.FixedH_40 = CFloat(c["42"])

        If hlty.name <> "" Then
            n = hlty.name
        Else If hlty.sFont_3 <> "" Then
            n = hlty.sFont_3
        Else
            Continue
        End If

        Drw.TextStyles.Add(hlty, n)

    Next

    ' Leo lo styles de dimensiones
    If cData["TABLES"].Exist("DIMSTYLE") Then
        For Each c As Collection In cData["TABLES"]["DIMSTYLE"]
            hdim = New DimStyle

            hdim.Name = c[dxf.codName]
            ' If IsNull(c[dxf.codHandle]) Then
            '     hdim.handle = c["105"]
            ' Else
            '     hdim.handle = c[dxf.codHandle]
            ' Endif ' depre

            Try hdim.DIMASZ = CFloat(c["41"])
            If hdim.DIMASZ = 0 Then hdim.DIMASZ = 1

            Try hdim.DIMTXT = CFloat(c["140"])
            If hdim.DIMTXT = 0 Then hdim.DIMTXT = 1

            Try hdim.DIMTXSTY = c["340"]

            If hdim.DIMTXSTY <> "" Then
                RefStyle = gcd.FindStyleByid(hdim.DIMTXSTY)
                If Not IsNull(RefStyle) Then
                    If RefStyle.FixedH_40 > 0 Then hdim.DIMTXT = RefStyle.FixedH_40
                    hdim.DIMTXSTY = RefStyle.sFont_3
                Endif
            Endif

            If hdim.name <> "" Then Drw.DimStyles.Add(hdim, hdim.name)

        Next
    End If

End

'' Reads LineTypes collection and puts data in arrLTypes
Public Sub ReadLTypes(cData As Collection, drw As Drawing)

    Dim hlty As LineType
    Dim t, i, ri As Integer
    Dim fTrameLength As Float
    Dim sNextKey, r As String
    Dim AbsoluteRotation, IsText, IsShape As Boolean

    ' primero eliminamos lo q haya
    Drw.LineTypes.Clear
    For Each c As Collection In cData["TABLES"]["LTYPE"]
        hlty = New LineType
        hlty.Name = c[dxf.codName]
        hlty.Description = c["3"]
        ' hlty.handle = c[dxf.codHandle] ' depre
        ' If hLty.handle = "" Then hLty.handle = gcd.NewHandle()
        Try hlty.nTrames = CInt(c["73"])
        If hlty.nTrames > 0 Then hlty.Length = CFloat(dxf.ReadCodeFromCol(c, 40))
        i = 0
        For t = 1 To hlty.nTrames

            r = dxf.ReadCodeFromCol(c, 49, True)
            hlty.TrameLength.Add(CFloat(r))
            ri = CInt(dxf.ReadCodeFromCol(c, 74, True,, 0))
            hlty.TrameType.Add(ri)
            Select Case ri
                Case 0
                    ' nada
                Case Else
                    If (ri And 1) = 1 Then AbsoluteRotation = True Else absoluterotation = False
                    If (ri And 2) = 2 Then IsText = True Else IsText = False
                    If (ri And 4) = 4 Then IsShape = True Else IsShape = False
                    hlty.TrameData.Add(dxf.ReadCodeFromCol(c, 75, True))
                    hlty.TrameStyle.Add(dxf.ReadCodeFromCol(c, 340, True))
                    hlty.TrameScale.Add(dxf.ReadCodeFromCol(c, 46, True))
                    hlty.TrameRotation.Add(dxf.ReadCodeFromCol(c, 50, True))
                    hlty.TrameOffX.Add(dxf.ReadCodeFromCol(c, 44, True))
                    hlty.TrameStyle.Add(dxf.ReadCodeFromCol(c, 45, True))
                    hlty.TrameData.Add(dxf.ReadCodeFromCol(c, 9, True))

            End Select

        Next

        Drw.LineTypes.Add(hlty, hlty.Name)

    Next
    If DRW.LineTypes.Count = 0 Then
        hlty = New LineType
        hlty.Name = "CONTINUOUS"
        hlty.Description = ""
        'hlty.handle = gcd.NewHandle()
        hlty.nTrames = 0
        drw.LineTypes.Add(hlty, hlty.Name)

    End If

    Drw.CurrLineType = Drw.LineTypes[Drw.LineTypes.First]

End

Public Sub ImportBlocksFromDXF(colData As Collection, drw As Drawing) ', obxEntities As Entity[]) As Integer

    Dim iTotalEntities As Integer, colent, colBlk As Collection, flxPoints As New Float[], P As Float[]
    Dim hBlock As String
    Dim cParent As Collection, cEntyList As New Collection
    Dim hEnty As Variant, iEnty As Integer
    Dim cEnty As Variant[]
    Dim i As Integer
    Dim S As New Sheet
    Dim newBlock As Block

    If Not colData.Exist("BLOCKS") Then Return
    ' For Each colBlk In colData["TABLES"]["BLOCK_RECORD"]
    '     Dim newBlock As New Block
    '     newBlock.entities = New Collection
    '     newBlock.name = colBlk[dxf.codName]
    '     newBlock.handle = colBlk[dxf.codHandle]
    '     newBlock.HandleOwnerParent = colBlk[dxf.codHandleOwner]
    '     newBlock.HandleAsociatedLayout = colBlk["340"]
    '     Try newBlock.InsertUnits = colBlk["70"]
    '     Try newBlock.Explotability = colBlk["280"]
    '     Try newBlock.Scalability = colBlk["281"]
    '     drw.oBlocks.Add(newBlock, newBlock.handle)
    '
    ' Next
    ' hay DXF sin TAbles
    If colData.Exist("TABLES") Then

        For Each colBlk In colData["BLOCKS"]
            newBlock = New Block
            newBlock.id = colBlk[dxf.codid]
            newBlock.entities = New Collection
            newBlock.name = colBlk[dxf.codName]
            newBlock.layer = colBlk[dxf.codLayer]
            Try newBlock.x0 = colBlk[dxf.codX0]
            Try newBlock.y0 = colBlk[dxf.codY0]
            Try newBlock.z0 = colBlk[dxf.codZ0]
            Try newBlock.flags = colBlk["70"]

            If colData["TABLES"].Exist("BLOCK_RECORD") Then
                If colData["TABLES"]["BLOCK_RECORD"].Exist(colBlk["330"]) Then
                    newBlock.idContainer = colData["TABLES"]["BLOCK_RECORD"][colBlk["330"]]["5"]
                    newBlock.idAsociatedLayout = colData["TABLES"]["BLOCK_RECORD"][colBlk["330"]]["340"]
                End If
            End If

            Drw.Blocks.Add(newBlock, newBlock.name)
        Next
    End If

    ' voy a hacer un chequeo final, porque algunos DXF vienen sin el bloque Model
    If Drw.Sheets.Count = 0 Then
        ' creo la Sheet
        S = New Sheet
        s.Name = "Model"
        s.IsModel = True
        'depre  s.Handle = "2"
        Drw.Sheets.Add(s, s.Name)
        drw.Sheet = s

        ' creo ql bloque

        newBlock = New Block
        newBlock.entities = New Collection
        newBlock.name = "*Model_Space"
        Drw.Blocks.Add(newBlock, newBlock.name)

    End If

    'Block_Record = New Collection

    If colData.Exist("BLOCKS") Then
        For Each colBlk In colData["BLOCKS"]

            If colBlk.Exist("entities") And Drw.Blocks.Exist(colBlk[dxf.codName]) Then

                DXFtoEntity(colBlk["entities"], colData, drw, Drw.Blocks[colBlk[dxf.codName]].entities)

            Else

                Debug "Error loading block", newBlock.name

            End If
            Inc i

        Next
    End If

End

Public Sub SetViewports(cDxfData As Collection, drw As Drawing)

    Dim e As Entity, v As Viewport, n, hLayout As String, s As Sheet, b As Block

    For Each b In drw.Blocks
        If drw.Sheets.Exist(b.idAsociatedLayout) Then
            For Each e In b.entities
                drw.Sheets[b.idAsociatedLayout].entities.Add(e, e.id)
                ' Try n = cDxfData["BLOCKS"][b.name]["2"]                      ' nombre del bloque
                ' Try hLayout = cDxfData["TABLES"]["BLOCK_RECORD"][n]["340"]
                ' If hLayout <> "" Then
                '     s.Entities = b.entities
                '
                '
            Next
        End If

    Next
    For Each s In drw.Sheets
        For Each e In s.entities
            If e.Gender = cadViewport.Gender Then
                s.Viewports.Add(e.pBlock, e.id)
                'cadViewport.SetViewport(e, s)
            Endif
        Next
    Next

    'Next

End

'' Importa las cosas de manera descentralizada
Public Sub DXFtoEntity(cDxfEntities As Collection, cDxfData As Collection, drw As Drawing, Optional cEntity As Collection, Newids As Boolean = False)

    Dim e, obx, cLastParent As Collection
    Dim entNueva As Entity
    Dim flgIsPolyline, IsDummy As Boolean
    Dim pBlockPolyline, b As Block
    Dim sid, sName As String

    Dim fTime As Float
    Dim t As Date
    Dim hContainer As Variant

    For Each e In cDxfEntities                                              ' Para cada Coleccion de datos de vrx
        If e.Exist(dxf.codEntity) Then                                     ' es una entidad?
            ' entonces, creamos una nueva
            ' poner en minuscula para anular la entidad
            If InStr("VIEWPORT LEADER HATCH POLYLINE ENDBLK SEQEND VERTEX POINT ATTDEF ATTRIB LINE LWPOLYLINE CIRCLE ELLIPSE ARC TEXT MTEXT SPLINE SOLID INSERT DIMENSION DIMENSION_LINEAR DIMENSION_DIAMETEr DIMENSION_RADIUs DIMENSION_ANG3Pt DIMENSION_ALIGNED DIMENSION_ORDINATE LARGE_RADIAL_DIMENSION ARC_DIMENSION", UCase(e[dxf.codEntity])) = 0 Then IsDummy = True Else IsDummy = False
            'If UCase(e[dxf.codEntity]) = "INSERT" Then Stop

            If IsDummy Then
                ' no esta implementada
                gcd.debuginfo("Entidad no implementada o con errores: " & e[dxf.codId] & "," & e[dxf.codEntity])

            Else

                t = Timer

                entNueva = clsEntities.DXFImportToEntity(e, IsDummy)

                If IsNull(entNueva) Then Continue        ' si esta implementada, llenamos los datos
                If entNueva.Gender = cadEndBlk.Gender Then Continue
                'stats
                If Not ReadTimes.Exist(entNueva.Gender) Then ReadTimes.Add(fTime, entNueva.Gender)
                If Not ReadEntities.Exist(entNueva.Gender) Then ReadEntities.Add(1, entNueva.Gender)

                If NewIds Or (entNueva.Id = "") Then
                    sId = gcd.NewId()
                    entNueva.Id = sId
                Else
                    sId = entNueva.Id
                End If
                If flgIsPolyline Then
                    pBlockPolyline.entities.Add(entNueva, sId)
                Else
                    If cEntity Then                                         ' el contenedor fue provisto
                        obx = cEntity
                    Else                                                    ' busco el contenedor de esta entidad
                        hContainer = ReadCodeFromCol(e, 330)                 ' esto puede ser un:
                        'If ReadCodeFromCol(e, 5) = "129D" Then Stop
                        'Debug "Contenedor", hContainer
                        ' -hBlock-Record
                        ' -hInsert
                        ' -hHatch               OTRA ENTIDAD que tenga .pBlock.enities as Collection
                        ' -Polyline

                        If hContainer <> "" And cDxfData.Exist("TABLES") Then ' busco la hoja donde dibujar esta entidad

                            If cDxfData["TABLES"]["BLOCK_RECORD"].Exist(hContainer) Then      ' busco en los bloques
                                sName = cDxfData["TABLES"]["BLOCK_RECORD"][hContainer]["340"]

                                If drw.Sheets.Exist(sName) Then               ' busco en las Sheets
                                    obx = drw.Sheets[sName].entities

                                Else                                                               ' busco en otro lado
                                    obx = hContainers[hContainer]
                                End If

                            End If
                        Else    ' los DXF viejos no tienen contenedores,   ni paperspace, probabÃ±lemente

                            obx = drw.Sheet.entities
                        End If

                    End If

                    Select Case entNueva.Gender
                        Case "HATCH", "INSERT", "POLYLINE", "POLYLINE_2D"
                            hContainers.Add(entNueva.pBlock.entities, entNueva.Id)
                    End Select

                    If obx Then

                        obx.Add(entNueva, sId)
                        ' pero , ademas

                        'drw.Entities.Add(entNueva, sId)
                    Else
                        Debug "Contenedor no encontrado, van al Model", hContainer
                        drw.Sheet.entities.Add(entNueva, sId)
                    End If

                    ' If e[dxf.codEntity] = "POLYLINE" Then
                    '     flgIsPolyline = True
                    '     pBlockPolyline = New Block
                    '     pBlockPolyline.entities = New Collection
                    '
                    '     entNueva.pBlock = pBlockPolyline
                    ' End If
                    ' If e[dxf.codEntity] = "SEQEND" And flgIsPolyline = True Then
                    '     flgIsPolyline = False
                    '     pBlockPolyline = Null
                    ' End If
                    fTime = (Timer - t)
                    ReadTimes[entNueva.Gender] += fTime
                    ReadEntities[entNueva.Gender] += 1
                    ' If entNueva.Gender = "HATCH" Then
                    '     ReadTimes.Add(fTime, entNueva.Handle)
                    ' Endif
                    ' If entNueva.HandleOwner = "640" Then Debug "640", entNueva.Gender

                    entNueva = Null                                           ' limpiamos

                End If

            End If
        End If
    Next

End

'' Transforma una coleccion en dos array de strings
Public Sub DigestColeccion(c As Collection, ByRef sClaves As String[], ByRef sValues As String[])

    Dim lpValue, lpclave As String
    Dim i As Integer

    sClaves.Clear
    sValues.Clear

    For Each lpValue In c
        lpclave = c.Key
        I = InStr(lpclave, "_")
        If i > 0 Then lpclave = Left(lpclave, i - 1)
        sClaves.Add(lpclave)           ' el codigo es el tipo de variable
        sValues.Add(lpValue)

    Next

End

' Public Function UpdateGraphicsFromDXF(cData As Collection, drw As Drawing, Optional handles As String[] = [])
'
'     Dim cEntity As Collection, entNueva As Entity
'
'     gcd.debugInfo("Importing DXF data",,, True)
'
'
'     gcd.debugInfo("Importados los Blocks",,, True)
'
'     If handles.Count = 0 Then                   ' Update all entities
'
'
'
'     Else                                        ' Update only entities with handles provided
'
'         For Each sHandle As String In handles
'
'             If cData["ENTITIES"].Exist(sHandle) Then  ' la actualizo
'
'                 entNueva = New Entity                                       ' entonces, creamos una nueva
'                 If clsEntities.ImportJsonToEntity(cData["ENTITIES"][sHandle], entNueva) Then         ' si esta implementada, llenamos los datos
'
'                     drw.Entities.Add(entNueva)
'                     entNueva = Null                                           ' limpiamos
'
'                 Endif
'             Endif
'
'         Next
'         gcd.debugInfo("Importadas las Entidades",,, True)
'
'     End If
'
'     'gcd.FillLayers(drw)         ' esto necesita que arrLayers y arrEntities esten cargados
'     'gcd.FillSheets(drw)
'     'depretest gcd.FillInserts(drw)
'
'
' End

Public Function ReadObjectsFromDXF(cData As Collection, drw As Drawing)

    Dim cObject As Collection, entNueva As Entity
    Dim sClaves, sValues As New String[]
    Dim s As Sheet

    gcd.debugInfo("Importing DXF object data",,, True)

    If Not cData.Exist("OBJECTS") Then Return
    For Each cObject In cData["OBJECTS"]

        If cObject["0"] = "LAYOUT" Then

            Me.DigestColeccion(cObject, ByRef sClaves, ByRef sValues)
            s = New Sheet
            objLayout.importDXF(s, cObject)
            drw.Sheets.Add(s, s.Id)
            If LCase(s.Name) = "model" Then
                s.IsModel = True
                drw.Sheet = s

            End If

        Endif

    Next

End

'' busca un bloque con ese block record
Private Function GetBlock(cBlocks As Collection, hBlockRecord As String) As Block

    Dim b As Block

    For Each b In cBlocks
        If b.IdContainer = hBlockRecord Then Return b

    Next

    Return Null

End
