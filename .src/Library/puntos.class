' Gambas class file

' m-designer
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA

' Tool maintained by Terco

' Some of this gotten from
' http://www.dcs.gla.ac.uk/~pat/52233/slides/Geometry1x1.pdf

' Tools helpers

' Operations on the element's vertices

Create Static
Create Private
' Fast Unsafe
Public HookSize As Integer = 16                       ' for use with poi
Public NumericTolerance As Float = 1e-7

'' Returns center, radious, start angle, end angle of an arc defined by 3 given points
Public Function Arc3Point(px1 As Float, py1 As Float, px2 As Float, py2 As Float, px3 As Float, py3 As Float) As Float[]

    Dim answer As Float[]

    ' mid points of segments
    Dim mx1, my1, mx2, my2 As Float

    mx1 = (px1 + px2) / 2
    my1 = (py1 + py2) / 2

    mx2 = (px3 + px2) / 2
    my2 = (py3 + py2) / 2

    ' angles
    Dim Ang1, Ang2 As Float
    Ang1 = Ang(px2 - px1, py2 - py1)
    Ang2 = Ang(px3 - px2, py3 - py2)

    ' anther point in the normal to segments
    Dim Ax1, Ay1, Ax2, Ay2 As Float
    Ax1 = mx1 - 100 * Sin(ang1)
    Ay1 = my1 + 100 * Cos(ang1)

    Ax2 = mx2 - 100 * Sin(ang2)
    Ay2 = my2 + 100 * Cos(ang2)

    ' the center is the intersection of the normals
    answer = lineLineIntersection2(mx1, my1, ax1, ay1, mx2, my2, ax2, ay2)

    ' the radious
    answer.Add(distancia(px1, py1, answer[0], answer[1]))

    ' start and end angles
    answer.Add(Ang(px3 - answer[0], py3 - answer[1]))
    answer.Add(Ang(px1 - answer[0], py1 - answer[1]))

    Return answer

End

'' Returns n 2D trianlges x0,y0,x1,y1,x2,y2 , x0,y0,x1,y1,x2,y2 and so on
Public Function PolygonTriangulation(fPolygon As Float[]) As Float[]

    'Dim UsedTracts As New Boolean[]
    Dim Wasted As New Float[]
    'Dim ExtraTract2 As New Integer[]
    Dim fPoly As New Float[]
    Dim Triangles As New Float[]
    Dim TriangleTest As New Float[]
    Dim i, iTramo, iCompare As Integer
    Dim EsUtil, EsPrimero As Boolean

    fPoly.Insert(fPolygon.Copy())

    'chequeos iniciales
    'If fPoly.Count < 5 Then Return Null     ' hay menos de 3 puntos
    If fPoly.Count <= 6 Then Return fPoly ' si hay 3 puntos, devulvo el trianglo mismo

    iTramo = 0  ' empiezo por el primer tramo
    Do
        EsUtil = False
        EsPrimero = False
        ' ' vamos por tramos
        TriangleTest.clear

        ' tramo a resolver i a i+1
        TriangleTest.Insert(fPoly.Copy(iTramo * 2, 4))

        ' primero chequeo si el tramos i+1 a i+2 es util
        TriangleTest.Insert(fPoly.Copy(iTramo * 2 + 4, 2))

        ' para que este triangulo sea util, ningun punto del poligono debe estar dentro de el
        EsUtil = True
        For i = 0 To fPoly.Count / 2 - 1
            If i <> iTramo And i <> iTramo + 1 And i <> iTramo + 2 Then
                If Me.IsPointInTri(fPoly.Copy(iTramo * 2, 2), fPoly.Copy(iTramo * 2 + 2, 2), fPoly.Copy(iTramo * 2 + 4, 2), fPoly.Copy(i * 2, 2)) Then
                    'If isInside(TriangleTest, fPoly[i * 2], fPoly[i * 2 + 1]) Then

                    EsUtil = False
                    Break
                End If
            Endif
        Next

        If EsUtil Then
            Triangles.Insert(fPoly.Copy(iTramo * 2, 2))
            Triangles.Insert(fPoly.Copy(iTramo * 2 + 2, 2))
            Triangles.Insert(fPoly.Copy(iTramo * 2 + 4, 2))
            wasted.Insert(fPoly.Extract(iTramo * 2 + 2, 2))
            iTramo = 0
            Continue
        Endif
        ' No es util, vamos por el otro lado del tramo pivot

        TriangleTest.clear

        ' tramo a resolver i a i+1
        TriangleTest.Insert(fPoly.Copy(iTramo * 2, 4))

        ' chequeo si el tramos i a i-1 es util
        If iTramo = 0 Then 'caso especial
            ' primero chequeo si el tramos i+1 a i+2 es util

            EsPrimero = True
            iCompare = fPoly.Count / 2 - 1

        Else

            iCompare = iTramo - 1
        End If
        TriangleTest.Insert(fPoly.Copy(iCompare * 2, 2))

        ' para que este triangulo sea util, ningun punto del poligono debe estar dentro de el
        EsUtil = True
        For i = 0 To fPoly.Count / 2 - 1
            If i <> iTramo And i <> iTramo + 1 And i <> iCompare Then
                If Me.IsPointInTri(fPoly.Copy(iTramo * 2, 2), fPoly.Copy(iTramo * 2 + 2, 2), fPoly.Copy(iCompare * 2, 2), fPoly.Copy(i * 2, 2)) Then
                    'If isInside(TriangleTest, fPoly[i * 2], fPoly[i * 2 + 1]) Then

                    EsUtil = False
                    Break
                End If
            Endif
        Next

        If EsUtil Then
            Triangles.Insert(fPoly.Copy(iTramo * 2, 2))
            Triangles.Insert(fPoly.Copy(iTramo * 2 + 2, 2))
            Triangles.Insert(fPoly.Copy(iCompare * 2, 2))
            wasted.Insert(fPoly.Extract(iTramo * 2, 2))
            iTramo = 0
            Continue
        Endif

        ' pruebo con otro tramo
        Inc iTramo
        'If Not EsUtil Then Break

    Loop Until (fPoly.Count = 6) Or (iTramo * 2 + 4 > fPoly.Max) ' 3 vertices or error

    Triangles.Insert(fPoly.Copy())
    Return Triangles

End

'' Returns the index in the array of pairs that is near the given point using HookSize parameter
Public Function FindPOI(xr As Float, yr As Float, arr As Float[], hook As Float) As Float[]

    Dim i As Integer

    For i = 0 To arr.Max Step 2

        If ((arr[i] - hook) < Xr And (arr[i] + hook) > Xr) Or ((arr[i] - hook) > Xr And (arr[i] + hook < Xr)) Then

            If ((arr[i + 1] - hook) < yr And (arr[i + 1] + hook) > yr) Or ((arr[i + 1] - hook) > yr And (arr[i + 1] + hook) < yr) Then

                Return [arr[i], arr[i + 1], i / 2]

            End If

        Endif

    Next

    Return [xr, yr, -1]           ' no points near

End

'' Returns the index in the array of pairs that is near the given point using HookSize parameter
Public Function FindPOILines(xreal As Float, Yreal As Float, arr As Float[], tolerance As Float) As Integer

    Dim i As Integer

    For i = 0 To arr.count - 4 Step 4
        If puntos.doIntersect(xreal - tolerance / 2, Yreal, Xreal + tolerance / 2, Yreal, arr[i + 0], arr[i + 1], arr[i + 2], arr[i + 3]) Or puntos.doIntersect(xreal, Yreal - tolerance / 2, Xreal, Yreal + tolerance / 2, arr[i + 0], arr[i + 1], arr[i + 2], arr[i + 3]) Then ' its above me

            Return i / 4
        End If
    Next
    Return -1

End

'' Returns the index in the array of pairs that is near the given point using HookSize parameter
Public Function FindPOIPoligon(xr As Float, yr As Float, arr As Float[], arrIndexes As Integer[], arrNElements As Integer[]) As Integer

    Dim i As Integer

    For i = 0 To arrIndexes.Max

        If isInside(arr, xr, yr, arrIndexes[i], arrNElements[i]) Then Return i

    Next

    Return -1

End

Public Function distancia(x1 As Float, y1 As Float, x2 As Float, y2 As Float) As Float
    ' returns distance between points

    Return ((x2 - x1) ^ 2 + (y2 - y1) ^ 2) ^ 0.5

End

Public Function InBetween(x As Float, x1 As Float, x2 As Float) As Boolean
    ' determine if a number is between the other two
    ' this is valid for negative values

    If (x1 <= X And x2 >= X) Or (x1 >= X And x2 <= X) Then Return True Else Return False

End

Public Function InBetweenNotEqual(x As Float, x1 As Float, x2 As Float) As Boolean
    ' determine if a number is between the other two
    ' this is valid for negative values

    If (x1 < X And x2 > X) Or (x1 > X And x2 < X) Then Return True Else Return False

End

'' Devuelve el segmento en el que esta el punto, considerando la tolerancia numerica
'' o -1 si no estan en ningun segmento. Si el punto esta en un vertice, devuelve el primer segmento.
Public Function inPolySegment(poligon As Float[], px As Float, py As Float, Optional Tolerance As Float = 0) As Integer

    Dim i As Integer

    If tolerance = 0 Then tolerance = NumericTolerance

    For i = 0 To poligon.Count - 4 Step 2

        If PointToLineDistance([px, py], poligon.Copy(i, 4)) <= tolerance Then Return (i + 2) / 2

    Next

    Return -1

End

'' determines if a XZ point is in the area of other by proximity parameter
'' this is valid for negative values
'' Float version
Public Function Around(p1x As Float, p1z As Float, p2x As Float, p2z As Float, prox As Float) As Boolean

    ' determines if a XZ point is in the area of other by proximity parameter
    ' this is valid for negative values

    If InBetween(p1x, p2x - prox, p2x + prox) And InBetween(p1z, p2z - prox, p2z + prox) Then Return True Else Return False

End

Public Function doIntersect(p1x As Float, p1y As Float, q1x As Float, q1y As Float, p2x As Float, p2y As Float, q2x As Float, q2y As Float) As Boolean

    Dim o1, o2, o3, o4 As Integer
    ' Find the four orientations needed For
    ' general And special cases
    o1 = orientation(p1x, p1y, q1x, q1y, p2x, p2y)
    o2 = orientation(p1x, p1y, q1x, q1y, q2x, q2y)
    o3 = orientation(p2x, p2y, q2x, q2y, p1x, p1y)
    o4 = orientation(p2x, p2y, q2x, q2y, q1x, q1y)

    ' General Case
    If (o1 <> o2 And o3 <> o4) Then
        Return True
    Endif

    ' Special Cases
    ' p1x , p1y, q1x ,q1y And p2x , p2y are colinear And
    ' p2x , p2y lies On segment p1x , p1yq1x ,q1y
    If (o1 = 0 And onSegment(p1x, p1y, p2x, p2y, q1x, q1y)) Then
        Return True
    Endif

    ' p1x , p1y, q1x ,q1y And p2x , p2y are colinear And
    ' q2x ,q2y lies On segment p1x , p1yq1x ,q1y
    If (o2 = 0 And onSegment(p1x, p1y, q2x, q2y, q1x, q1y)) Then
        Return True
    Endif

    ' p2x , p2y, q2x ,q2y And p1x , p1y are colinear And
    ' p1x , p1y lies On segment p2x , p2yq2x ,q2y
    If (o3 = 0 And onSegment(p2x, p2y, p1x, p1y, q2x, q2y)) Then
        Return True
    Endif

    ' p2x , p2y, q2x ,q2y And q1x ,q1y are colinear And
    ' q1x ,q1y lies On segment p2x , p2yq2x ,q2y
    If (o4 = 0 And onSegment(p2x, p2y, q1x, q1y, q2x, q2y)) Then
        Return True
    Endif

    ' Doesn 't fall in any of the above cases
    Return False

End

' To find orientation Of ordered triplet(p, q, r).
' The function returns following values
' 0 - - > p, q And r are colinear
' 2 - - > Clockwise                     WATCH OUT: WE ARE USING AND INVERTED Y AXIS, SO THIS WILL RETURN 2 to clockwise
' 1 - - > Counterclockwise              functions on the internet are the other way
Public Function orientation(px As Float, py As Float, qx As Float, qy As Float, rx As Float, ry As Float) As Integer

    Dim v As Float

    v = (qy - py) * (rx - qx) - (qx - px) * (ry - qy)
    'Print v
    '

    If (v = 0) Then Return 0 ' colinear

    If (v > 0) Then Return 2

    If (v < 0) Then Return 1

End

' Given three colinear points p, q, r,
' the function checks If point q lies
' On Line segment 'pr'
Public Function onSegment(px As Float, py As Float, qx As Float, qy As Float, rx As Float, ry As Float) As Boolean

    If (qx <= Max(px, rx) And
            qx >= Min(px, rx) And
            qy <= Max(py, ry) And
            qy >= Min(py, ry)) Then
        Return True
    Endif

    Return False

End

Public Function Sign(p1 As Float[], p2 As Float[], p3 As Float[]) As Float

    Return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])

End

Public Function IsPointInTri(v1 As Float[], v2 As Float[], v3 As Float[], pt As Float[]) As Boolean

    Dim b1, b2, b3 As Boolean

    b1 = Sign(pt, v1, v2) < 0.0
    b2 = Sign(pt, v2, v3) < 0.0
    b3 = Sign(pt, v3, v1) < 0.0

    Return ((b1 = b2) And (b2 = b3))

End
'' InsideTriangle decides If a point P Is Inside Of the triangle
''  defined by A, B, C.

' Public Function InsideTriangle(AA As Float[], BB As Float[], CC As Float[], P As Float[]) As Boolean
'
'     Dim ax, ay, bx, by, cx, cy, apx, apy, bpx, bpy, cpx, cpy, cCROSSap, bCROSScp, aCROSSbp As Float
'
'     ax = CC[0] - BB[0]
'     ay = CC[1] - BB[1]
'     bx = AA[0] - CC[0]
'     by = AA[1] - CC[1]
'     cx = BB[0] - AA[0]
'     cy = BB[1] - AA[1]
'     apx = P[0] - AA[0]
'     apy = P[1] - AA[1]
'     bpx = P[0] - BB[0]
'     bpy = P[1] - BB[1]
'     cpx = P[0] - CC[0]
'     cpy = P[1] - CC[1]
'     aCROSSbp = ax * bpy - ay * bpx
'     cCROSSap = cx * apy - cy * apx
'     bCROSScp = bx * cpy - by * cpx
'
'     ' vemos el caso especial doonde coincide
'     If cpx = 0 And cpy = 0 Then Return False
'     If bpx = 0 And bpy = 0 Then Return False
'     If apx = 0 And apy = 0 Then Return False
'
'     Return ((aCROSSbp >= 0.0) And (bCROSScp >= 0.0) And (cCROSSap >= 0.0))
'
' End

' Returns True If the point p lies
' inside the polygon[] With n vertices
Public Function isInside(polygon As Float[], px As Float, py As Float, Optional StartIndex As Integer = 0, Vertices As Integer = 0) As Boolean

    ' There must be at least 3 vertices In polygon[]
    If vertices = 0 Then vertices = polygon.Count / 2

    If (Vertices < 3) Then
        Return False
    Endif

    ' Create a point For Line segment From p To infinite
    Dim extremeX, extremeY As Float   '= New Point(INF, p.y)

    extremeX = 10E10
    extremeY = py

    ' Count intersections Of the above Line
    ' With sides Of polygon
    Dim count As Integer = 0, i As Integer = 0
    Dim next1 As Integer
    For i = StartIndex To vertices * 2 - 1 Step 2

        Next1 = i + 2
        If i = polygon.max - 1 Then next1 = 0

        ' Check If the Line segment From 'p' to
        ' 'extreme' intersects with the line
        ' segment From 'polygon[i]' to 'polygon[next]'

        If (doIntersect(polygon[i], polygon[i + 1], polygon[Next1], polygon[Next1 + 1], px, py, extremeX, extremeY)) Then
            ' If the point 'p' is colinear with line
            ' segment 'i-next', then check if it lies
            ' On segment.If it lies, Return True, otherwise False

            If (orientation(polygon[i], polygon[i + 1], px, py, polygon[Next1], polygon[next1 + 1]) = 0) Then

                Return onSegment(polygon[i], polygon[i + 1], px, py, polygon[Next1], polygon[next1 + 1])

            Endif

            Inc count

        Endif

    Next

    ' Return True If count Is Odd, False otherwise
    Return (count Mod 2 = 1) ' Same As (count % 2 = 1)

End

Public Function RotateFromPointWithAngle(CenterX As Float, CenterZ As Float, angle As Float, Px As Float, Pz As Float) As Float[]

    Dim s, c, xnew, ynew As Float

    s = Sin(angle)
    c = Cos(angle)

    ' translate point back To origin:
    px -= CenterX
    pz -= CenterZ

    ' rotate point
    xnew = px * c - pz * s
    ynew = px * s + pz * c

    ' translate point back:
    px = xnew + CenterX
    pz = ynew + CenterZ

    Return [px, pz]

End

Public Function RotateWithSinCos(Px As Float, Pz As Float, S As Float, C As Float) As Float[]

    Dim xnew, ynew As Float

    ' translate point back To origin:

    ' rotate point
    xnew = px * c - pz * s
    ynew = px * s + pz * c

    Return [xnew, ynew]

End

Public Function RotateFromPointWithSinCos(CenterX As Float, CenterZ As Float, S As Float, C As Float, Px As Float, Pz As Float) As Float[]

    Dim xnew, ynew As Float

    ' translate point back To origin:
    px -= CenterX
    pz -= CenterZ

    ' rotate point
    xnew = px * c - pz * s
    ynew = px * s + pz * c

    ' translate point back:
    px = xnew + CenterX
    pz = ynew + CenterZ

    Return [px, pz]

End

Public Function lineLineIntersection(A As Float[], B As Float[], C As Float[], D As Float[]) As Float[]

    '     / / Line AB represented As A1x + b1y = c1
    Dim a1 As Float = B[1] - A[1]
    Dim b1 As Float = A[0] - B[0]
    Dim c1 As Float = a1 * (A[0]) + b1 * (A[1])
    '
    '     / / Line CD represented As A2x + b2y = c2
    Dim a2 As Float = D[1] - C[1]
    Dim b2 As Float = C[0] - D[0]
    Dim c2 As Float = a2 * (C[0]) + b2 * (C[1])
    '
    Dim determinant As Float = a1 * b2 - a2 * b1
    '
    If (determinant = 0) Then
        '
        '         / / The lines are parallel.This Is Simplified
        '         / / by returning a pair Of FLT_MAX
        Return []
        '
    Else
        '
        Dim x As Float = (b2 * c1 - b1 * c2) / determinant
        Dim y As Float = (a1 * c2 - a2 * c1) / determinant
        Return [x, y]
    End If

End
'' Devuelve la interseccion de A-B con D-C

Public Function lineLineIntersection2(Ax As Float, Ay As Float, Bx As Float, By As Float, Cx As Float, Cy As Float, Dx As Float, Dy As Float) As Float[]

    '     / / Line AB represented As A1x + b1y = c1
    Dim a1 As Float = By - Ay
    Dim b1 As Float = Ax - Bx
    Dim c1 As Float = a1 * (Ax) + b1 * (Ay)
    '
    '     / / Line CD represented As A2x + b2y = c2
    Dim a2 As Float = Dy - Cy
    Dim b2 As Float = Cx - Dx
    Dim c2 As Float = a2 * (Cx) + b2 * (Cy)
    '
    Dim determinant As Float = a1 * b2 - a2 * b1

    ' veo el caso particular q coincidan los extremos

    If ax = cx And ay = cy Then Return [ax, ay]
    If ax = dx And ay = dy Then Return [ax, ay]

    If bx = cx And by = cy Then Return [bx, by]
    If bx = dx And by = dy Then Return [bx, by]

    '
    If (determinant = 0) Then
        '
        '         / / The lines are parallel.This Is Simplified
        '         / / by returning a pair Of FLT_MAX
        Return [] 'Null
        '
    Else
        '
        Dim x As Float = (b2 * c1 - b1 * c2) / determinant
        Dim y As Float = (a1 * c2 - a2 * c1) / determinant
        Return [x, y]
    End If

End

' Devuelve un conjunto de lineas que representan la interseccion de una linea con una polilinea cerrada
Public Function LinePolyIntersection(flxLine As Float[], flxPoly As Float[]) As Float[]

    ' la polylinea se considera cerrada y de mas de 3 puntos, caso contrario se devuelve la linea sin cambios
    ' la linea es de dos puntos , si esta afuera de la polilinea, se devuelve un array vacio
    ' Chequeos previos:
    Dim FirstInside As Boolean
    Dim LastInside As Boolean
    Dim i As Integer
    Dim flxRta As New Float[]

    If flxLine.Count <> 4 Then Return []

    If flxPoly.Count < 6 Then Return flxLine.Copy()

    ' fuera de los casos triviales, entonces armo el array de intersecciones
    Dim flxIntersections As New Float[]

    ' determino si el primer punto esta dentro de la poly
    If puntos.isInside(flxPoly, flxLine[0], flxLine[1]) Then FirstInside = True

    ' y el ultimo
    If puntos.isInside(flxPoly, flxLine[2], flxLine[3]) Then LastInside = True

    ' busco todas las intersecciones de la linea con la polilinea
    For i = 0 To flxPoly.count - 4 Step 2
        If puntos.doIntersect(flxLine[0], flxLine[1], flxLine[2], flxLine[3], flxPoly[i + 0], flxPoly[i + 1], flxPoly[i + 2], flxPoly[i + 3]) Then
            flxIntersections.Insert(puntos.lineLineIntersection2(flxLine[0], flxLine[1], flxLine[2], flxLine[3], flxPoly[i + 0], flxPoly[i + 1], flxPoly[i + 2], flxPoly[i + 3]))
        Endif
    Next
    ' y el cierre de la poly
    If puntos.doIntersect(flxLine[0], flxLine[1], flxLine[2], flxLine[3], flxPoly[flxPoly.Max - 1], flxPoly[flxPoly.Max], flxPoly[0], flxPoly[1]) Then
        flxIntersections.Insert(puntos.lineLineIntersection2(flxLine[0], flxLine[1], flxLine[2], flxLine[3], flxPoly[flxPoly.Max - 1], flxPoly[flxPoly.Max], flxPoly[0], flxPoly[1]))
    Endif

    ' si el primer punto esta adentro, pero no se da el caso particular que coincide con parte de la polilinea, lo agrego

    If flxIntersections.Count > 0 Then

        If FirstInside Then
            If Not EqualPoints(flxLine[0], flxLine[1], flxIntersections[0], flxIntersections[1]) Then

                If Not EqualPoints(flxLine[0], flxLine[1], flxIntersections[flxIntersections.Max - 1], flxIntersections[flxIntersections.Max]) Then

                    flxRta.Insert(flxLine.Copy(0, 2))
                End If
            End If
        End If

        ' y luego agrego todas las intersecciones
        flxRta.Insert(flxIntersections.Copy())

        ' si el ultimo punto esta adentro, pero no se da el caso particular que coincide con parte de la polilinea, lo agrego
        If LastInside Then
            If Not EqualPoints(flxLine[2], flxLine[3], flxIntersections[flxIntersections.Max - 1], flxIntersections[flxIntersections.Max]) Then
                If Not EqualPoints(flxLine[2], flxLine[3], flxIntersections[0], flxIntersections[1]) Then
                    flxRta.Insert(flxLine.Copy(2, 2))
                End If
            End If
        End If

    Else

        If FirstInside Then flxRta.Insert(flxLine.Copy(0, 2))
        If LastInside Then flxRta.Insert(flxLine.Copy(2, 2))

    End If

    If (flxRta.Count Mod 4) > 0 Then
        ' tengo un punto repetido, posiblemente porque haya una interseccion en un
        ' punto definitorio de la poligonal
        ' trato de eliminar puntos iguales
        For i = 0 To flxRta.Max - 2 Step 2
            If i > flxRta.Max - 3 Then Break
            If EqualPoints(flxRta[i], flxRta[i + 1], flxRta[i + 2], flxRta[i + 3]) Then
                ' remuevo uno de los dos
                flxRta.Remove(i, 2)

            Endif
        Next
    End If
    If flxRta.Count = 2 Then Return []

    Return flxRta

End

' This function is to solve floating point problems
Public Function EqualPoints(x1 As Float, y1 As Float, x2 As Float, y2 As Float) As Boolean

    If (CSingle(x1) = CSingle(x2)) And (CSingle(y1) = CSingle(y2)) Then Return True Else Return False

End

' devuelve un conjunto de lineas que representan la interseccion de dos polilineas, la primera
' es abierta; la segunda, cerrada
Public Function PolyPolyIntersection(flxPolyOpen As Float[], flxPolyClosed As Float[]) As Float[]

    Dim i As Integer

    Dim flxRta As New Float[]

    For i = 0 To flxPolyOpen.Count - 4 Step 2
        flxRta.Insert(LinePolyIntersection(flxPolyOpen.Copy(i, 4), flxPolyClosed))
    Next

    Return flxRta

End

Public Function PointToLineDistance(fPoint As Float[], fLine As Float[]) As Float

    ' adaptado de
    ' https://www.mathopenref.com/coordpointdisttrig.html
    Dim E As Float[]

    Dim CE, angE As Float

    ' veo los casos mas simples

    If fLine[0] = fLine[2] Then ' la linea es vertical
        Return fLine[0] - fPoint[0]

    Else If fLine[1] = fLine[3] Then ' la linea es horizontal
        Return fLine[1] - fPoint[1]

    Endif

    e = lineLineIntersection(fPoint, [10e10, fPoint[1]], [fLine[0], fLine[1]], [fLine[2], fLine[3]])

    CE = fPoint[0] - e[0]

    angE = ATan2(fLine[3] - fLine[1], fLine[2] - fLine[0])

    ' Debug "Radio", ce
    ' Debug "angulo", angE
    ' Debug "distancia", CE * Sin(angE)
    Return CE * Sin(angE)

End

'' Returns the acute angle between two vectors
Public Function Angle(vector1 As Float[], vector2 As Float[]) As Float

    Dim alfa, beta, gamma, l As Float

    alfa = Ang(vector1[0], vector1[1])
    beta = Ang(vector2[0], vector2[1])
    gamma = beta - alfa

    If gamma < 0 Then gamma += 2 * Pi
    If gamma > Pi Then gamma -= Pi

    Return gamma

End

'' Returns the acute angle between two vectors, with negatives
Public Function Angle2(vector1 As Float[], vector2 As Float[]) As Float

    Dim alfa, beta, gamma, l As Float

    alfa = Ang(vector1[0], vector1[1])
    beta = Ang(vector2[0], vector2[1])
    gamma = beta - alfa

    Return gamma

End

Public Function ReboundVector(vector As Float[], wall As Float[]) As Float[]

    Dim alfa, beta, gamma, l As Float

    alfa = Ang(vector[0], vector[1])
    beta = Ang(wall[0], wall[1])
    gamma = beta * 2 - alfa

    l = distancia(0, 0, vector[0], vector[1])
    Return [Cos(gamma) * l, Sin(gamma) * l]

End

Public Sub Normalize(v As Float[])

    Dim l As Float, i As Integer

    For i = 0 To v.Max
        l += v[i] * v[i]
    Next
    l = Sqr(l)
    For i = 0 To v.Max
        v[i] /= l
    Next

End

Public Function Dot(v1 As Float[], v2 As Float[]) As Float

    Return v1[0] * v2[0] + v1[1] * v2[1]

End

Public Function Translate(points As Float[], dx As Float, dy As Float) As Boolean

    Dim i As Integer

    For i = 0 To points.max Step 2
        points[i] += dx
        points[i + 1] += dy
    Next

End

'' Angle must be in Radians
Public Function Rotate(points As Float[], Radians As Float)

    Dim i As Integer
    Dim s, c, xnew, ynew As Float

    s = Sin(Radians)
    c = Cos(Radians)

    For i = 0 To points.max Step 2

        ' rotate point
        xnew = points[i] * c - points[i + 1] * s
        ynew = points[i] * s + points[i + 1] * c

        points[i] = xnew
        points[i + 1] = ynew
    Next

End

Public Function Scale(points As Float[], Sx As Float, Sy As Float) As Boolean

    Dim i As Integer

    For i = 0 To points.max Step 2
        points[i] *= Sx
        points[i + 1] *= Sy
    Next

End

'' Devuelve True si el poligono esta dentro del rectangulo
Public Function IsPoligonInsideRect(poligon As Float[], x0 As Float, y0 As Float, x1 As Float, y1 As Float, Optional StartIndex As Integer = 0, TotalElements As Integer = 0) As Boolean

    Dim i As Integer

    Dec TotalElements
    If totalelements < 0 Then TotalElements = poligon.Max

    For i = StartIndex To TotalElements Step 2
        If poligon[i] < x0 Then Return False
        If poligon[i] > x1 Then Return False
        If poligon[i + 1] < y0 Then Return False
        If poligon[i + 1] > y1 Then Return False
    Next
    Return True

End

Public Function IsPoligonSelfIntersecting(poligon As Float[]) As Boolean

    ' para que esta funcion sea util, no debe tener en cuenta los puntos en comun de los segentos, sino
    ' dara falsos positivos
    Dim i, ii As Integer
    Dim TestX0, TestX1, TestY0, TestY1 As Float
    Dim CrossPoint As New Float[]

    If poligon.count < 8 Then Return False
    For i = 0 To poligon.Max - 1 Step 2
        If i = poligon.Max - 1 Then
            TestX0 = poligon[poligon.Max - 1]
            TestY0 = poligon[poligon.Max]
            TestX1 = poligon[0]
            TestY1 = poligon[1]

        Else
            TestX0 = poligon[i]
            TestY0 = poligon[i + 1]
            TestX1 = poligon[i + 2]
            TestY1 = poligon[i + 3]
        End If
        For ii = 0 To poligon.Max - 2 Step 2
            If i = ii Then Continue ' es el mismo segmento
            CrossPoint = lineLineIntersection2(TestX0, TestY0, TestX1, TestY1, poligon[ii], poligon[ii + 1], poligon[ii + 2], poligon[ii + 3])
            If CrossPoint Then ' tenemos una interseccion, pero vamos a considerar valida si no coincide con los extremos
                'If Not (CrossPoint[0] = poligon[ii] And CrossPoint[1] = poligon[ii + 1]) Or (CrossPoint[0] = poligon[ii + 2] And CrossPoint[1] = poligon[ii + 3]) Then
                ' debo testear que la interseccion este dentro del tramo
                If InBetweenNotEqual(CrossPoint[0], poligon[ii], poligon[ii + 2]) And InBetweenNotEqual(CrossPoint[1], poligon[ii + 1], poligon[ii + 3]) Then
                    If InBetweenNotEqual(CrossPoint[0], TestX0, TestX1) And InBetweenNotEqual(CrossPoint[1], TestY0, TestY1) Then

                        Return True
                    End If
                End If

            Endif
        Next

        CrossPoint = lineLineIntersection2(TestX0, TestY0, TestX1, TestY1, poligon[poligon.Max - 1], poligon[poligon.Max], poligon[0], poligon[1])
        If CrossPoint Then ' tenemos una interseccion, pero vamos a considerar valida si no coincide con los extremos
            'If Not (CrossPoint[0] = poligon[poligon.Max - 1] And CrossPoint[1] = poligon[poligon.Max]) Then Return True

            'If Not (CrossPoint[0] = poligon[0] And CrossPoint[1] = poligon[1]) Then Return True

            If InBetweenNotEqual(CrossPoint[0], poligon[poligon.Max - 1], poligon[0]) And InBetweenNotEqual(CrossPoint[1], poligon[poligon.Max], poligon[1]) Then
                If InBetweenNotEqual(CrossPoint[0], TestX0, TestX1) And InBetweenNotEqual(CrossPoint[1], TestY0, TestY1) Then

                    Return True
                End If
            End If
        Endif

    Next

    Return False

End

'' Devuelve True si el poligono cruza la linea x0,y0 - x1,y1
Public Function IsPoligonCrossingLine(poligon As Float[], x0 As Float, y0 As Float, x1 As Float, y1 As Float, Optional StartIndex As Integer = 0, TotalElements As Integer = 0) As Boolean

    Dim i As Integer

    Dec TotalElements
    If totalelements < 0 Then TotalElements = poligon.Max

    For i = StartIndex To TotalElements - 3 Step 2
        If doIntersect(poligon[i], poligon[i + 1], poligon[i + 2], poligon[i + 3], x0, y0, x1, y1) Then Return True
    Next
    ' cierre del poligono, puntos inicial y final
    If doIntersect(poligon[StartIndex], poligon[StartIndex + 1], poligon[TotalElements - 1], poligon[TotalElements], x0, y0, x1, y1) Then Return True

    Return False

End

'' Devuelve True si el poligono cruza la linea x0,y0 - x1,y1
Public Function IsPoligonCrossingRect(poligon As Float[], x0 As Float, y0 As Float, x1 As Float, y1 As Float, Optional StartIndex As Integer = 0, TotalElements As Integer = 0) As Boolean

    Dim i As Integer

    If poligon.Count = 0 Then Return False
    If IsPoligonCrossingLine(poligon, x0, y0, x1, y0, StartIndex, TotalElements) Then Return True
    If IsPoligonCrossingLine(poligon, x0, y1, x1, y1, StartIndex, TotalElements) Then Return True
    If IsPoligonCrossingLine(poligon, x0, y0, x0, y1, StartIndex, TotalElements) Then Return True
    If IsPoligonCrossingLine(poligon, x1, y0, x1, y1, StartIndex, TotalElements) Then Return True
    Return False

End

'' Largo del poligono, o sea la suma del largo de cada tramo y, si
'' es cerrado, tambien suma del P0 al Pn
Public Function PoligonLength(points As Float[], Optional IsClosed As Boolean = True) As Float

    Dim i As Integer, l As Float

    For i = 0 To points.Count - 4 Step 2
        l += puntos.distancia(points[i], points[i + 1], points[i + 2], points[i + 3])
    Next
    If IsClosed Then l += puntos.distancia(points[0], points[1], points[points.max - 1], points[points.max])

    Return l

End

'' Area del poligono, OJO: si el poligono se cruza, esta funcion dara un resultado erroneo
Public Function PoligonArea(points As Float[]) As Float

    Dim i As Integer, area As Float

    For i = 0 To points.Count - 4 Step 2
        area += points[i] * points[i + 3] - points[i + 1] * points[i + 2]
    Next
    area += points[points.Max - 1] * points[1] - points[points.max] * points[0]

    Return Abs(area) / 2

End
